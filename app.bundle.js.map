{"version":3,"sources":["webpack:///app.bundle.js","webpack:///webpack/bootstrap c32d1e7bf0ecf85b6ab6","webpack:///./node_modules/axios/lib/utils.js","webpack:///./node_modules/axios/lib/defaults.js","webpack:///./node_modules/axios/lib/helpers/bind.js","webpack:///./node_modules/process/browser.js","webpack:///./node_modules/axios/lib/adapters/xhr.js","webpack:///./node_modules/axios/lib/core/createError.js","webpack:///./node_modules/axios/lib/cancel/isCancel.js","webpack:///./node_modules/axios/lib/cancel/Cancel.js","webpack:///./node_modules/axios/index.js","webpack:///./node_modules/axios/lib/axios.js","webpack:///./node_modules/is-buffer/index.js","webpack:///./node_modules/axios/lib/core/Axios.js","webpack:///./node_modules/axios/lib/helpers/normalizeHeaderName.js","webpack:///./node_modules/axios/lib/core/settle.js","webpack:///./node_modules/axios/lib/core/enhanceError.js","webpack:///./node_modules/axios/lib/helpers/buildURL.js","webpack:///./node_modules/axios/lib/helpers/parseHeaders.js","webpack:///./node_modules/axios/lib/helpers/isURLSameOrigin.js","webpack:///./node_modules/axios/lib/helpers/btoa.js","webpack:///./node_modules/axios/lib/helpers/cookies.js","webpack:///./node_modules/axios/lib/core/InterceptorManager.js","webpack:///./node_modules/axios/lib/core/dispatchRequest.js","webpack:///./node_modules/axios/lib/core/transformData.js","webpack:///./node_modules/axios/lib/helpers/isAbsoluteURL.js","webpack:///./node_modules/axios/lib/helpers/combineURLs.js","webpack:///./node_modules/axios/lib/cancel/CancelToken.js","webpack:///./node_modules/axios/lib/helpers/spread.js","webpack:///./src/app/index.js","webpack:///./src/app/supportCard.js","webpack:///./node_modules/localforage/dist/localforage.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/app/pushToggle.js","webpack:///./src/app/pushInfo.js","webpack:///./src/app/serverSubscription.js","webpack:///./src/app/service-worker.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","isArray","val","toString","isArrayBuffer","isFormData","FormData","isArrayBufferView","ArrayBuffer","isView","buffer","isString","isNumber","isUndefined","isObject","isDate","isFile","isBlob","isFunction","isStream","pipe","isURLSearchParams","URLSearchParams","trim","str","replace","isStandardBrowserEnv","navigator","product","window","document","forEach","obj","fn","length","key","merge","assignValue","result","arguments","extend","a","b","thisArg","bind","isBuffer","process","setContentTypeIfUnset","headers","value","utils","normalizeHeaderName","DEFAULT_CONTENT_TYPE","Content-Type","defaults","adapter","XMLHttpRequest","transformRequest","data","JSON","stringify","transformResponse","parse","e","timeout","xsrfCookieName","xsrfHeaderName","maxContentLength","validateStatus","status","common","Accept","method","args","Array","apply","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","setTimeout","this","runClearTimeout","marker","cachedClearTimeout","clearTimeout","cleanUpNextTick","draining","currentQueue","queue","concat","queueIndex","drainQueue","len","run","Item","array","noop","nextTick","push","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","settle","buildURL","parseHeaders","isURLSameOrigin","createError","btoa","config","Promise","resolve","reject","requestData","requestHeaders","request","loadEvent","xDomain","NODE_ENV","XDomainRequest","url","onprogress","ontimeout","auth","username","password","Authorization","open","toUpperCase","params","paramsSerializer","readyState","responseURL","indexOf","responseHeaders","getAllResponseHeaders","responseData","responseType","response","responseText","statusText","onerror","cookies","xsrfValue","withCredentials","read","undefined","toLowerCase","setRequestHeader","onDownloadProgress","addEventListener","onUploadProgress","upload","cancelToken","promise","then","cancel","abort","send","enhanceError","message","code","error","__CANCEL__","Cancel","createInstance","defaultConfig","context","Axios","instance","axios","create","instanceConfig","CancelToken","isCancel","all","promises","spread","default","constructor","isSlowBuffer","readFloatLE","slice","_isBuffer","interceptors","InterceptorManager","dispatchRequest","isAbsoluteURL","combineURLs","baseURL","chain","interceptor","unshift","fulfilled","rejected","shift","normalizedName","encode","encodeURIComponent","serializedParams","parts","v","toISOString","join","parsed","split","line","substr","resolveURL","href","msie","urlParsingNode","setAttribute","protocol","host","search","hash","hostname","port","pathname","charAt","originURL","test","userAgent","createElement","location","requestURL","E","input","block","charCode","String","output","idx","map","chars","charCodeAt","write","expires","path","domain","secure","cookie","Date","toGMTString","match","RegExp","decodeURIComponent","remove","now","handlers","use","eject","id","h","throwIfCancellationRequested","throwIfRequested","transformData","reason","fns","relativeURL","executor","TypeError","resolvePromise","token","source","callback","arr","_interopRequireDefault","urlBase64ToUint8Array","base64String","padding","repeat","base64","rawData","atob","outputArray","Uint8Array","initSubscription","serviceWorker","ready","registration","pushManager","getSubscription","subscription","updateSubscriptionUI","catch","console","updateServerSubscription","subscribe","userVisibleOnly","applicationServerKey","SAFE_APPLICATION_SERVER_KEY","log","pushSubscription","unsubscribe","removed","_pushToggle","updateSwitch","_pushInfo","displayPushInfo","_localforage2","getItem","savedSubscription","_evalSubscriptionCond","evalSubscriptionConditions","shouldUpdate","shouldDelete","_serverSubscription2","createSubscription","setItem","deleteSubscription","_id","newSubscription","displayServerResponse","displayServerError","endpointCondition","endpoint","_axios","_supportCard","_supportCard2","_localforage","_serverSubscription","_serviceWorker","swSupport","pushSupport","isSupported","register","subscriptionSwitch","changeEvent","checked","target","waitToggle","updateSupportCard","notSupportedCard","style","display","textContent","querySelector","supportStatus","global","require","f","t","r","u","1","_dereq_","oldQueue","immediate","task","scheduleDrain","Mutation","MutationObserver","WebKitMutationObserver","called","observer","element","createTextNode","observe","characterData","setImmediate","MessageChannel","scriptEl","onreadystatechange","parentNode","removeChild","documentElement","appendChild","channel","port1","onmessage","port2","postMessage","self","2","INTERNAL","resolver","state","PENDING","outcome","safelyResolveThenable","QueueItem","onFulfilled","onRejected","callFulfilled","otherCallFulfilled","callRejected","otherCallRejected","unwrap","func","returnValue","getThen","thenable","onError","onSuccess","tryToUnwrap","tryCatch","out","iterable","values","resolved","resolveFromAll","outValue","race","REJECTED","FULFILLED","3","4","_classCallCheck","Constructor","createBlob","properties","Blob","Builder","BlobBuilder","MSBlobBuilder","MozBlobBuilder","WebKitBlobBuilder","builder","append","getBlob","type","executeCallback","executeTwoCallbacks","errorCallback","_binStringToArrayBuffer","bin","buf","_checkBlobSupportWithoutCaching","idb","Promise$1","txn","transaction","DETECT_BLOB_SUPPORT_STORE","blob","objectStore","put","onabort","preventDefault","stopPropagation","oncomplete","matchedChrome","matchedEdge","parseInt","_checkBlobSupport","supportsBlobs","_deferReadiness","dbInfo","dbContext","dbContexts","deferredOperation","deferredOperations","dbReady","_advanceReadiness","pop","_getConnection","upgradeNeeded","db","close","dbArgs","openreq","onupgradeneeded","createObjectStore","storeName","oldVersion","ex","warn","newVersion","onsuccess","_getOriginalConnection","_getUpgradedConnection","_isUpgradeNeeded","defaultVersion","isNewStore","objectStoreNames","contains","isDowngrade","isUpgrade","incVersion","_encodeBlob","reader","FileReader","onloadend","__local_forage_encoded_blob","readAsBinaryString","_decodeBlob","encodedBlob","_isEncodedBlob","_fullyReady","_initReady","_dbInfo","_initStorage","options","ignoreErrors","forages","initPromises","j","forage","_defaultConfig","k","store","req","iterate","iterator","openCursor","iterationNumber","cursor","blobSupport","err","removeItem","clear","count","advanced","advance","keys","stringToBuffer","serializedString","encoded1","encoded2","encoded3","encoded4","bufferLength","bytes","BASE_CHARS","bufferToString","substring","serialize","valueType","toString$1","SERIALIZED_MARKER","TYPE_ARRAYBUFFER","TYPE_INT8ARRAY","TYPE_UINT8ARRAY","TYPE_UINT8CLAMPEDARRAY","TYPE_INT16ARRAY","TYPE_UINT16ARRAY","TYPE_INT32ARRAY","TYPE_UINT32ARRAY","TYPE_FLOAT32ARRAY","TYPE_FLOAT64ARRAY","fileReader","onload","BLOB_TYPE_PREFIX","TYPE_BLOB","readAsArrayBuffer","deserialize","SERIALIZED_MARKER_LENGTH","blobType","TYPE_SERIALIZED_MARKER_LENGTH","BLOB_TYPE_PREFIX_REGEX","matcher","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","_initStorage$1","dbInfoPromise","openDatabase","description","size","executeSql","serializer","localforageSerializer","getItem$1","results","rows","item","iterate$1","_setItem","retriesLeft","originalValue","sqlError","QUOTA_ERR","setItem$1","removeItem$1","clear$1","length$1","key$1","keys$1","_initStorage$2","keyPrefix","clear$2","localStorage","getItem$2","iterate$2","keyPrefixLength","key$2","keys$2","length$2","removeItem$2","setItem$2","callWhenReady","localForageInstance","libraryMethod","_args","arg","isLibraryDriver","driverName","driver","DriverType","_typeof","Symbol","indexedDB","webkitIndexedDB","mozIndexedDB","OIndexedDB","msIndexedDB","asyncStorage","_driver","webSQLStorage","localStorageWrapper","CustomDrivers","INDEXEDDB","LOCALSTORAGE","WEBSQL","DefaultDriverOrder","LibraryMethods","DefaultConfig","driverSupport","isSafari","platform","hasFetch","fetch","IDBKeyRange","LocalForage","_config","_driverSet","_initDriver","_ready","_wrapLibraryMethodsWithReady","setDriver","defineDriver","driverObject","complianceError","namingError","customDriverMethods","customDriverMethod","supportPromise","_support","supportResult","getDriver","getDriverPromise","getSerializer","serializerPromise","drivers","setDriverToConfig","extendSelfWithDriver","_extend","initDriver","supportedDrivers","driverPromiseLoop","currentDriverIndex","_getSupportedDrivers","oldDriverSetDone","supports","libraryMethodsAndProperties","localforage_js","g","Function","eval","changeSwitch","updateStatus","ENABLED_ON_TEXT","ENABLED_OFF_TEXT","subscriptionLabel","classList","add","enableSwitch","enable","enabledBool","disabled","NOT_SUPPORTED_TEXT","subscriptionStatus","card","subscriptionInfoCard","subscriptionInfo","innerHTML","displayServerId","serverId","serverInfo","_axios2","post","subscriberURL","subscriptionId","delete","SERVER_BASE_URL"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAI,EAAAJ,EACAK,GAAA,EACAH,WAUA,OANAJ,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,GAAA,EAGAF,EAAAD,QAvBA,GAAAD,KA4BAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,SAAAP,EAAAQ,EAAAC,GACAZ,EAAAa,EAAAV,EAAAQ,IACAG,OAAAC,eAAAZ,EAAAQ,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAZ,EAAAmB,EAAA,SAAAf,GACA,GAAAQ,GAAAR,KAAAgB,WACA,WAA2B,MAAAhB,GAAA,SAC3B,WAAiC,MAAAA,GAEjC,OADAJ,GAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAQ,EAAAC,GAAsD,MAAAR,QAAAS,UAAAC,eAAAjB,KAAAc,EAAAC,IAGtDtB,EAAAyB,EAAA,KAGAzB,IAAA0B,EAAA,MDMM,SAAUtB,EAAQD,EAASH,GAEjC,YEpDA,SAAA2B,GAAAC,GACA,yBAAAC,EAAAtB,KAAAqB,GASA,QAAAE,GAAAF,GACA,+BAAAC,EAAAtB,KAAAqB,GASA,QAAAG,GAAAH,GACA,yBAAAI,WAAAJ,YAAAI,UASA,QAAAC,GAAAL,GAOA,MALA,mBAAAM,0BAAA,OACAA,YAAAC,OAAAP,GAEA,GAAAA,EAAA,QAAAA,EAAAQ,iBAAAF,aAWA,QAAAG,GAAAT,GACA,sBAAAA,GASA,QAAAU,GAAAV,GACA,sBAAAA,GASA,QAAAW,GAAAX,GACA,gBAAAA,EASA,QAAAY,GAAAZ,GACA,cAAAA,GAAA,gBAAAA,GASA,QAAAa,GAAAb,GACA,wBAAAC,EAAAtB,KAAAqB,GASA,QAAAc,GAAAd,GACA,wBAAAC,EAAAtB,KAAAqB,GASA,QAAAe,GAAAf,GACA,wBAAAC,EAAAtB,KAAAqB,GASA,QAAAgB,GAAAhB,GACA,4BAAAC,EAAAtB,KAAAqB,GASA,QAAAiB,GAAAjB,GACA,MAAAY,GAAAZ,IAAAgB,EAAAhB,EAAAkB,MASA,QAAAC,GAAAnB,GACA,yBAAAoB,kBAAApB,YAAAoB,iBASA,QAAAC,GAAAC,GACA,MAAAA,GAAAC,QAAA,WAAAA,QAAA,WAgBA,QAAAC,KACA,0BAAAC,YAAA,gBAAAA,UAAAC,WAIA,mBAAAC,SACA,mBAAAC,WAgBA,QAAAC,GAAAC,EAAAC,GAEA,UAAAD,OAAA,KAAAA,EAUA,GALA,gBAAAA,IAAA/B,EAAA+B,KAEAA,OAGA/B,EAAA+B,GAEA,OAAArD,GAAA,EAAAC,EAAAoD,EAAAE,OAAmCvD,EAAAC,EAAOD,IAC1CsD,EAAApD,KAAA,KAAAmD,EAAArD,KAAAqD,OAIA,QAAAG,KAAAH,GACA5C,OAAAS,UAAAC,eAAAjB,KAAAmD,EAAAG,IACAF,EAAApD,KAAA,KAAAmD,EAAAG,KAAAH,GAuBA,QAAAI,KAEA,QAAAC,GAAAnC,EAAAiC,GACA,gBAAAG,GAAAH,IAAA,gBAAAjC,GACAoC,EAAAH,GAAAC,EAAAE,EAAAH,GAAAjC,GAEAoC,EAAAH,GAAAjC,EAIA,OATAoC,MASA3D,EAAA,EAAAC,EAAA2D,UAAAL,OAAuCvD,EAAAC,EAAOD,IAC9CoD,EAAAQ,UAAA5D,GAAA0D,EAEA,OAAAC,GAWA,QAAAE,GAAAC,EAAAC,EAAAC,GAQA,MAPAZ,GAAAW,EAAA,SAAAxC,EAAAiC,GAEAM,EAAAN,GADAQ,GAAA,kBAAAzC,GACA0C,EAAA1C,EAAAyC,GAEAzC,IAGAuC,EApRA,GAAAG,GAAAtE,EAAA,GACAuE,EAAAvE,EAAA,IAMA6B,EAAAf,OAAAS,UAAAM,QAgRAzB,GAAAD,SACAwB,UACAG,gBACAyC,WACAxC,aACAE,oBACAI,WACAC,WACAE,WACAD,cACAE,SACAC,SACAC,SACAC,aACAC,WACAE,oBACAK,uBACAK,UACAK,QACAI,SACAjB,SF4EM,SAAU7C,EAAQD,EAASH,GAEjC,cAC4B,SAASwE,GGnXrC,QAAAC,GAAAC,EAAAC,IACAC,EAAArC,YAAAmC,IAAAE,EAAArC,YAAAmC,EAAA,mBACAA,EAAA,gBAAAC,GATA,GAAAC,GAAA5E,EAAA,GACA6E,EAAA7E,EAAA,IAEA8E,GACAC,eAAA,qCAqBAC,GACAC,QAbA,WACA,GAAAA,EAQA,OAPA,mBAAAC,gBAEAD,EAAAjF,EAAA,OACG,KAAAwE,IAEHS,EAAAjF,EAAA,IAEAiF,KAMAE,kBAAA,SAAAC,EAAAV,GAEA,MADAG,GAAAH,EAAA,gBACAE,EAAA7C,WAAAqD,IACAR,EAAA9C,cAAAsD,IACAR,EAAAL,SAAAa,IACAR,EAAA/B,SAAAuC,IACAR,EAAAlC,OAAA0C,IACAR,EAAAjC,OAAAyC,GAEAA,EAEAR,EAAA3C,kBAAAmD,GACAA,EAAAhD,OAEAwC,EAAA7B,kBAAAqC,IACAX,EAAAC,EAAA,mDACAU,EAAAvD,YAEA+C,EAAApC,SAAA4C,IACAX,EAAAC,EAAA,kCACAW,KAAAC,UAAAF,IAEAA,IAGAG,mBAAA,SAAAH,GAEA,mBAAAA,GACA,IACAA,EAAAC,KAAAG,MAAAJ,GACO,MAAAK,IAEP,MAAAL,KAGAM,QAAA,EAEAC,eAAA,aACAC,eAAA,eAEAC,kBAAA,EAEAC,eAAA,SAAAC,GACA,MAAAA,IAAA,KAAAA,EAAA,KAIAf,GAAAN,SACAsB,QACAC,OAAA,sCAIArB,EAAAnB,SAAA,gCAAAyC,GACAlB,EAAAN,QAAAwB,QAGAtB,EAAAnB,SAAA,+BAAAyC,GACAlB,EAAAN,QAAAwB,GAAAtB,EAAAd,MAAAgB,KAGA1E,EAAAD,QAAA6E,IH8X6BzE,KAAKJ,EAASH,EAAoB,KAIzD,SAAUI,EAAQD,EAASH,GAEjC,YI7dAI,GAAAD,QAAA,SAAAwD,EAAAU,GACA,kBAEA,OADA8B,GAAA,GAAAC,OAAAnC,UAAAL,QACAvD,EAAA,EAAmBA,EAAA8F,EAAAvC,OAAiBvD,IACpC8F,EAAA9F,GAAA4D,UAAA5D,EAEA,OAAAsD,GAAA0C,MAAAhC,EAAA8B,MJueM,SAAU/F,EAAQD,GKpexB,QAAAmG,KACA,SAAAC,OAAA,mCAEA,QAAAC,KACA,SAAAD,OAAA,qCAsBA,QAAAE,GAAAC,GACA,GAAAC,IAAAC,WAEA,MAAAA,YAAAF,EAAA,EAGA,KAAAC,IAAAL,IAAAK,IAAAC,WAEA,MADAD,GAAAC,WACAA,WAAAF,EAAA,EAEA,KAEA,MAAAC,GAAAD,EAAA,GACK,MAAAjB,GACL,IAEA,MAAAkB,GAAApG,KAAA,KAAAmG,EAAA,GACS,MAAAjB,GAET,MAAAkB,GAAApG,KAAAsG,KAAAH,EAAA,KAMA,QAAAI,GAAAC,GACA,GAAAC,IAAAC,aAEA,MAAAA,cAAAF,EAGA,KAAAC,IAAAR,IAAAQ,IAAAC,aAEA,MADAD,GAAAC,aACAA,aAAAF,EAEA,KAEA,MAAAC,GAAAD,GACK,MAAAtB,GACL,IAEA,MAAAuB,GAAAzG,KAAA,KAAAwG,GACS,MAAAtB,GAGT,MAAAuB,GAAAzG,KAAAsG,KAAAE,KAYA,QAAAG,KACAC,GAAAC,IAGAD,GAAA,EACAC,EAAAxD,OACAyD,EAAAD,EAAAE,OAAAD,GAEAE,GAAA,EAEAF,EAAAzD,QACA4D,KAIA,QAAAA,KACA,IAAAL,EAAA,CAGA,GAAAzB,GAAAe,EAAAS,EACAC,IAAA,CAGA,KADA,GAAAM,GAAAJ,EAAAzD,OACA6D,GAAA,CAGA,IAFAL,EAAAC,EACAA,OACAE,EAAAE,GACAL,GACAA,EAAAG,GAAAG,KAGAH,IAAA,EACAE,EAAAJ,EAAAzD,OAEAwD,EAAA,KACAD,GAAA,EACAL,EAAApB,IAiBA,QAAAiC,GAAAjB,EAAAkB,GACAf,KAAAH,MACAG,KAAAe,QAYA,QAAAC,MAhKA,GAOAlB,GACAK,EARAxC,EAAApE,EAAAD,YAgBA,WACA,IAEAwG,EADA,kBAAAC,YACAA,WAEAN,EAEK,MAAAb,GACLkB,EAAAL,EAEA,IAEAU,EADA,kBAAAC,cACAA,aAEAT,EAEK,MAAAf,GACLuB,EAAAR,KAuDA,IAEAY,GAFAC,KACAF,GAAA,EAEAI,GAAA,CAyCA/C,GAAAsD,SAAA,SAAApB,GACA,GAAAP,GAAA,GAAAC,OAAAnC,UAAAL,OAAA,EACA,IAAAK,UAAAL,OAAA,EACA,OAAAvD,GAAA,EAAuBA,EAAA4D,UAAAL,OAAsBvD,IAC7C8F,EAAA9F,EAAA,GAAA4D,UAAA5D,EAGAgH,GAAAU,KAAA,GAAAJ,GAAAjB,EAAAP,IACA,IAAAkB,EAAAzD,QAAAuD,GACAV,EAAAe,IASAG,EAAApG,UAAAmG,IAAA,WACAb,KAAAH,IAAAL,MAAA,KAAAQ,KAAAe,QAEApD,EAAAwD,MAAA,UACAxD,EAAAyD,SAAA,EACAzD,EAAA0D,OACA1D,EAAA2D,QACA3D,EAAA4D,QAAA,GACA5D,EAAA6D,YAIA7D,EAAA8D,GAAAT,EACArD,EAAA+D,YAAAV,EACArD,EAAAgE,KAAAX,EACArD,EAAAiE,IAAAZ,EACArD,EAAAkE,eAAAb,EACArD,EAAAmE,mBAAAd,EACArD,EAAAoE,KAAAf,EACArD,EAAAqE,gBAAAhB,EACArD,EAAAsE,oBAAAjB,EAEArD,EAAAuE,UAAA,SAAApI,GAAqC,UAErC6D,EAAAwE,QAAA,SAAArI,GACA,SAAA4F,OAAA,qCAGA/B,EAAAyE,IAAA,WAA2B,WAC3BzE,EAAA0E,MAAA,SAAAC,GACA,SAAA5C,OAAA,mCAEA/B,EAAA4E,MAAA,WAA4B,WLsftB,SAAUhJ,EAAQD,EAASH,GAEjC,cAC4B,SAASwE,GM9qBrC,GAAAI,GAAA5E,EAAA,GACAqJ,EAAArJ,EAAA,IACAsJ,EAAAtJ,EAAA,IACAuJ,EAAAvJ,EAAA,IACAwJ,EAAAxJ,EAAA,IACAyJ,EAAAzJ,EAAA,GACA0J,EAAA,mBAAAnG,gBAAAmG,MAAAnG,OAAAmG,KAAApF,KAAAf,SAAAvD,EAAA,GAEAI,GAAAD,QAAA,SAAAwJ,GACA,UAAAC,SAAA,SAAAC,EAAAC,GACA,GAAAC,GAAAJ,EAAAvE,KACA4E,EAAAL,EAAAjF,OAEAE,GAAA7C,WAAAgI,UACAC,GAAA,eAGA,IAAAC,GAAA,GAAA/E,gBACAgF,EAAA,qBACAC,GAAA,CAiBA,IAZA,SAAA3F,EAAA0D,IAAAkC,UACA,mBAAA7G,UACAA,OAAA8G,gBAAA,mBAAAJ,IACAT,EAAAG,EAAAW,OACAL,EAAA,GAAA1G,QAAA8G,eACAH,EAAA,SACAC,GAAA,EACAF,EAAAM,WAAA,aACAN,EAAAO,UAAA,cAIAb,EAAAc,KAAA,CACA,GAAAC,GAAAf,EAAAc,KAAAC,UAAA,GACAC,EAAAhB,EAAAc,KAAAE,UAAA,EACAX,GAAAY,cAAA,SAAAlB,EAAAgB,EAAA,IAAAC,GA+DA,GA5DAV,EAAAY,KAAAlB,EAAAzD,OAAA4E,cAAAxB,EAAAK,EAAAW,IAAAX,EAAAoB,OAAApB,EAAAqB,mBAAA,GAGAf,EAAAvE,QAAAiE,EAAAjE,QAGAuE,EAAAC,GAAA,WACA,GAAAD,IAAA,IAAAA,EAAAgB,YAAAd,KAQA,IAAAF,EAAAlE,QAAAkE,EAAAiB,aAAA,IAAAjB,EAAAiB,YAAAC,QAAA,WAKA,GAAAC,GAAA,yBAAAnB,GAAAV,EAAAU,EAAAoB,yBAAA,KACAC,EAAA3B,EAAA4B,cAAA,SAAA5B,EAAA4B,aAAAtB,EAAAuB,SAAAvB,EAAAwB,aACAD,GACApG,KAAAkG,EAEAvF,OAAA,OAAAkE,EAAAlE,OAAA,IAAAkE,EAAAlE,OACA2F,WAAA,OAAAzB,EAAAlE,OAAA,aAAAkE,EAAAyB,WACAhH,QAAA0G,EACAzB,SACAM,UAGAZ,GAAAQ,EAAAC,EAAA0B,GAGAvB,EAAA,OAIAA,EAAA0B,QAAA,WAGA7B,EAAAL,EAAA,gBAAAE,EAAA,KAAAM,IAGAA,EAAA,MAIAA,EAAAO,UAAA,WACAV,EAAAL,EAAA,cAAAE,EAAAjE,QAAA,cAAAiE,EAAA,eACAM,IAGAA,EAAA,MAMArF,EAAAxB,uBAAA,CACA,GAAAwI,GAAA5L,EAAA,IAGA6L,GAAAlC,EAAAmC,iBAAAtC,EAAAG,EAAAW,OAAAX,EAAAhE,eACAiG,EAAAG,KAAApC,EAAAhE,oBACAqG,EAEAH,KACA7B,EAAAL,EAAA/D,gBAAAiG,GAuBA,GAlBA,oBAAA5B,IACArF,EAAAnB,QAAAuG,EAAA,SAAApI,EAAAiC,OACA,KAAAkG,GAAA,iBAAAlG,EAAAoI,oBAEAjC,GAAAnG,GAGAoG,EAAAiC,iBAAArI,EAAAjC,KAMA+H,EAAAmC,kBACA7B,EAAA6B,iBAAA,GAIAnC,EAAA4B,aACA,IACAtB,EAAAsB,aAAA5B,EAAA4B,aACO,MAAA9F,GAGP,YAAAkE,EAAA4B,aACA,KAAA9F,GAMA,kBAAAkE,GAAAwC,oBACAlC,EAAAmC,iBAAA,WAAAzC,EAAAwC,oBAIA,kBAAAxC,GAAA0C,kBAAApC,EAAAqC,QACArC,EAAAqC,OAAAF,iBAAA,WAAAzC,EAAA0C,kBAGA1C,EAAA4C,aAEA5C,EAAA4C,YAAAC,QAAAC,KAAA,SAAAC,GACAzC,IAIAA,EAAA0C,QACA7C,EAAA4C,GAEAzC,EAAA,YAIA+B,KAAAjC,IACAA,EAAA,MAIAE,EAAA2C,KAAA7C,QNorB6BxJ,KAAKJ,EAASH,EAAoB,KAIzD,SAAUI,EAAQD,EAASH,GAEjC,YOz2BA,IAAA6M,GAAA7M,EAAA,GAYAI,GAAAD,QAAA,SAAA2M,EAAAnD,EAAAoD,EAAA9C,EAAAuB,GACA,GAAAwB,GAAA,GAAAzG,OAAAuG,EACA,OAAAD,GAAAG,EAAArD,EAAAoD,EAAA9C,EAAAuB,KPk3BM,SAAUpL,EAAQD,EAASH,GAEjC,YQl4BAI,GAAAD,QAAA,SAAAwE,GACA,SAAAA,MAAAsI,cR24BM,SAAU7M,EAAQD,EAASH,GAEjC,YSx4BA,SAAAkN,GAAAJ,GACAjG,KAAAiG,UAGAI,EAAA3L,UAAAM,SAAA,WACA,gBAAAgF,KAAAiG,QAAA,KAAAjG,KAAAiG,QAAA,KAGAI,EAAA3L,UAAA0L,YAAA,EAEA7M,EAAAD,QAAA+M,GTs5BM,SAAU9M,EAAQD,EAASH,GUx6BjCI,EAAAD,QAAAH,EAAA,IV86BM,SAAUI,EAAQD,EAASH,GAEjC,YWn6BA,SAAAmN,GAAAC,GACA,GAAAC,GAAA,GAAAC,GAAAF,GACAG,EAAAjJ,EAAAgJ,EAAA/L,UAAA0I,QAAAoD,EAQA,OALAzI,GAAAV,OAAAqJ,EAAAD,EAAA/L,UAAA8L,GAGAzI,EAAAV,OAAAqJ,EAAAF,GAEAE,EArBA,GAAA3I,GAAA5E,EAAA,GACAsE,EAAAtE,EAAA,GACAsN,EAAAtN,EAAA,IACAgF,EAAAhF,EAAA,GAsBAwN,EAAAL,EAAAnI,EAGAwI,GAAAF,QAGAE,EAAAC,OAAA,SAAAC,GACA,MAAAP,GAAAvI,EAAAd,MAAAkB,EAAA0I,KAIAF,EAAAN,OAAAlN,EAAA,GACAwN,EAAAG,YAAA3N,EAAA,IACAwN,EAAAI,SAAA5N,EAAA,GAGAwN,EAAAK,IAAA,SAAAC,GACA,MAAAlE,SAAAiE,IAAAC,IAEAN,EAAAO,OAAA/N,EAAA,IAEAI,EAAAD,QAAAqN,EAGApN,EAAAD,QAAA6N,QAAAR,GXs7BM,SAAUpN,EAAQD,GY59BxB,QAAAoE,GAAAb,GACA,QAAAA,EAAAuK,aAAA,kBAAAvK,GAAAuK,YAAA1J,UAAAb,EAAAuK,YAAA1J,SAAAb,GAIA,QAAAwK,GAAAxK,GACA,wBAAAA,GAAAyK,aAAA,kBAAAzK,GAAA0K,OAAA7J,EAAAb,EAAA0K,MAAA,MAVAhO,EAAAD,QAAA,SAAAuD,GACA,aAAAA,IAAAa,EAAAb,IAAAwK,EAAAxK,QAAA2K,aZ0/BM,SAAUjO,EAAQD,EAASH,GAEjC,Yax/BA,SAAAsN,GAAAI,GACA7G,KAAA7B,SAAA0I,EACA7G,KAAAyH,cACArE,QAAA,GAAAsE,GACA/C,SAAA,GAAA+C,IAhBA,GAAAvJ,GAAAhF,EAAA,GACA4E,EAAA5E,EAAA,GACAuO,EAAAvO,EAAA,IACAwO,EAAAxO,EAAA,IACAyO,EAAAzO,EAAA,IACA0O,EAAA1O,EAAA,GAoBAsN,GAAA/L,UAAA0I,QAAA,SAAAN,GAGA,gBAAAA,KACAA,EAAA/E,EAAAd,OACAwG,IAAArG,UAAA,IACKA,UAAA,KAGL0F,EAAA/E,EAAAd,MAAAkB,EAAA6B,KAAA7B,UAAiDkB,OAAA,OAAgByD,GACjEA,EAAAzD,OAAAyD,EAAAzD,OAAA+F,cAGAtC,EAAAgF,UAAAF,EAAA9E,EAAAW,OACAX,EAAAW,IAAAoE,EAAA/E,EAAAgF,QAAAhF,EAAAW,KAIA,IAAAsE,IAAAJ,MAAAxC,IACAQ,EAAA5C,QAAAC,QAAAF,EAUA,KARA9C,KAAAyH,aAAArE,QAAAxG,QAAA,SAAAoL,GACAD,EAAAE,QAAAD,EAAAE,UAAAF,EAAAG,YAGAnI,KAAAyH,aAAA9C,SAAA/H,QAAA,SAAAoL,GACAD,EAAA7G,KAAA8G,EAAAE,UAAAF,EAAAG,YAGAJ,EAAAhL,QACA4I,IAAAC,KAAAmC,EAAAK,QAAAL,EAAAK,QAGA,OAAAzC,IAIA5H,EAAAnB,SAAA,0CAAAyC,GAEAoH,EAAA/L,UAAA2E,GAAA,SAAAoE,EAAAX,GACA,MAAA9C,MAAAoD,QAAArF,EAAAd,MAAA6F,OACAzD,SACAoE,YAKA1F,EAAAnB,SAAA,+BAAAyC,GAEAoH,EAAA/L,UAAA2E,GAAA,SAAAoE,EAAAlF,EAAAuE,GACA,MAAA9C,MAAAoD,QAAArF,EAAAd,MAAA6F,OACAzD,SACAoE,MACAlF,aAKAhF,EAAAD,QAAAmN,Gb4gCM,SAAUlN,EAAQD,EAASH,GAEjC,YcjmCA,IAAA4E,GAAA5E,EAAA,EAEAI,GAAAD,QAAA,SAAAuE,EAAAwK,GACAtK,EAAAnB,QAAAiB,EAAA,SAAAC,EAAAhE,GACAA,IAAAuO,GAAAvO,EAAAmK,gBAAAoE,EAAApE,gBACApG,EAAAwK,GAAAvK,QACAD,GAAA/D,Qd4mCM,SAAUP,EAAQD,EAASH,GAEjC,YepnCA,IAAAyJ,GAAAzJ,EAAA,EASAI,GAAAD,QAAA,SAAA0J,EAAAC,EAAA0B,GACA,GAAA1F,GAAA0F,EAAA7B,OAAA7D,cAEA0F,GAAAzF,QAAAD,MAAA0F,EAAAzF,QAGA+D,EAAAL,EACA,mCAAA+B,EAAAzF,OACAyF,EAAA7B,OACA,KACA6B,EAAAvB,QACAuB,IAPA3B,EAAA2B,KfsoCM,SAAUpL,EAAQD,EAASH,GAEjC,YgB3oCAI,GAAAD,QAAA,SAAA6M,EAAArD,EAAAoD,EAAA9C,EAAAuB,GAOA,MANAwB,GAAArD,SACAoD,IACAC,EAAAD,QAEAC,EAAA/C,UACA+C,EAAAxB,WACAwB,IhB8pCM,SAAU5M,EAAQD,EAASH,GAEjC,YiB/qCA,SAAAmP,GAAAvN,GACA,MAAAwN,oBAAAxN,GACAuB,QAAA,aACAA,QAAA,aACAA,QAAA,YACAA,QAAA,aACAA,QAAA,YACAA,QAAA,aACAA,QAAA,aAVA,GAAAyB,GAAA5E,EAAA,EAoBAI,GAAAD,QAAA,SAAAmK,EAAAS,EAAAC,GAEA,IAAAD,EACA,MAAAT,EAGA,IAAA+E,EACA,IAAArE,EACAqE,EAAArE,EAAAD,OACG,IAAAnG,EAAA7B,kBAAAgI,GACHsE,EAAAtE,EAAAlJ,eACG,CACH,GAAAyN,KAEA1K,GAAAnB,QAAAsH,EAAA,SAAAnJ,EAAAiC,GACA,OAAAjC,OAAA,KAAAA,IAIAgD,EAAAjD,QAAAC,KACAiC,GAAA,MAGAe,EAAAjD,QAAAC,KACAA,OAGAgD,EAAAnB,QAAA7B,EAAA,SAAA2N,GACA3K,EAAAnC,OAAA8M,GACAA,IAAAC,cACS5K,EAAApC,SAAA+M,KACTA,EAAAlK,KAAAC,UAAAiK,IAEAD,EAAAvH,KAAAoH,EAAAtL,GAAA,IAAAsL,EAAAI,SAIAF,EAAAC,EAAAG,KAAA,KAOA,MAJAJ,KACA/E,KAAA,IAAAA,EAAAa,QAAA,cAAAkE,GAGA/E,IjB0rCM,SAAUlK,EAAQD,EAASH,GAEjC,YkB5vCA,IAAA4E,GAAA5E,EAAA,EAeAI,GAAAD,QAAA,SAAAuE,GACA,GACAb,GACAjC,EACAvB,EAHAqP,IAKA,OAAAhL,IAEAE,EAAAnB,QAAAiB,EAAAiL,MAAA,eAAAC,GACAvP,EAAAuP,EAAAzE,QAAA,KACAtH,EAAAe,EAAA3B,KAAA2M,EAAAC,OAAA,EAAAxP,IAAA4L,cACArK,EAAAgD,EAAA3B,KAAA2M,EAAAC,OAAAxP,EAAA,IAEAwD,IACA6L,EAAA7L,GAAA6L,EAAA7L,GAAA6L,EAAA7L,GAAA,KAAAjC,OAIA8N,GAZiBA,IlBixCX,SAAUtP,EAAQD,EAASH,GAEjC,YmBxyCA,IAAA4E,GAAA5E,EAAA,EAEAI,GAAAD,QACAyE,EAAAxB,uBAIA,WAWA,QAAA0M,GAAAxF,GACA,GAAAyF,GAAAzF,CAWA,OATA0F,KAEAC,EAAAC,aAAA,OAAAH,GACAA,EAAAE,EAAAF,MAGAE,EAAAC,aAAA,OAAAH,IAIAA,KAAAE,EAAAF,KACAI,SAAAF,EAAAE,SAAAF,EAAAE,SAAAhN,QAAA,YACAiN,KAAAH,EAAAG,KACAC,OAAAJ,EAAAI,OAAAJ,EAAAI,OAAAlN,QAAA,aACAmN,KAAAL,EAAAK,KAAAL,EAAAK,KAAAnN,QAAA,YACAoN,SAAAN,EAAAM,SACAC,KAAAP,EAAAO,KACAC,SAAA,MAAAR,EAAAQ,SAAAC,OAAA,GACAT,EAAAQ,SACA,IAAAR,EAAAQ,UAhCA,GAEAE,GAFAX,EAAA,kBAAAY,KAAAvN,UAAAwN,WACAZ,EAAAzM,SAAAsN,cAAA,IA2CA,OARAH,GAAAb,EAAAvM,OAAAwN,SAAAhB,MAQA,SAAAiB,GACA,GAAAtB,GAAA9K,EAAAvC,SAAA2O,GAAAlB,EAAAkB,IACA,OAAAtB,GAAAS,WAAAQ,EAAAR,UACAT,EAAAU,OAAAO,EAAAP,SAKA,WACA,kBACA,cnBmzCM,SAAUhQ,EAAQD,EAASH,GAEjC,YoB/2CA,SAAAiR,KACApK,KAAAiG,QAAA,uCAMA,QAAApD,GAAAwH,GAGA,IAEA,GAAAC,GAAAC,EAJAlO,EAAAmO,OAAAH,GACAI,EAAA,GAGAC,EAAA,EAAAC,EAAAC,EAIAvO,EAAAwN,OAAA,EAAAa,KAAAC,EAAA,IAAAD,EAAA,GAEAD,GAAAE,EAAAd,OAAA,GAAAS,GAAA,EAAAI,EAAA,KACA,CAEA,IADAH,EAAAlO,EAAAwO,WAAAH,GAAA,MACA,IACA,SAAAN,EAEAE,MAAA,EAAAC,EAEA,MAAAE,GA5BA,GAAAG,GAAA,mEAKAR,GAAA1P,UAAA,GAAAgF,OACA0K,EAAA1P,UAAAwL,KAAA,EACAkE,EAAA1P,UAAAZ,KAAA,wBAwBAP,EAAAD,QAAAuJ,GpB23CM,SAAUtJ,EAAQD,EAASH,GAEjC,YqB95CA,IAAA4E,GAAA5E,EAAA,EAEAI,GAAAD,QACAyE,EAAAxB,uBAGA,WACA,OACAuO,MAAA,SAAAhR,EAAAgE,EAAAiN,EAAAC,EAAAC,EAAAC,GACA,GAAAC,KACAA,GAAAjK,KAAApH,EAAA,IAAAyO,mBAAAzK,IAEAC,EAAAtC,SAAAsP,IACAI,EAAAjK,KAAA,cAAAkK,MAAAL,GAAAM,eAGAtN,EAAAvC,SAAAwP,IACAG,EAAAjK,KAAA,QAAA8J,GAGAjN,EAAAvC,SAAAyP,IACAE,EAAAjK,KAAA,UAAA+J,IAGA,IAAAC,GACAC,EAAAjK,KAAA,UAGAvE,SAAAwO,SAAAvC,KAAA,OAGA1D,KAAA,SAAApL,GACA,GAAAwR,GAAA3O,SAAAwO,OAAAG,MAAA,GAAAC,QAAA,aAA0DzR,EAAA,aAC1D,OAAAwR,GAAAE,mBAAAF,EAAA,UAGAG,OAAA,SAAA3R,GACAkG,KAAA8K,MAAAhR,EAAA,GAAAsR,KAAAM,MAAA,YAMA,WACA,OACAZ,MAAA,aACA5F,KAAA,WAA6B,aAC7BuG,OAAA,kBrBy6CM,SAAUlS,EAAQD,EAASH,GAEjC,YsBx9CA,SAAAuO,KACA1H,KAAA2L,YAHA,GAAA5N,GAAA5E,EAAA,EAcAuO,GAAAhN,UAAAkR,IAAA,SAAA1D,EAAAC,GAKA,MAJAnI,MAAA2L,SAAAzK,MACAgH,YACAC,aAEAnI,KAAA2L,SAAA5O,OAAA,GAQA2K,EAAAhN,UAAAmR,MAAA,SAAAC,GACA9L,KAAA2L,SAAAG,KACA9L,KAAA2L,SAAAG,GAAA,OAYApE,EAAAhN,UAAAkC,QAAA,SAAAE,GACAiB,EAAAnB,QAAAoD,KAAA2L,SAAA,SAAAI,GACA,OAAAA,GACAjP,EAAAiP,MAKAxS,EAAAD,QAAAoO,GtBk+CM,SAAUnO,EAAQD,EAASH,GAEjC,YuB7gDA,SAAA6S,GAAAlJ,GACAA,EAAA4C,aACA5C,EAAA4C,YAAAuG,mBAVA,GAAAlO,GAAA5E,EAAA,GACA+S,EAAA/S,EAAA,IACA4N,EAAA5N,EAAA,GACAgF,EAAAhF,EAAA,EAiBAI,GAAAD,QAAA,SAAAwJ,GA6BA,MA5BAkJ,GAAAlJ,GAGAA,EAAAjF,QAAAiF,EAAAjF,YAGAiF,EAAAvE,KAAA2N,EACApJ,EAAAvE,KACAuE,EAAAjF,QACAiF,EAAAxE,kBAIAwE,EAAAjF,QAAAE,EAAAd,MACA6F,EAAAjF,QAAAsB,WACA2D,EAAAjF,QAAAiF,EAAAzD,YACAyD,EAAAjF,aAGAE,EAAAnB,SACA,qDACA,SAAAyC,SACAyD,GAAAjF,QAAAwB,MAIAyD,EAAA1E,SAAAD,EAAAC,SAEA0E,GAAA8C,KAAA,SAAAjB,GAUA,MATAqH,GAAAlJ,GAGA6B,EAAApG,KAAA2N,EACAvH,EAAApG,KACAoG,EAAA9G,QACAiF,EAAApE,mBAGAiG,GACG,SAAAwH,GAcH,MAbApF,GAAAoF,KACAH,EAAAlJ,GAGAqJ,KAAAxH,WACAwH,EAAAxH,SAAApG,KAAA2N,EACAC,EAAAxH,SAAApG,KACA4N,EAAAxH,SAAA9G,QACAiF,EAAApE,qBAKAqE,QAAAE,OAAAkJ,OvB+hDM,SAAU5S,EAAQD,EAASH,GAEjC,YwB3mDA,IAAA4E,GAAA5E,EAAA,EAUAI,GAAAD,QAAA,SAAAiF,EAAAV,EAAAuO,GAMA,MAJArO,GAAAnB,QAAAwP,EAAA,SAAAtP,GACAyB,EAAAzB,EAAAyB,EAAAV,KAGAU,IxBonDM,SAAUhF,EAAQD,EAASH,GAEjC,YyBhoDAI,GAAAD,QAAA,SAAAmK,GAIA,sCAAAsG,KAAAtG,KzB+oDM,SAAUlK,EAAQD,EAASH,GAEjC,Y0BppDAI,GAAAD,QAAA,SAAAwO,EAAAuE,GACA,MAAAA,GACAvE,EAAAxL,QAAA,eAAA+P,EAAA/P,QAAA,WACAwL,I1BoqDM,SAAUvO,EAAQD,EAASH,GAEjC,Y2BxqDA,SAAA2N,GAAAwF,GACA,qBAAAA,GACA,SAAAC,WAAA,+BAGA,IAAAC,EACAxM,MAAA2F,QAAA,GAAA5C,SAAA,SAAAC,GACAwJ,EAAAxJ,GAGA,IAAAyJ,GAAAzM,IACAsM,GAAA,SAAArG,GACAwG,EAAAN,SAKAM,EAAAN,OAAA,GAAA9F,GAAAJ,GACAuG,EAAAC,EAAAN,WA1BA,GAAA9F,GAAAlN,EAAA,EAiCA2N,GAAApM,UAAAuR,iBAAA,WACA,GAAAjM,KAAAmM,OACA,KAAAnM,MAAAmM,QAQArF,EAAA4F,OAAA,WACA,GAAA7G,EAIA,QACA4G,MAJA,GAAA3F,GAAA,SAAAlN,GACAiM,EAAAjM,IAIAiM,WAIAtM,EAAAD,QAAAwN,G3BwrDM,SAAUvN,EAAQD,EAASH,GAEjC,Y4B5tDAI,GAAAD,QAAA,SAAAqT,GACA,gBAAAC,GACA,MAAAD,GAAAnN,MAAA,KAAAoN,M5B0vDM,SAAUrT,EAAQD,EAASH,GAEjC,YA6BA,SAAS0T,GAAuBhQ,GAAO,MAAOA,IAAOA,EAAItC,WAAasC,GAAQsK,QAAStK,G6BpvDvF,QAASiQ,GAAsBC,GAS7B,IAAK,GARCC,GAAU,IAAIC,QAAQ,EAAIF,EAAahQ,OAAS,GAAK,GACrDmQ,GAAUH,EAAeC,GAC5B1Q,QAAQ,MAAO,KACfA,QAAQ,KAAM,KAEX6Q,EAAUzQ,OAAO0Q,KAAKF,GACtBG,EAAc,GAAIC,YAAWH,EAAQpQ,QAElCvD,EAAI,EAAGA,EAAI2T,EAAQpQ,SAAUvD,EACpC6T,EAAY7T,GAAK2T,EAAQtC,WAAWrR,EAEtC,OAAO6T,GAMT,QAASE,KACP/Q,UAAUgR,cAAcC,MAAM7H,KAC5B,SAAU8H,GACRC,EAAcD,EAAaC,YAC3BA,EAAYC,kBACThI,KAAK,SAAUiI,GACdC,EAAqBD,KAEtBE,MAAM,SAAU5H,GACf6H,QAAQ7H,MAAMA,GACd8H,EAAyB,UAUnC,QAASC,KACPP,EAAYO,WACVC,iBAAiB,EACjBC,qBAAsBtB,EAAsBuB,KAE7CzI,KAAK,SAAUiI,GACdG,QAAQM,IAAI,eACZC,EAAmBV,EACnBC,EAAqBD,KAEtBE,MAAM,SAAU5H,GACf6H,QAAQM,IAAI,mCACZN,QAAQ7H,MAAMA,GACd2H,EAAqBS,KASzB,QAASC,KACP,MAAKD,GAOHA,EAAiBC,cACd5I,KAAK,SAAU6I,GACdF,EAAmB,KACnBT,EAAqBS,KAEtBR,MAAM,SAAU5H,GACf6H,QAAQ7H,MAAMA,GACd2H,EAAqBS,MAbzBP,QAAQM,IAAI,kCACZR,GAAqB,OAkBzB,QAASA,GAAqBD,IAC5B,EAAAa,EAAAC,cAAad,IACb,EAAAe,EAAAC,iBAAgBhB,GAChBI,EAAyBJ,GAO3B,QAASI,GAAyBJ,GAChC,MAAOiB,GAAA3H,QAAY4H,QAAQ,gBACxBnJ,KAAK,SAAUoJ,GACdA,EAAoBxQ,KAAKG,MAAMqQ,EADE,IAAAC,GAEMC,EACrCF,EACAnB,GAFMsB,EAFyBF,EAEzBE,aAAcC,EAFWH,EAEXG,YAKvB,OAAKD,IAAiBC,EAKjBD,EAOKE,EAAAlI,QAAmBmI,mBAAmBzB,GAC1CjI,KAAK,SAAAjB,GACJ,GAAMpG,GAAOoG,EAASpG,IAEtB,OADAyP,SAAQM,IAAI,wBAAyB/P,GAC9BuQ,EAAA3H,QAAYoI,QAAQ,eAAgB/Q,KAAKC,UAAUF,IAAOqH,KAAK,iBAAMrH,OAEvE6Q,EACFN,EAAA3H,QAAYoI,QAAQ,eAAgB,MACxC3J,KAAK,WAEJ,MADAyJ,GAAAlI,QAAmBqI,mBAAmBR,EAAkBS,KACjD,WAJN,IAjBLzB,QAAQM,IAAI,2CACLU,KAwBVpJ,KAAK,SAAU8J,GAGV7B,IACFG,QAAQM,IAAI,gDACZ,EAAAM,EAAAC,iBAAgBhB,IAChB,EAAAe,EAAAe,uBAAsBD,MAGzB3B,MAAM,SAAU5H,GACf6H,QAAQ7H,MAAM,kCACd6H,QAAQ7H,MAAMA,IACd,EAAAyI,EAAAgB,oBAAmBzJ,KAOzB,QAAS+I,GAA2BF,EAAmBnB,GACrD,GAAMgC,GACJb,GAAqBnB,GACrBmB,EAAkBc,WAAajC,EAAaiC,QAG9C,QACEX,cAAeH,GAAqBnB,GAAgBgC,EACpDT,cAAevB,GAAgBmB,GApNnC7V,EAAA,GAEA,IAAA4W,GAAA5W,EAAA,GACA6W,G7BsxDcnD,EAAuBkD,G6BtxDrC5W,EAAA,K7B0xDI8W,EAAgBpD,EAAuBmD,G6BzxD3CE,EAAA/W,EAAA,I7B6xDI2V,EAAgBjC,EAAuBqD,G6B5xD3CxB,EAAAvV,EAAA,IACAyV,EAAAzV,EAAA,IACAgX,EAAAhX,EAAA,I7BkyDIkW,EAAuBxC,EAAuBsD,G6B7xDlDC,EAAAjX,EAAA,IAGMkX,G7B8xDgBxD,EAAuBuD,G6B9xD3B5T,WAAa,iBAAmBA,YAC5C8T,EAAc5T,QAAU,eAAiBA,QACzC6T,EAAc/T,WAAc6T,GAAaC,EACzCjC,EAA8B,0FAWhCV,EAAc,KACdY,EAAmB,IAEvB5R,UAAS4I,iBAAiB,mBAAoB,YAC5C,EAAA0K,EAAA9I,SAAkBkJ,EAAWC,GACzBC,IAEF/T,UAAUgR,cAAcgD,SAAS,uBAAuBzC,MAAM,SAAU5H,GAEtE,KADA6H,SAAQ7H,MAAM,+CACRA,IAGRoH,IACAmB,EAAA+B,mBAAmBlL,iBAAiB,SAAU,SAAUmL,GACtD,GAAMC,GAAUD,EAAYE,OAAOD,SACnC,EAAAjC,EAAAmC,cACIF,EACFzC,IAEAM,U7B+9DF,SAAUjV,EAAQD,KAMlB,SAAUC,EAAQD,EAASH,GAEjC,Y8B7gEe,SAAS2X,GAAkBtD,EAAeG,GACnDH,GAAiBG,EACnBoD,EAAiBC,MAAMC,QAAU,QAEjCZ,EAAUa,YAAc1D,EAAgB,YAAc,gBACtD8C,EAAYY,YAAcvD,EAAc,YAAc,gBACtDoD,EAAiBC,MAAMC,QAAU,S9B0gErChX,OAAOC,eAAeZ,EAAS,cAC7BwE,OAAO,IAETxE,EAAQ6N,Q8BnhEgB2J,CALjB,IAAMC,sBAAmBpU,SAASwU,cAAc,kBACjDC,EAAgBL,EAAiBI,cAAc,mBAC/Cd,EAAYe,EAAcD,cAAc,0BACxCb,EAAcc,EAAcD,cAAc,qB9B8iE1C,SAAU5X,EAAQD,EAASH,IAEL,SAASkY,GAAS,GAAIC,G+B1jElDA,GAMA,SAAAC,GAAwEhY,EAAAD,QAAAiY,KAA6P,WAAuC,eAAA3S,GAAA4S,EAAAlX,EAAAmX,GAA0B,QAAA5W,GAAAb,EAAA0X,GAAgB,IAAApX,EAAAN,GAAA,CAAU,IAAAwX,EAAAxX,GAAA,CAAU,GAAAsD,GAAA,kBAAAgU,KAA0C,KAAAI,GAAApU,EAAA,MAAAgU,GAAAtX,GAAA,EAAwB,IAAAR,EAAA,MAAAA,GAAAQ,GAAA,EAAoB,IAAAuX,GAAA,GAAA7R,OAAA,uBAAA1F,EAAA,IAA8C,MAAAuX,GAAArL,KAAA,mBAAAqL,EAAqC,GAAA9X,GAAAa,EAAAN,IAAYV,WAAYkY,GAAAxX,GAAA,GAAAN,KAAAD,EAAAH,QAAA,SAAAsF,GAAmC,GAAAtE,GAAAkX,EAAAxX,GAAA,GAAA4E,EAAiB,OAAA/D,GAAAP,GAAAsE,IAAgBnF,IAAAH,QAAAsF,EAAA4S,EAAAlX,EAAAmX,GAAsB,MAAAnX,GAAAN,GAAAV,QAA8D,OAA1CE,GAAA,kBAAA8X,MAA0CtX,EAAA,EAAYA,EAAAyX,EAAA1U,OAAW/C,IAAAa,EAAA4W,EAAAzX,GAAY,OAAAa,KAAY8W,GAAA,SAAAC,EAAArY,EAAAD,IAClzB,SAAA+X,GACA,YA+CA,SAAApQ,KACAX,GAAA,CAGA,KAFA,GAAA9G,GAAAqY,EACAjR,EAAAJ,EAAAzD,OACA6D,GAAA,CAIA,IAHAiR,EAAArR,EACAA,KACAhH,GAAA,IACAA,EAAAoH,GACAiR,EAAArY,IAEAoH,GAAAJ,EAAAzD,OAEAuD,GAAA,EAIA,QAAAwR,GAAAC,GACA,IAAAvR,EAAAU,KAAA6Q,IAAAzR,GACA0R,IAjEA,GAEAA,GAFAC,EAAAZ,EAAAa,kBAAAb,EAAAc,sBAKA,IAAAF,EAAA,CACA,GAAAG,GAAA,EACAC,EAAA,GAAAJ,GAAAhR,GACAqR,EAAAjB,EAAA1U,SAAA4V,eAAA,GACAF,GAAAG,QAAAF,GACAG,eAAA,IAEAT,EAAA,WACAM,EAAA/T,KAAA6T,MAAA,OAEG,IAAAf,EAAAqB,kBAAA,KAAArB,EAAAsB,eAOHX,EADG,YAAAX,IAAA,sBAAAA,GAAA1U,SAAAsN,cAAA,UACH,WAIA,GAAA2I,GAAAvB,EAAA1U,SAAAsN,cAAA,SACA2I,GAAAC,mBAAA,WACA5R,IAEA2R,EAAAC,mBAAA,KACAD,EAAAE,WAAAC,YAAAH,GACAA,EAAA,MAEAvB,EAAA1U,SAAAqW,gBAAAC,YAAAL,IAGA,WACA7S,WAAAkB,EAAA,QAvBG,CACH,GAAAiS,GAAA,GAAA7B,GAAAsB,cACAO,GAAAC,MAAAC,UAAAnS,EACA+Q,EAAA,WACAkB,EAAAG,MAAAC,YAAA,IAwBA,GAAAhT,GACAE,IAkBAjH,GAAAD,QAAAwY,IAOCpY,KAAAsG,SAAA,KAAAqR,IAAA,mBAAAkC,WAAA,mBAAA7W,wBACG8W,GAAA,SAAA5B,EAAArY,EAAAD,GACJ,YAIA,SAAAma,MAUA,QAAA1Q,GAAA2Q,GACA,qBAAAA,GACA,SAAAnH,WAAA,8BAEAvM,MAAA2T,MAAAC,EACA5T,KAAAQ,SACAR,KAAA6T,YAAA,GACAH,IAAAD,GACAK,EAAA9T,KAAA0T,GAsBA,QAAAK,GAAApO,EAAAqO,EAAAC,GACAjU,KAAA2F,UACA,kBAAAqO,KACAhU,KAAAgU,cACAhU,KAAAkU,cAAAlU,KAAAmU,oBAEA,kBAAAF,KACAjU,KAAAiU,aACAjU,KAAAoU,aAAApU,KAAAqU,mBAgBA,QAAAC,GAAA3O,EAAA4O,EAAAzW,GACAgU,EAAA,WACA,GAAA0C,EACA,KACAA,EAAAD,EAAAzW,GACK,MAAAc,GACL,MAAA+M,GAAA1I,OAAA0C,EAAA/G,GAEA4V,IAAA7O,EACAgG,EAAA1I,OAAA0C,EAAA,GAAA4G,WAAA,uCAEAZ,EAAA3I,QAAA2C,EAAA6O,KAoCA,QAAAC,GAAA5X,GAEA,GAAA+I,GAAA/I,KAAA+I,IACA,IAAA/I,GAAA,gBAAAA,IAAA,kBAAA+I,GACA,kBACAA,EAAApG,MAAA3C,EAAAO,YAKA,QAAA0W,GAAAP,EAAAmB,GAGA,QAAAC,GAAA7W,GACAsU,IAGAA,GAAA,EACAzG,EAAA1I,OAAAsQ,EAAAzV,IAGA,QAAA8W,GAAA9W,GACAsU,IAGAA,GAAA,EACAzG,EAAA3I,QAAAuQ,EAAAzV,IAGA,QAAA+W,KACAH,EAAAE,EAAAD,GAlBA,GAAAvC,IAAA,EAqBAjV,EAAA2X,EAAAD,EACA,WAAA1X,EAAA+B,QACAyV,EAAAxX,EAAAW,OAIA,QAAAgX,GAAAP,EAAAzW,GACA,GAAAiX,KACA,KACAA,EAAAjX,MAAAyW,EAAAzW,GACAiX,EAAA7V,OAAA,UACG,MAAAN,GACHmW,EAAA7V,OAAA,QACA6V,EAAAjX,MAAAc,EAEA,MAAAmW,GAIA,QAAA/R,GAAAlF,GACA,MAAAA,aAAAkC,MACAlC,EAEA6N,EAAA3I,QAAA,GAAAhD,MAAAyT,GAAA3V,GAIA,QAAAmF,GAAAkJ,GACA,GAAAxG,GAAA,GAAA3F,MAAAyT,EACA,OAAA9H,GAAA1I,OAAA0C,EAAAwG,GAIA,QAAAnF,GAAAgO,GACA,GAAAzB,GAAAvT,IACA,uBAAA/F,OAAAS,UAAAM,SAAAtB,KAAAsb,GACA,MAAAhV,MAAAiD,OAAA,GAAAsJ,WAAA,oBAGA,IAAA3L,GAAAoU,EAAAjY,OACAqV,GAAA,CACA,KAAAxR,EACA,MAAAZ,MAAAgD,WAQA,KALA,GAAAiS,GAAA,GAAA1V,OAAAqB,GACAsU,EAAA,EACA1b,GAAA,EACAmM,EAAA,GAAA3F,MAAAyT,KAEAja,EAAAoH,IAIA,SAAA9C,EAAAtE,GAOA,QAAA2b,GAAAC,GACAH,EAAAzb,GAAA4b,IACAF,IAAAtU,GAAAwR,IACAA,GAAA,EACAzG,EAAA3I,QAAA2C,EAAAsP,IAVA1B,EAAAvQ,QAAAlF,GAAA8H,KAAAuP,EAAA,SAAAhP,GACAiM,IACAA,GAAA,EACAzG,EAAA1I,OAAA0C,EAAAQ,OAPA6O,EAAAxb,KAEA,OAAAmM,GAmBA,QAAA0P,GAAAL,GACA,GAAAzB,GAAAvT,IACA,uBAAA/F,OAAAS,UAAAM,SAAAtB,KAAAsb,GACA,MAAAhV,MAAAiD,OAAA,GAAAsJ,WAAA,oBAGA,IAAA3L,GAAAoU,EAAAjY,OACAqV,GAAA,CACA,KAAAxR,EACA,MAAAZ,MAAAgD,WAMA,KAHA,GAAAxJ,IAAA,EACAmM,EAAA,GAAA3F,MAAAyT,KAEAja,EAAAoH,IAIA,SAAA9C,GACAyV,EAAAvQ,QAAAlF,GAAA8H,KAAA,SAAAjB,GACAyN,IACAA,GAAA,EACAzG,EAAA3I,QAAA2C,EAAAhB,KAEK,SAAAwB,GACLiM,IACAA,GAAA,EACAzG,EAAA1I,OAAA0C,EAAAQ,OAZA6O,EAAAxb,GAEA,OAAAmM,GA7OA,GAAAmM,GAAAF,EAAA,GAKAjG,KAEA2J,GAAA,YACAC,GAAA,aACA3B,GAAA,UAEAra,GAAAD,UAAAyJ,EAcAA,EAAArI,UAAA,eAAAuZ,GACA,MAAAjU,MAAA4F,KAAA,KAAAqO,IAEAlR,EAAArI,UAAAkL,KAAA,SAAAoO,EAAAC,GACA,qBAAAD,IAAAhU,KAAA2T,QAAA4B,GACA,kBAAAtB,IAAAjU,KAAA2T,QAAA2B,EACA,MAAAtV,KAEA,IAAA2F,GAAA,GAAA3F,MAAAoH,YAAAqM,EACA,IAAAzT,KAAA2T,QAAAC,EAAA,CAEAU,EAAA3O,EADA3F,KAAA2T,QAAA4B,EAAAvB,EAAAC,EACAjU,KAAA6T,aAEA7T,MAAAQ,MAAAU,KAAA,GAAA6S,GAAApO,EAAAqO,EAAAC,GAGA,OAAAtO,IAaAoO,EAAArZ,UAAAwZ,cAAA,SAAApW,GACA6N,EAAA3I,QAAAhD,KAAA2F,QAAA7H,IAEAiW,EAAArZ,UAAAyZ,mBAAA,SAAArW,GACAwW,EAAAtU,KAAA2F,QAAA3F,KAAAgU,YAAAlW,IAEAiW,EAAArZ,UAAA0Z,aAAA,SAAAtW,GACA6N,EAAA1I,OAAAjD,KAAA2F,QAAA7H,IAEAiW,EAAArZ,UAAA2Z,kBAAA,SAAAvW,GACAwW,EAAAtU,KAAA2F,QAAA3F,KAAAiU,WAAAnW,IAmBA6N,EAAA3I,QAAA,SAAAuQ,EAAAzV,GACA,GAAAX,GAAA2X,EAAAL,EAAA3W,EACA,cAAAX,EAAA+B,OACA,MAAAyM,GAAA1I,OAAAsQ,EAAApW,EAAAW,MAEA,IAAA4W,GAAAvX,EAAAW,KAEA,IAAA4W,EACAZ,EAAAP,EAAAmB,OACG,CACHnB,EAAAI,MAAA4B,EACAhC,EAAAM,QAAA/V,CAGA,KAFA,GAAAtE,IAAA,EACAoH,EAAA2S,EAAA/S,MAAAzD,SACAvD,EAAAoH,GACA2S,EAAA/S,MAAAhH,GAAA0a,cAAApW,GAGA,MAAAyV,IAEA5H,EAAA1I,OAAA,SAAAsQ,EAAApN,GACAoN,EAAAI,MAAA2B,EACA/B,EAAAM,QAAA1N,CAGA,KAFA,GAAA3M,IAAA,EACAoH,EAAA2S,EAAA/S,MAAAzD,SACAvD,EAAAoH,GACA2S,EAAA/S,MAAAhH,GAAA4a,aAAAjO,EAEA,OAAAoN,IAsDAja,EAAA0J,UAQA1J,EAAA2J,SAMA3J,EAAA0N,MAuCA1N,EAAA+b,SAmCG1D,EAAA,IAAM6D,GAAA,SAAA5D,EAAArY,EAAAD,IACT,SAAA+X,GACA,YACA,mBAAAA,GAAAtO,UACAsO,EAAAtO,QAAA6O,EAAA,MAGClY,KAAAsG,SAAA,KAAAqR,IAAA,mBAAAkC,WAAA,mBAAA7W,qBACE8W,EAAA,IAAMiC,GAAA,SAAA7D,EAAArY,EAAAD,GACT,YAIA,SAAAoc,GAAAhP,EAAAiP,GAAiD,KAAAjP,YAAAiP,IAA0C,SAAApJ,WAAA,qCAqE3F,QAAAqJ,GAAAnN,EAAAoN,GAEApN,QACAoN,OACA,KACA,UAAAC,MAAArN,EAAAoN,GACK,MAAAjX,GACL,iBAAAA,EAAA9E,KACA,KAAA8E,EAIA,QAFAmX,GAAA,mBAAAC,yBAAA,mBAAAC,6BAAA,mBAAAC,+BAAAC,kBACAC,EAAA,GAAAL,GACAvc,EAAA,EAAuBA,EAAAiP,EAAA1L,OAAkBvD,GAAA,EACzC4c,EAAAC,OAAA5N,EAAAjP,GAEA,OAAA4c,GAAAE,QAAAT,EAAAU,OAaA,QAAAC,GAAA7Q,EAAAgH,GACAA,GACAhH,EAAAC,KAAA,SAAAzI,GACAwP,EAAA,KAAAxP,IACS,SAAAgJ,GACTwG,EAAAxG,KAKA,QAAAsQ,GAAA9Q,EAAAgH,EAAA+J,GACA,kBAAA/J,IACAhH,EAAAC,KAAA+G,GAGA,kBAAA+J,IACA/Q,EAAA,MAAA+Q,GAiBA,QAAAC,GAAAC,GAIA,OAHA7Z,GAAA6Z,EAAA7Z,OACA8Z,EAAA,GAAAxb,aAAA0B,GACA6P,EAAA,GAAAU,YAAAuJ,GACArd,EAAA,EAAmBA,EAAAuD,EAAYvD,IAC/BoT,EAAApT,GAAAod,EAAA/L,WAAArR,EAEA,OAAAqd,GAkBA,QAAAC,GAAAC,GACA,UAAAC,IAAA,SAAAhU,GACA,GAAAiU,GAAAF,EAAAG,YAAAC,GAAA,aACAC,EAAAxB,GAAA,IACAqB,GAAAI,YAAAF,IAAAG,IAAAF,EAAA,OAEAH,EAAAM,QAAA,SAAA3Y,GAGAA,EAAA4Y,iBACA5Y,EAAA6Y,kBACAzU,GAAA,IAGAiU,EAAAS,WAAA,WACA,GAAAC,GAAAnb,UAAAwN,UAAAsB,MAAA,iBACAsM,EAAApb,UAAAwN,UAAAsB,MAAA,SAGAtI,GAAA4U,IAAAD,GAAAE,SAAAF,EAAA,eAEK,iBACL,WAIA,QAAAG,GAAAf,GACA,uBAAAgB,IACAf,GAAAhU,QAAA+U,IAEAjB,EAAAC,GAAAnR,KAAA,SAAA9H,GAEA,MADAia,IAAAja,IAKA,QAAAka,GAAAC,GACA,GAAAC,GAAAC,GAAAF,EAAAne,MAGAse,IAEAA,GAAAzS,QAAA,GAAAqR,IAAA,SAAAhU,GACAoV,EAAApV,YAIAkV,EAAAG,mBAAAnX,KAAAkX,GAGAF,EAAAI,QAGAJ,EAAAI,QAAAJ,EAAAI,QAAA1S,KAAA,WACA,MAAAwS,GAAAzS,UAHAuS,EAAAI,QAAAF,EAAAzS,QAQA,QAAA4S,GAAAN,GACA,GAAAC,GAAAC,GAAAF,EAAAne,MAGAse,EAAAF,EAAAG,mBAAAG,KAIAJ,IACAA,EAAApV,UAIA,QAAAyV,GAAAR,EAAAS,GACA,UAAA1B,IAAA,SAAAhU,EAAAC,GAEA,GAAAgV,EAAAU,GAAA,CACA,IAAAD,EAIA,MAAA1V,GAAAiV,EAAAU,GAHAX,GAAAC,GACAA,EAAAU,GAAAC,QAMA,GAAAC,IAAAZ,EAAAne,KAEA4e,IACAG,EAAA3X,KAAA+W,EAAA1W,QAGA,IAAAuX,GAAA/B,GAAA/S,KAAAxE,MAAAuX,GAAA8B,EAEAH,KACAI,EAAAC,gBAAA,SAAAna,GACA,GAAA+Z,GAAAG,EAAA3b,MACA,KACAwb,EAAAK,kBAAAf,EAAAgB,WACAra,EAAAsa,YAAA,GAEAP,EAAAK,kBAAA7B,IAEiB,MAAAgC,GACjB,uBAAAA,EAAArf,KAGA,KAAAqf,EAFAnL,SAAAoL,KAAA,iBAAAnB,EAAAne,KAAA,oCAAA8E,EAAAsa,WAAA,eAAAta,EAAAya,WAAA,sBAAApB,EAAAgB,UAAA,wBAQAH,EAAAhU,QAAA,SAAAlG,GACAA,EAAA4Y,iBACAvU,EAAA6V,EAAA3S,QAGA2S,EAAAQ,UAAA,WACAtW,EAAA8V,EAAA3b,QACAob,EAAAN,MAKA,QAAAsB,GAAAtB,GACA,MAAAQ,GAAAR,GAAA,GAGA,QAAAuB,GAAAvB,GACA,MAAAQ,GAAAR,GAAA,GAGA,QAAAwB,GAAAxB,EAAAyB,GACA,IAAAzB,EAAAU,GACA,QAGA,IAAAgB,IAAA1B,EAAAU,GAAAiB,iBAAAC,SAAA5B,EAAAgB,WACAa,EAAA7B,EAAA1W,QAAA0W,EAAAU,GAAApX,QACAwY,EAAA9B,EAAA1W,QAAA0W,EAAAU,GAAApX,OAYA,IAVAuY,IAGA7B,EAAA1W,UAAAmY,GACA1L,QAAAoL,KAAA,iBAAAnB,EAAAne,KAAA,uCAAAme,EAAAU,GAAApX,QAAA,eAAA0W,EAAA1W,QAAA,KAGA0W,EAAA1W,QAAA0W,EAAAU,GAAApX,SAGAwY,GAAAJ,EAAA,CAIA,GAAAA,EAAA,CACA,GAAAK,GAAA/B,EAAAU,GAAApX,QAAA,CACAyY,GAAA/B,EAAA1W,UACA0W,EAAA1W,QAAAyY,GAIA,SAGA,SAIA,QAAAC,GAAA7C,GACA,UAAAJ,IAAA,SAAAhU,EAAAC,GACA,GAAAiX,GAAA,GAAAC,WACAD,GAAApV,QAAA7B,EACAiX,EAAAE,UAAA,SAAAxb,GACA,GAAAsO,GAAArK,KAAAjE,EAAAgS,OAAAzT,QAAA,GACA6F,IACAqX,6BAAA,EACA9b,KAAA2O,EACAqJ,KAAAa,EAAAb,QAGA2D,EAAAI,mBAAAlD,KAKA,QAAAmD,GAAAC,GAEA,MAAA5E,IADAe,EAAAvJ,KAAAoN,EAAAjc,SACoCgY,KAAAiE,EAAAjE,OAIpC,QAAAkE,GAAA3c,GACA,MAAAA,MAAAuc,4BAOA,QAAAK,GAAA/N,GACA,GAAA4G,GAAAvT,KAEA2F,EAAA4N,EAAAoH,aAAA/U,KAAA,WACA,GAAAsS,GAAAC,GAAA5E,EAAAqH,QAAA9gB,KAEA,IAAAoe,KAAAI,QACA,MAAAJ,GAAAI,SAKA,OADA7B,GAAA9Q,EAAAgH,KACAhH,EAKA,QAAAkV,GAAAC,GAgDA,QAAAC,KAGA,MAAA/D,IAAAhU,UAlDA,GAAAuQ,GAAAvT,KACAiY,GACAU,GAAA,KAGA,IAAAmC,EACA,OAAAthB,KAAAshB,GACA7C,EAAAze,GAAAshB,EAAAthB,EAKA2e,MACAA,MAIA,IAAAD,GAAAC,GAAAF,EAAAne,KAGAoe,KACAA,GAEA8C,WAEArC,GAAA,KAEAL,QAAA,KAEAD,uBAGAF,GAAAF,EAAAne,MAAAoe,GAIAA,EAAA8C,QAAA9Z,KAAAqS,GAGAA,EAAAoH,aACApH,EAAAoH,WAAApH,EAAA9F,MACA8F,EAAA9F,MAAAiN,EAYA,QARAO,MAQAC,EAAA,EAAmBA,EAAAhD,EAAA8C,QAAAje,OAA8Bme,IAAA,CACjD,GAAAC,GAAAjD,EAAA8C,QAAAE,EACAC,KAAA5H,GAEA0H,EAAA/Z,KAAAia,EAAAR,aAAA,MAAAI,IAKA,GAAAC,GAAA9C,EAAA8C,QAAAzT,MAAA,EAIA,OAAAyP,IAAAhQ,IAAAiU,GAAArV,KAAA,WAGA,MAFAqS,GAAAU,GAAAT,EAAAS,GAEAY,EAAAtB,KACKrS,KAAA,SAAA+S,GAEL,MADAV,GAAAU,KACAc,EAAAxB,EAAA1E,EAAA6H,eAAA7Z,SAEAiY,EAAAvB,GAEAU,IACK/S,KAAA,SAAA+S,GACLV,EAAAU,GAAAT,EAAAS,KACApF,EAAAqH,QAAA3C,CAEA,QAAAoD,GAAA,EAAuBA,EAAAL,EAAAje,OAAoBse,IAAA,CAC3C,GAAAF,GAAAH,EAAAK,EACAF,KAAA5H,IAEA4H,EAAAP,QAAAjC,GAAAV,EAAAU,GACAwC,EAAAP,QAAArZ,QAAA0W,EAAA1W,YAMA,QAAAwN,GAAA/R,EAAA2P,GACA,GAAA4G,GAAAvT,IAGA,iBAAAhD,KACAgR,QAAAoL,KAAApc,EAAA,2CACAA,EAAAwN,OAAAxN,GAGA,IAAA2I,GAAA,GAAAqR,IAAA,SAAAhU,EAAAC,GACAsQ,EAAA9F,QAAA7H,KAAA,WACA,GAAAqS,GAAA1E,EAAAqH,QACAU,EAAArD,EAAAU,GAAAzB,YAAAe,EAAAgB,UAAA,YAAA5B,YAAAY,EAAAgB,WACAsC,EAAAD,EAAAjhB,IAAA2C,EAEAue,GAAAjC,UAAA,WACA,GAAAxb,GAAAyd,EAAApe,WACAgI,KAAArH,IACAA,EAAA,MAEA2c,EAAA3c,KACAA,EAAAyc,EAAAzc,IAEAkF,EAAAlF,IAGAyd,EAAAzW,QAAA,WACA7B,EAAAsY,EAAApV,UAES,MAAAlD,IAIT,OADAuT,GAAA7Q,EAAAgH,GACAhH,EAIA,QAAA6V,GAAAC,EAAA9O,GACA,GAAA4G,GAAAvT,KAEA2F,EAAA,GAAAqR,IAAA,SAAAhU,EAAAC,GACAsQ,EAAA9F,QAAA7H,KAAA,WACA,GAAAqS,GAAA1E,EAAAqH,QACAU,EAAArD,EAAAU,GAAAzB,YAAAe,EAAAgB,UAAA,YAAA5B,YAAAY,EAAAgB,WAEAsC,EAAAD,EAAAI,aACAC,EAAA,CAEAJ,GAAAjC,UAAA,WACA,GAAAsC,GAAAL,EAAApe,MAEA,IAAAye,EAAA,CACA,GAAA9d,GAAA8d,EAAA9d,KACA2c,GAAA3c,KACAA,EAAAyc,EAAAzc,GAEA,IAAAX,GAAAse,EAAA3d,EAAA8d,EAAA5e,IAAA2e,SAEA,KAAAxe,EACA6F,EAAA7F,GAEAye,EAAA,eAGA5Y,MAIAuY,EAAAzW,QAAA,WACA7B,EAAAsY,EAAApV,UAES,MAAAlD,IAKT,OAFAuT,GAAA7Q,EAAAgH,GAEAhH,EAGA,QAAA4J,GAAAvS,EAAAc,EAAA6O,GACA,GAAA4G,GAAAvT,IAGA,iBAAAhD,KACAgR,QAAAoL,KAAApc,EAAA,2CACAA,EAAAwN,OAAAxN,GAGA,IAAA2I,GAAA,GAAAqR,IAAA,SAAAhU,EAAAC,GACA,GAAAgV,EACA1E,GAAA9F,QAAA7H,KAAA,WAEA,MADAqS,GAAA1E,EAAAqH,QACA,kBAAA5f,GAAAtB,KAAAoE,GACAga,EAAAG,EAAAU,IAAA/S,KAAA,SAAAiW,GACA,MAAAA,GACA/d,EAEAmc,EAAAnc,KAGAA,IACS8H,KAAA,SAAA9H,GACT,GAAAoZ,GAAAe,EAAAU,GAAAzB,YAAAe,EAAAgB,UAAA,aACAqC,EAAApE,EAAAG,YAAAY,EAAAgB,WACAsC,EAAAD,EAAAhE,IAAAxZ,EAAAd,EAMA,QAAAc,IACAA,MAAAqH,IAGA+R,EAAAQ,WAAA,eAOAvS,KAAArH,IACAA,EAAA,MAGAkF,EAAAlF,IAEAoZ,EAAAK,QAAAL,EAAApS,QAAA,WACA,GAAAgX,GAAAP,EAAApV,MAAAoV,EAAApV,MAAAoV,EAAArE,YAAA/Q,KACAlD,GAAA6Y,MAES,MAAA7Y,IAIT,OADAuT,GAAA7Q,EAAAgH,GACAhH,EAGA,QAAAoW,GAAA/e,EAAA2P,GACA,GAAA4G,GAAAvT,IAGA,iBAAAhD,KACAgR,QAAAoL,KAAApc,EAAA,2CACAA,EAAAwN,OAAAxN,GAGA,IAAA2I,GAAA,GAAAqR,IAAA,SAAAhU,EAAAC,GACAsQ,EAAA9F,QAAA7H,KAAA,WACA,GAAAqS,GAAA1E,EAAAqH,QACA1D,EAAAe,EAAAU,GAAAzB,YAAAe,EAAAgB,UAAA,aACAqC,EAAApE,EAAAG,YAAAY,EAAAgB,WAOAsC,EAAAD,EAAA,OAAAte,EACAka,GAAAQ,WAAA,WACA1U,KAGAkU,EAAApS,QAAA,WACA7B,EAAAsY,EAAApV,QAKA+Q,EAAAK,QAAA,WACA,GAAAuE,GAAAP,EAAApV,MAAAoV,EAAApV,MAAAoV,EAAArE,YAAA/Q,KACAlD,GAAA6Y,MAES,MAAA7Y,IAIT,OADAuT,GAAA7Q,EAAAgH,GACAhH,EAGA,QAAAqW,GAAArP,GACA,GAAA4G,GAAAvT,KAEA2F,EAAA,GAAAqR,IAAA,SAAAhU,EAAAC,GACAsQ,EAAA9F,QAAA7H,KAAA,WACA,GAAAqS,GAAA1E,EAAAqH,QACA1D,EAAAe,EAAAU,GAAAzB,YAAAe,EAAAgB,UAAA,aACAqC,EAAApE,EAAAG,YAAAY,EAAAgB,WACAsC,EAAAD,EAAAU,OAEA9E,GAAAQ,WAAA,WACA1U,KAGAkU,EAAAK,QAAAL,EAAApS,QAAA,WACA,GAAAgX,GAAAP,EAAApV,MAAAoV,EAAApV,MAAAoV,EAAArE,YAAA/Q,KACAlD,GAAA6Y,MAES,MAAA7Y,IAIT,OADAuT,GAAA7Q,EAAAgH,GACAhH,EAGA,QAAA5I,GAAA4P,GACA,GAAA4G,GAAAvT,KAEA2F,EAAA,GAAAqR,IAAA,SAAAhU,EAAAC,GACAsQ,EAAA9F,QAAA7H,KAAA,WACA,GAAAqS,GAAA1E,EAAAqH,QACAU,EAAArD,EAAAU,GAAAzB,YAAAe,EAAAgB,UAAA,YAAA5B,YAAAY,EAAAgB,WACAsC,EAAAD,EAAAW,OAEAV,GAAAjC,UAAA,WACAtW,EAAAuY,EAAApe,SAGAoe,EAAAzW,QAAA,WACA7B,EAAAsY,EAAApV,UAES,MAAAlD,IAIT,OADAuT,GAAA7Q,EAAAgH,GACAhH,EAGA,QAAA3I,GAAA1C,EAAAqS,GACA,GAAA4G,GAAAvT,KAEA2F,EAAA,GAAAqR,IAAA,SAAAhU,EAAAC,GACA,GAAA3I,EAAA,EAGA,WAFA0I,GAAA,KAKAuQ,GAAA9F,QAAA7H,KAAA,WACA,GAAAqS,GAAA1E,EAAAqH,QACAU,EAAArD,EAAAU,GAAAzB,YAAAe,EAAAgB,UAAA,YAAA5B,YAAAY,EAAAgB,WAEAiD,GAAA,EACAX,EAAAD,EAAAI,YACAH,GAAAjC,UAAA,WACA,GAAAsC,GAAAL,EAAApe,MACA,KAAAye,EAIA,WAFA5Y,GAAA,KAKA,KAAA1I,EAGA0I,EAAA4Y,EAAA5e,KAEAkf,EAOAlZ,EAAA4Y,EAAA5e,MAJAkf,GAAA,EACAN,EAAAO,QAAA7hB,KAQAihB,EAAAzW,QAAA,WACA7B,EAAAsY,EAAApV,UAES,MAAAlD,IAIT,OADAuT,GAAA7Q,EAAAgH,GACAhH,EAGA,QAAAyW,GAAAzP,GACA,GAAA4G,GAAAvT,KAEA2F,EAAA,GAAAqR,IAAA,SAAAhU,EAAAC,GACAsQ,EAAA9F,QAAA7H,KAAA,WACA,GAAAqS,GAAA1E,EAAAqH,QACAU,EAAArD,EAAAU,GAAAzB,YAAAe,EAAAgB,UAAA,YAAA5B,YAAAY,EAAAgB,WAEAsC,EAAAD,EAAAI,aACAU,IAEAb,GAAAjC,UAAA,WACA,GAAAsC,GAAAL,EAAApe,MAEA,KAAAye,EAEA,WADA5Y,GAAAoZ,EAIAA,GAAAlb,KAAA0a,EAAA5e,KACA4e,EAAA,YAGAL,EAAAzW,QAAA,WACA7B,EAAAsY,EAAApV,UAES,MAAAlD,IAIT,OADAuT,GAAA7Q,EAAAgH,GACAhH,EA2CA,QAAA0W,GAAAC,GAEA,GAEA9iB,GAEA+iB,EAAAC,EAAAC,EAAAC,EAJAC,EAAA,IAAAL,EAAAvf,OACA6D,EAAA0b,EAAAvf,OAEAnC,EAAA,CAGA,OAAA0hB,IAAAvf,OAAA,KACA4f,IACA,MAAAL,IAAAvf,OAAA,IACA4f,IAIA,IAAAphB,GAAA,GAAAF,aAAAshB,GACAC,EAAA,GAAAtP,YAAA/R,EAEA,KAAA/B,EAAA,EAAeA,EAAAoH,EAASpH,GAAA,EACxB+iB,EAAAM,GAAAvY,QAAAgY,EAAA9iB,IACAgjB,EAAAK,GAAAvY,QAAAgY,EAAA9iB,EAAA,IACAijB,EAAAI,GAAAvY,QAAAgY,EAAA9iB,EAAA,IACAkjB,EAAAG,GAAAvY,QAAAgY,EAAA9iB,EAAA,IAGAojB,EAAAhiB,KAAA2hB,GAAA,EAAAC,GAAA,EACAI,EAAAhiB,MAAA,GAAA4hB,IAAA,EAAAC,GAAA,EACAG,EAAAhiB,MAAA,EAAA6hB,IAAA,KAAAC,CAEA,OAAAnhB,GAKA,QAAAuhB,GAAAvhB,GAEA,GAEA/B,GAFAojB,EAAA,GAAAtP,YAAA/R,GACAwR,EAAA,EAGA,KAAAvT,EAAA,EAAeA,EAAAojB,EAAA7f,OAAkBvD,GAAA,EAEjCuT,GAAA8P,GAAAD,EAAApjB,IAAA,GACAuT,GAAA8P,IAAA,EAAAD,EAAApjB,KAAA,EAAAojB,EAAApjB,EAAA,OACAuT,GAAA8P,IAAA,GAAAD,EAAApjB,EAAA,OAAAojB,EAAApjB,EAAA,OACAuT,GAAA8P,GAAA,GAAAD,EAAApjB,EAAA,GASA,OANAojB,GAAA7f,OAAA,KACAgQ,IAAAgQ,UAAA,EAAAhQ,EAAAhQ,OAAA,OACK6f,EAAA7f,OAAA,OACLgQ,IAAAgQ,UAAA,EAAAhQ,EAAAhQ,OAAA,SAGAgQ,EAMA,QAAAiQ,GAAAlf,EAAA6O,GACA,GAAAsQ,GAAA,EASA,IARAnf,IACAmf,EAAAC,GAAAxjB,KAAAoE,IAOAA,IAAA,yBAAAmf,GAAAnf,EAAAvC,QAAA,yBAAA2hB,GAAAxjB,KAAAoE,EAAAvC,SAAA,CAGA,GAAAA,GACA2E,EAAAid,EAEArf,aAAAzC,cACAE,EAAAuC,EACAoC,GAAAkd,KAEA7hB,EAAAuC,EAAAvC,OAEA,uBAAA0hB,EACA/c,GAAAmd,GACa,wBAAAJ,EACb/c,GAAAod,GACa,+BAAAL,EACb/c,GAAAqd,GACa,wBAAAN,EACb/c,GAAAsd,GACa,yBAAAP,EACb/c,GAAAud,GACa,wBAAAR,EACb/c,GAAAwd,GACa,yBAAAT,EACb/c,GAAAyd,GACa,0BAAAV,EACb/c,GAAA0d,GACa,0BAAAX,EACb/c,GAAA2d,GAEAlR,EAAA,GAAAjN,OAAA,wCAIAiN,EAAAzM,EAAA4c,EAAAvhB,QACK,sBAAA0hB,EAAA,CAEL,GAAAa,GAAA,GAAA3D,WAEA2D,GAAAC,OAAA,WAEA,GAAA1hB,GAAA2hB,GAAAlgB,EAAAyY,KAAA,IAAAuG,EAAA9c,KAAA7C,OAEAwP,GAAAwQ,GAAAc,GAAA5hB,IAGAyhB,EAAAI,kBAAApgB,OAEA,KACA6O,EAAAnO,KAAAC,UAAAX,IACS,MAAAc,GACToP,QAAA7H,MAAA,8CAAArI,GAEA6O,EAAA,KAAA/N,IAaA,QAAAuf,GAAArgB,GAIA,GAAAA,EAAAif,UAAA,EAAAqB,MAAAjB,GACA,MAAA3e,MAAAG,MAAAb,EAMA,IAGAugB,GAHA/B,EAAAxe,EAAAif,UAAAuB,IACA/H,EAAAzY,EAAAif,UAAAqB,GAAAE,GAKA,IAAA/H,IAAA0H,IAAAM,GAAAxU,KAAAuS,GAAA,CACA,GAAAkC,GAAAlC,EAAAhR,MAAAiT,GACAF,GAAAG,EAAA,GACAlC,IAAAS,UAAAyB,EAAA,GAAAzhB,QAEA,GAAAxB,GAAA8gB,EAAAC,EAIA,QAAA/F,GACA,IAAA6G,IACA,MAAA7hB,EACA,KAAA0iB,IACA,MAAArI,IAAAra,IAAyCgb,KAAA8H,GACzC,KAAAhB,IACA,UAAAoB,WAAAljB,EACA,KAAA+hB,IACA,UAAAhQ,YAAA/R,EACA,KAAAgiB,IACA,UAAAmB,mBAAAnjB,EACA,KAAAiiB,IACA,UAAAmB,YAAApjB,EACA,KAAAkiB,IACA,UAAAmB,aAAArjB,EACA,KAAAmiB,IACA,UAAAmB,YAAAtjB,EACA,KAAAoiB,IACA,UAAAmB,aAAAvjB,EACA,KAAAqiB,IACA,UAAAmB,cAAAxjB,EACA,KAAAsiB,IACA,UAAAmB,cAAAzjB,EACA,SACA,SAAAmE,OAAA,gBAAA6W,IAsBA,QAAA0I,GAAAnE,GACA,GAAAvH,GAAAvT,KACAiY,GACAU,GAAA,KAGA,IAAAmC,EACA,OAAAthB,KAAAshB,GACA7C,EAAAze,GAAA,gBAAAshB,GAAAthB,GAAAshB,EAAAthB,GAAAwB,WAAA8f,EAAAthB,EAIA,IAAA0lB,GAAA,GAAAlI,IAAA,SAAAhU,EAAAC,GAGA,IACAgV,EAAAU,GAAAwG,aAAAlH,EAAAne,KAAA0Q,OAAAyN,EAAA1W,SAAA0W,EAAAmH,YAAAnH,EAAAoH,MACS,MAAAzgB,GACT,MAAAqE,GAAArE,GAIAqZ,EAAAU,GAAAzB,YAAA,SAAA1F,GACAA,EAAA8N,WAAA,8BAAArH,EAAAgB,UAAA,6DACA1F,EAAAqH,QAAA3C,EACAjV,KACa,SAAAwO,EAAArL,GACblD,EAAAkD,QAMA,OADA8R,GAAAsH,WAAAC,GACAN,EAGA,QAAAO,GAAAziB,EAAA2P,GACA,GAAA4G,GAAAvT,IAGA,iBAAAhD,KACAgR,QAAAoL,KAAApc,EAAA,2CACAA,EAAAwN,OAAAxN,GAGA,IAAA2I,GAAA,GAAAqR,IAAA,SAAAhU,EAAAC,GACAsQ,EAAA9F,QAAA7H,KAAA,WACA,GAAAqS,GAAA1E,EAAAqH,OACA3C,GAAAU,GAAAzB,YAAA,SAAA1F,GACAA,EAAA8N,WAAA,iBAAArH,EAAAgB,UAAA,0BAAAjc,GAAA,SAAAwU,EAAAkO,GACA,GAAAviB,GAAAuiB,EAAAC,KAAA5iB,OAAA2iB,EAAAC,KAAAC,KAAA,GAAA9hB,MAAA,IAIAX,KACAA,EAAA8a,EAAAsH,WAAApB,YAAAhhB,IAGA6F,EAAA7F,IACiB,SAAAqU,EAAArL,GAEjBlD,EAAAkD,SAGS,MAAAlD,IAIT,OADAuT,GAAA7Q,EAAAgH,GACAhH,EAGA,QAAAka,GAAApE,EAAA9O,GACA,GAAA4G,GAAAvT,KAEA2F,EAAA,GAAAqR,IAAA,SAAAhU,EAAAC,GACAsQ,EAAA9F,QAAA7H,KAAA,WACA,GAAAqS,GAAA1E,EAAAqH,OAEA3C,GAAAU,GAAAzB,YAAA,SAAA1F,GACAA,EAAA8N,WAAA,iBAAArH,EAAAgB,aAAA,SAAAzH,EAAAkO,GAIA,OAHAC,GAAAD,EAAAC,KACA5iB,EAAA4iB,EAAA5iB,OAEAvD,EAAA,EAAmCA,EAAAuD,EAAYvD,IAAA,CAC/C,GAAAomB,GAAAD,EAAAC,KAAApmB,GACA2D,EAAAyiB,EAAA9hB,KAYA,IARAX,IACAA,EAAA8a,EAAAsH,WAAApB,YAAAhhB,QAOA,MAJAA,EAAAse,EAAAte,EAAAyiB,EAAA5iB,IAAAxD,EAAA,IAMA,WADAwJ,GAAA7F,GAKA6F,KACiB,SAAAwO,EAAArL,GACjBlD,EAAAkD,SAGS,MAAAlD,IAIT,OADAuT,GAAA7Q,EAAAgH,GACAhH,EAGA,QAAAma,GAAA9iB,EAAAc,EAAA6O,EAAAoT,GACA,GAAAxM,GAAAvT,IAGA,iBAAAhD,KACAgR,QAAAoL,KAAApc,EAAA,2CACAA,EAAAwN,OAAAxN,GAGA,IAAA2I,GAAA,GAAAqR,IAAA,SAAAhU,EAAAC,GACAsQ,EAAA9F,QAAA7H,KAAA,eAIAT,KAAArH,IACAA,EAAA,KAIA,IAAAkiB,GAAAliB,EAEAma,EAAA1E,EAAAqH,OACA3C,GAAAsH,WAAAvC,UAAAlf,EAAA,SAAAA,EAAAqI,GACAA,EACAlD,EAAAkD,GAEA8R,EAAAU,GAAAzB,YAAA,SAAA1F,GACAA,EAAA8N,WAAA,0BAAArH,EAAAgB,UAAA,+BAAAjc,EAAAc,GAAA,WACAkF,EAAAgd,IACyB,SAAAxO,EAAArL,GACzBlD,EAAAkD,MAEqB,SAAA8Z,GAGrB,GAAAA,EAAA/Z,OAAA+Z,EAAAC,UAAA,CAQA,GAAAH,EAAA,EAEA,WADA/c,GAAA8c,EAAAtgB,MAAA+T,GAAAvW,EAAAgjB,EAAArT,EAAAoT,EAAA,IAGA9c,GAAAgd,UAKS,MAAAhd,IAIT,OADAuT,GAAA7Q,EAAAgH,GACAhH,EAGA,QAAAwa,GAAAnjB,EAAAc,EAAA6O,GACA,MAAAmT,GAAAtgB,MAAAQ,MAAAhD,EAAAc,EAAA6O,EAAA,IAGA,QAAAyT,GAAApjB,EAAA2P,GACA,GAAA4G,GAAAvT,IAGA,iBAAAhD,KACAgR,QAAAoL,KAAApc,EAAA,2CACAA,EAAAwN,OAAAxN,GAGA,IAAA2I,GAAA,GAAAqR,IAAA,SAAAhU,EAAAC,GACAsQ,EAAA9F,QAAA7H,KAAA,WACA,GAAAqS,GAAA1E,EAAAqH,OACA3C,GAAAU,GAAAzB,YAAA,SAAA1F,GACAA,EAAA8N,WAAA,eAAArH,EAAAgB,UAAA,kBAAAjc,GAAA,WACAgG,KACiB,SAAAwO,EAAArL,GAEjBlD,EAAAkD,SAGS,MAAAlD,IAIT,OADAuT,GAAA7Q,EAAAgH,GACAhH,EAKA,QAAA0a,GAAA1T,GACA,GAAA4G,GAAAvT,KAEA2F,EAAA,GAAAqR,IAAA,SAAAhU,EAAAC,GACAsQ,EAAA9F,QAAA7H,KAAA,WACA,GAAAqS,GAAA1E,EAAAqH,OACA3C,GAAAU,GAAAzB,YAAA,SAAA1F,GACAA,EAAA8N,WAAA,eAAArH,EAAAgB,aAAA,WACAjW,KACiB,SAAAwO,EAAArL,GACjBlD,EAAAkD,SAGS,MAAAlD,IAIT,OADAuT,GAAA7Q,EAAAgH,GACAhH,EAKA,QAAA2a,GAAA3T,GACA,GAAA4G,GAAAvT,KAEA2F,EAAA,GAAAqR,IAAA,SAAAhU,EAAAC,GACAsQ,EAAA9F,QAAA7H,KAAA,WACA,GAAAqS,GAAA1E,EAAAqH,OACA3C,GAAAU,GAAAzB,YAAA,SAAA1F,GAEAA,EAAA8N,WAAA,+BAAArH,EAAAgB,aAAA,SAAAzH,EAAAkO,GACA,GAAAviB,GAAAuiB,EAAAC,KAAAC,KAAA,GAAAhmB,CAEAoJ,GAAA7F,IACiB,SAAAqU,EAAArL,GAEjBlD,EAAAkD,SAGS,MAAAlD,IAIT,OADAuT,GAAA7Q,EAAAgH,GACAhH,EAUA,QAAA4a,GAAAjmB,EAAAqS,GACA,GAAA4G,GAAAvT,KAEA2F,EAAA,GAAAqR,IAAA,SAAAhU,EAAAC,GACAsQ,EAAA9F,QAAA7H,KAAA,WACA,GAAAqS,GAAA1E,EAAAqH,OACA3C,GAAAU,GAAAzB,YAAA,SAAA1F,GACAA,EAAA8N,WAAA,mBAAArH,EAAAgB,UAAA,yBAAA3e,EAAA,YAAAkX,EAAAkO,GACA,GAAAviB,GAAAuiB,EAAAC,KAAA5iB,OAAA2iB,EAAAC,KAAAC,KAAA,GAAA5iB,IAAA,IACAgG,GAAA7F,IACiB,SAAAqU,EAAArL,GACjBlD,EAAAkD,SAGS,MAAAlD,IAIT,OADAuT,GAAA7Q,EAAAgH,GACAhH,EAGA,QAAA6a,GAAA7T,GACA,GAAA4G,GAAAvT,KAEA2F,EAAA,GAAAqR,IAAA,SAAAhU,EAAAC,GACAsQ,EAAA9F,QAAA7H,KAAA,WACA,GAAAqS,GAAA1E,EAAAqH,OACA3C,GAAAU,GAAAzB,YAAA,SAAA1F,GACAA,EAAA8N,WAAA,mBAAArH,EAAAgB,aAAA,SAAAzH,EAAAkO,GAGA,OAFAtD,MAEA5iB,EAAA,EAAmCA,EAAAkmB,EAAAC,KAAA5iB,OAAyBvD,IAC5D4iB,EAAAlb,KAAAwe,EAAAC,KAAAC,KAAApmB,GAAAwD,IAGAgG,GAAAoZ,IACiB,SAAA5K,EAAArL,GAEjBlD,EAAAkD,SAGS,MAAAlD,IAIT,OADAuT,GAAA7Q,EAAAgH,GACAhH,EAiBA,QAAA8a,GAAA3F,GACA,GAAAvH,GAAAvT,KACAiY,IACA,IAAA6C,EACA,OAAAthB,KAAAshB,GACA7C,EAAAze,GAAAshB,EAAAthB,EAaA,OATAye,GAAAyI,UAAAzI,EAAAne,KAAA,IAEAme,EAAAgB,YAAA1F,EAAA6H,eAAAnC,YACAhB,EAAAyI,WAAAzI,EAAAgB,UAAA,KAGA1F,EAAAqH,QAAA3C,EACAA,EAAAsH,WAAAC,GAEAxI,GAAAhU,UAKA,QAAA2d,GAAAhU,GACA,GAAA4G,GAAAvT,KACA2F,EAAA4N,EAAA9F,QAAA7H,KAAA,WAGA,OAFA8a,GAAAnN,EAAAqH,QAAA8F,UAEAlnB,EAAAonB,aAAA7jB,OAAA,EAA6CvD,GAAA,EAAQA,IAAA,CACrD,GAAAwD,GAAA4jB,aAAA5jB,IAAAxD,EAEA,KAAAwD,EAAAsH,QAAAoc,IACAE,aAAA7E,WAAA/e,KAMA,OADAwZ,GAAA7Q,EAAAgH,GACAhH,EAMA,QAAAkb,GAAA7jB,EAAA2P,GACA,GAAA4G,GAAAvT,IAGA,iBAAAhD,KACAgR,QAAAoL,KAAApc,EAAA,2CACAA,EAAAwN,OAAAxN,GAGA,IAAA2I,GAAA4N,EAAA9F,QAAA7H,KAAA,WACA,GAAAqS,GAAA1E,EAAAqH,QACAzd,EAAAyjB,aAAA7R,QAAAkJ,EAAAyI,UAAA1jB,EAUA,OAJAG,KACAA,EAAA8a,EAAAsH,WAAApB,YAAAhhB,IAGAA,GAIA,OADAqZ,GAAA7Q,EAAAgH,GACAhH,EAIA,QAAAmb,GAAArF,EAAA9O,GACA,GAAA4G,GAAAvT,KAEA2F,EAAA4N,EAAA9F,QAAA7H,KAAA,WAcA,OAbAqS,GAAA1E,EAAAqH,QACA8F,EAAAzI,EAAAyI,UACAK,EAAAL,EAAA3jB,OACAA,EAAA6jB,aAAA7jB,OAQA4e,EAAA,EAEAniB,EAAA,EAAuBA,EAAAuD,EAAYvD,IAAA,CACnC,GAAAwD,GAAA4jB,aAAA5jB,IAAAxD,EACA,QAAAwD,EAAAsH,QAAAoc,GAAA,CAGA,GAAA5iB,GAAA8iB,aAAA7R,QAAA/R,EAYA,IANAc,IACAA,EAAAma,EAAAsH,WAAApB,YAAArgB,QAKA,MAFAA,EAAA2d,EAAA3d,EAAAd,EAAA+f,UAAAgE,GAAApF,MAGA,MAAA7d,MAMA,OADA0Y,GAAA7Q,EAAAgH,GACAhH,EAIA,QAAAqb,GAAA1mB,EAAAqS,GACA,GAAA4G,GAAAvT,KACA2F,EAAA4N,EAAA9F,QAAA7H,KAAA,WACA,GACAzI,GADA8a,EAAA1E,EAAAqH,OAEA,KACAzd,EAAAyjB,aAAA5jB,IAAA1C,GACS,MAAA6L,GACThJ,EAAA,KAQA,MAJAA,KACAA,IAAA4f,UAAA9E,EAAAyI,UAAA3jB,SAGAI,GAIA,OADAqZ,GAAA7Q,EAAAgH,GACAhH,EAGA,QAAAsb,GAAAtU,GACA,GAAA4G,GAAAvT,KACA2F,EAAA4N,EAAA9F,QAAA7H,KAAA,WAKA,OAJAqS,GAAA1E,EAAAqH,QACA7d,EAAA6jB,aAAA7jB,OACAqf,KAEA5iB,EAAA,EAAuBA,EAAAuD,EAAYvD,IACnC,IAAAonB,aAAA5jB,IAAAxD,GAAA8K,QAAA2T,EAAAyI,YACAtE,EAAAlb,KAAA0f,aAAA5jB,IAAAxD,GAAAujB,UAAA9E,EAAAyI,UAAA3jB,QAIA,OAAAqf,IAIA,OADA5F,GAAA7Q,EAAAgH,GACAhH,EAIA,QAAAub,GAAAvU,GACA,GAAA4G,GAAAvT,KACA2F,EAAA4N,EAAA6I,OAAAxW,KAAA,SAAAwW,GACA,MAAAA,GAAArf,QAIA,OADAyZ,GAAA7Q,EAAAgH,GACAhH,EAIA,QAAAwb,GAAAnkB,EAAA2P,GACA,GAAA4G,GAAAvT,IAGA,iBAAAhD,KACAgR,QAAAoL,KAAApc,EAAA,2CACAA,EAAAwN,OAAAxN,GAGA,IAAA2I,GAAA4N,EAAA9F,QAAA7H,KAAA,WACA,GAAAqS,GAAA1E,EAAAqH,OACAgG,cAAA7E,WAAA9D,EAAAyI,UAAA1jB,IAIA,OADAwZ,GAAA7Q,EAAAgH,GACAhH,EAOA,QAAAyb,GAAApkB,EAAAc,EAAA6O,GACA,GAAA4G,GAAAvT,IAGA,iBAAAhD,KACAgR,QAAAoL,KAAApc,EAAA,2CACAA,EAAAwN,OAAAxN,GAGA,IAAA2I,GAAA4N,EAAA9F,QAAA7H,KAAA,eAGAT,KAAArH,IACAA,EAAA,KAIA,IAAAkiB,GAAAliB,CAEA,WAAAkZ,IAAA,SAAAhU,EAAAC,GACA,GAAAgV,GAAA1E,EAAAqH,OACA3C,GAAAsH,WAAAvC,UAAAlf,EAAA,SAAAA,EAAAqI,GACA,GAAAA,EACAlD,EAAAkD,OAEA,KACAya,aAAArR,QAAA0I,EAAAyI,UAAA1jB,EAAAc,GACAkF,EAAAgd,GACqB,MAAAphB,GAGrB,uBAAAA,EAAA9E,MAAA,+BAAA8E,EAAA9E,MACAmJ,EAAArE,GAEAqE,EAAArE,SAQA,OADA4X,GAAA7Q,EAAAgH,GACAhH,EA0DA,QAAA0b,GAAAC,EAAAC,GACAD,EAAAC,GAAA,WACA,GAAAC,GAAApkB,SACA,OAAAkkB,GAAA7T,QAAA7H,KAAA,WACA,MAAA0b,GAAAC,GAAA/hB,MAAA8hB,EAAAE,MAKA,QAAAnkB,KACA,OAAA7D,GAAA,EAAmBA,EAAA4D,UAAAL,OAAsBvD,IAAA,CACzC,GAAAioB,GAAArkB,UAAA5D,EAEA,IAAAioB,EACA,OAAAzkB,KAAAykB,GACAA,EAAA9mB,eAAAqC,KACAlC,GAAA2mB,EAAAzkB,IACAI,UAAA,GAAAJ,GAAAykB,EAAAzkB,GAAAuK,QAEAnK,UAAA,GAAAJ,GAAAykB,EAAAzkB,IAOA,MAAAI,WAAA,GAGA,QAAAskB,IAAAC,GACA,OAAAC,KAAAC,IACA,GAAAA,GAAAlnB,eAAAinB,IAAAC,GAAAD,KAAAD,EACA,QAIA,UAjpDA,GAAAG,IAAA,kBAAAC,SAAA,gBAAAA,QAAAtG,SAAA,SAAA5e,GAAoG,aAAAA,IAAqB,SAAAA,GAAmB,MAAAA,IAAA,kBAAAklB,SAAAllB,EAAAuK,cAAA2a,QAAAllB,IAAAklB,OAAArnB,UAAA,eAAAmC,IAyB5Ika,GArBA,WAEA,IACA,sBAAAiL,WACA,MAAAA,UAEA,uBAAAC,iBACA,MAAAA,gBAEA,uBAAAC,cACA,MAAAA,aAEA,uBAAAC,YACA,MAAAA,WAEA,uBAAAC,aACA,MAAAA,aAEK,MAAAxjB,OAsEL,oBAAAmE,UAGA6O,EAAA,EAEA,IA0BAmG,IACAI,GA3BAnB,GAAAjU,QAyBAoU,GAAA,mCAGAnc,GAAAf,OAAAS,UAAAM,SA8oBAqnB,IACAC,QAAA,eACAzH,eACAW,UACAzM,UACAQ,UACAwM,aACAC,QACAjf,SACAC,MACAof,QAMAS,GAAA,mEAEAmB,GAAA,uBACAO,GAAA,gCAEApB,GAAA,YACAiB,GAAAjB,GAAApgB,OAGAqgB,GAAA,OACAa,GAAA,OACAZ,GAAA,OACAC,GAAA,OACAC,GAAA,OACAC,GAAA,OACAE,GAAA,OACAD,GAAA,OACAE,GAAA,OACAC,GAAA,OACAC,GAAA,OACAS,GAAAF,GAAAhB,GAAArgB,OAEAmgB,GAAAjjB,OAAAS,UAAAM,SAiMAwkB,IACAxC,YACAmB,cACA9B,iBACAS,kBAkUAyF,IACAD,QAAA,gBACAzH,aAAAoE,EACAzD,QAAAqE,EACA9Q,QAAA0Q,EACAlQ,QAAA4Q,EACApE,WAAAqE,EACApE,MAAAqE,EACAtjB,OAAAujB,EACAtjB,IAAAujB,EACAnE,KAAAoE,GAoPAgC,IACAF,QAAA,sBACAzH,aAAA4F,EAEAjF,QAAAsF,EACA/R,QAAA8R,EACAtR,QAAA6R,EACArF,WAAAoF,EACAnF,MAAA2E,EACA5jB,OAAAmkB,EACAlkB,IAAAgkB,EACA5E,KAAA6E,GAKAwB,MAEAZ,IACAa,UAAA,eACAC,aAAA,sBACAC,OAAA,iBAGAC,IAAAhB,GAAAa,UAAAb,GAAAe,OAAAf,GAAAc,cAEAG,IAAA,0EAEAC,IACA3D,YAAA,GACAwC,OAAAiB,GAAAtb,QACAzN,KAAA,cAGAulB,KAAA,QACApG,UAAA,gBACA1X,QAAA,GAGAyhB,KAMAA,IAAAnB,GAAAa,WAxkDA,WACA,IAGA,IAAA3L,GACA,QAMA,IAAAkM,GAAA,mBAAA9D,eAAA,4BAAApV,KAAAvN,UAAAwN,aAAA,SAAAD,KAAAvN,UAAAwN,aAAA,aAAAD,KAAAvN,UAAA0mB,UAEAC,EAAA,kBAAAC,SAAA,IAAAA,MAAApoB,WAAAsJ,QAAA,eAIA,SAAA2e,GAAAE,IAAA,mBAAAnB,YAGA,mBAAAqB,aACK,MAAAzkB,GACL,aAojDAokB,GAAAnB,GAAAe,QAhjDA,WACA,wBAAAzD,iBAijDA6D,GAAAnB,GAAAc,cA9iDA,WACA,IACA,yBAAA/B,eAAA,WAAAA,4BAAArR,QACK,MAAA3Q,GACL,YA4iDA,IAAA9D,IAAAyE,MAAAzE,SAAA,SAAA2mB,GACA,yBAAAxnB,OAAAS,UAAAM,SAAAtB,KAAA+nB,IA0CA6B,GAAA,WACA,QAAAA,GAAAxI,GACApF,EAAA1V,KAAAsjB,GAEAtjB,KAAA0iB,UAAAb,GAAAa,UACA1iB,KAAA2iB,aAAAd,GAAAc,aACA3iB,KAAA4iB,OAAAf,GAAAe,OAEA5iB,KAAAob,eAAA/d,KAAuC0lB,IACvC/iB,KAAAujB,QAAAlmB,KAAgC2C,KAAAob,eAAAN,GAChC9a,KAAAwjB,WAAA,KACAxjB,KAAAyjB,YAAA,KACAzjB,KAAA0jB,QAAA,EACA1jB,KAAA4a,QAAA,KAEA5a,KAAA2jB,+BACA3jB,KAAA4jB,UAAA5jB,KAAAujB,QAAA3B,QAAA,oBA+PA,MAtPA0B,GAAA5oB,UAAAoI,OAAA,SAAAgY,GAIA,wBAAAA,EAAA,YAAAgH,GAAAhH,IAAA,CAGA,GAAA9a,KAAA0jB,OACA,UAAAhkB,OAAA,uDAGA,QAAAlG,KAAAshB,GAAA,CAKA,GAJA,cAAAthB,IACAshB,EAAAthB,GAAAshB,EAAAthB,GAAA8C,QAAA,YAGA,YAAA9C,GAAA,gBAAAshB,GAAAthB,GACA,UAAAkG,OAAA,qCAGAM,MAAAujB,QAAA/pB,GAAAshB,EAAAthB,GAKA,kBAAAshB,MAAA8G,SACA5hB,KAAA4jB,UAAA5jB,KAAAujB,QAAA3B,QAIS,sBAAA9G,GACT9a,KAAAujB,QAAAzI,GAEA9a,KAAAujB,SAQAD,EAAA5oB,UAAAmpB,aAAA,SAAAC,EAAAnX,EAAA+J,GACA,GAAA/Q,GAAA,GAAAqR,IAAA,SAAAhU,EAAAC,GACA,IACA,GAAA0e,GAAAmC,EAAAxB,QACAyB,EAAA,GAAArkB,OAAA,wFACAskB,EAAA,GAAAtkB,OAAA,sCAAAokB,EAAAxB,QAIA,KAAAwB,EAAAxB,QAEA,WADArf,GAAA8gB,EAGA,IAAArC,GAAAoC,EAAAxB,SAEA,WADArf,GAAA+gB,EAKA,QADAC,GAAAnB,GAAAriB,OAAA,gBACAjH,EAAA,EAA+BA,EAAAyqB,EAAAlnB,OAAgCvD,IAAA,CAC/D,GAAA0qB,GAAAD,EAAAzqB,EACA,KAAA0qB,IAAAJ,EAAAI,IAAA,kBAAAJ,GAAAI,GAEA,WADAjhB,GAAA8gB,GAKA,GAAAI,GAAAnN,GAAAhU,SAAA,EACA,aAAA8gB,KAEAK,EADAL,EAAAM,UAAA,kBAAAN,GAAAM,SACAN,EAAAM,WAEApN,GAAAhU,UAAA8gB,EAAAM,WAIAD,EAAAve,KAAA,SAAAye,GACArB,GAAArB,GAAA0C,EACA5B,GAAAd,GAAAmC,EACA9gB,KACiBC,GACJ,MAAArE,GACbqE,EAAArE,KAKA,OADA6X,GAAA9Q,EAAAgH,EAAA+J,GACA/Q,GAGA2d,EAAA5oB,UAAAknB,OAAA,WACA,MAAA5hB,MAAAsiB,SAAA,MAGAgB,EAAA5oB,UAAA4pB,UAAA,SAAA3C,EAAAhV,EAAA+J,GACA,GAAAnD,GAAAvT,KACAukB,EAAAvN,GAAAhU,UAAA4C,KAAA,WACA,IAAA8b,GAAAC,GASa,IAAAc,GAAAd,GACb,MAAAc,IAAAd,EAEA,UAAAjiB,OAAA,qBAXA,OAAAiiB,GACA,IAAApO,GAAAmP,UACA,MAAAL,GACA,KAAA9O,GAAAoP,aACA,MAAAH,GACA,KAAAjP,GAAAqP,OACA,MAAAL,MASA,OADA9L,GAAA8N,EAAA5X,EAAA+J,GACA6N,GAGAjB,EAAA5oB,UAAA8pB,cAAA,SAAA7X,GACA,GAAA8X,GAAAzN,GAAAhU,QAAAwc,GAEA,OADA/I,GAAAgO,EAAA9X,GACA8X,GAGAnB,EAAA5oB,UAAA+S,MAAA,SAAAd,GACA,GAAA4G,GAAAvT,KAEA2F,EAAA4N,EAAAiQ,WAAA5d,KAAA,WAKA,MAJA,QAAA2N,EAAAmQ,SACAnQ,EAAAmQ,OAAAnQ,EAAAkQ,eAGAlQ,EAAAmQ,QAIA,OADAjN,GAAA9Q,EAAAgH,KACAhH,GAGA2d,EAAA5oB,UAAAkpB,UAAA,SAAAc,EAAA/X,EAAA+J,GASA,QAAAiO,KACApR,EAAAgQ,QAAA3B,OAAArO,EAAAqO,SAGA,QAAAgD,GAAAhD,GAKA,MAJArO,GAAAsR,QAAAjD,GACA+C,IAEApR,EAAAmQ,OAAAnQ,EAAAsH,aAAAtH,EAAAgQ,SACAhQ,EAAAmQ,OAGA,QAAAoB,GAAAC,GACA,kBAGA,QAAAC,KACA,KAAAC,EAAAF,EAAAhoB,QAAA,CACA,GAAA4kB,GAAAoD,EAAAE,EAMA,OALAA,KAEA1R,EAAAqH,QAAA,KACArH,EAAAmQ,OAAA,KAEAnQ,EAAA+Q,UAAA3C,GAAA/b,KAAAgf,GAAA,MAAAI,GAGAL,GACA,IAAAxe,GAAA,GAAAzG,OAAA,qCAEA,OADA6T,GAAAiQ,WAAAxM,GAAA/T,OAAAkD,GACAoN,EAAAiQ,WAhBA,GAAAyB,GAAA,CAmBA,OAAAD,MAzCA,GAAAzR,GAAAvT,IAEAlF,IAAA4pB,KACAA,MAGA,IAAAK,GAAA/kB,KAAAklB,qBAAAR,GA0CAS,EAAA,OAAAnlB,KAAAwjB,WAAAxjB,KAAAwjB,WAAA,iBACA,MAAAxM,IAAAhU,YACSgU,GAAAhU,SAqBT,OAnBAhD,MAAAwjB,WAAA2B,EAAAvf,KAAA,WACA,GAAA+b,GAAAoD,EAAA,EAIA,OAHAxR,GAAAqH,QAAA,KACArH,EAAAmQ,OAAA,KAEAnQ,EAAA+Q,UAAA3C,GAAA/b,KAAA,SAAAgc,GACArO,EAAA+O,QAAAV,EAAAU,QACAqC,IACApR,EAAAoQ,+BACApQ,EAAAkQ,YAAAqB,EAAAC,OAES,iBACTJ,GACA,IAAAxe,GAAA,GAAAzG,OAAA,qCAEA,OADA6T,GAAAiQ,WAAAxM,GAAA/T,OAAAkD,GACAoN,EAAAiQ,aAGA/M,EAAAzW,KAAAwjB,WAAA7W,EAAA+J,GACA1W,KAAAwjB,YAGAF,EAAA5oB,UAAA0qB,SAAA,SAAAzD,GACA,QAAAqB,GAAArB,IAGA2B,EAAA5oB,UAAAmqB,QAAA,SAAAQ,GACAhoB,EAAA2C,KAAAqlB,IAGA/B,EAAA5oB,UAAAwqB,qBAAA,SAAAR,GAEA,OADAK,MACAvrB,EAAA,EAAAoH,EAAA8jB,EAAA3nB,OAA6CvD,EAAAoH,EAASpH,IAAA,CACtD,GAAAmoB,GAAA+C,EAAAlrB,EACAwG,MAAAolB,SAAAzD,IACAoD,EAAA7jB,KAAAygB,GAGA,MAAAoD,IAGAzB,EAAA5oB,UAAAipB,6BAAA,WAKA,OAAAnqB,GAAA,EAAuBA,EAAAspB,GAAA/lB,OAA2BvD,IAClD6nB,EAAArhB,KAAA8iB,GAAAtpB,KAIA8pB,EAAA5oB,UAAA4L,eAAA,SAAAwU,GACA,UAAAwI,GAAAxI,IAGAwI,KAOAgC,GAAA,GAAAhC,GAEA/pB,GAAAD,QAAAgsB,KAEG9P,EAAA,SAAW,W/B4jEe9b,KAAKJ,EAASH,EAAoB,MAIzD,SAAUI,EAAQD,GgCv0IxB,GAAAisB,EAGAA,GAAA,WACA,MAAAvlB,QAGA,KAEAulB,KAAAC,SAAA,qBAAAC,MAAA,QACC,MAAA7mB,GAED,gBAAAlC,UACA6oB,EAAA7oB,QAOAnD,EAAAD,QAAAisB,GhC80IM,SAAUhsB,EAAQD,EAASH,GAEjC,YiC70IA,SAASusB,GAAajkB,GACpBA,IAAOA,EACPkkB,EAAalkB,EAAKmkB,EAAkBC,GACpCpV,EAAmBE,QAAUlP,EAC7BA,EAAKqkB,EAAkBC,UAAUC,IAAI,cACjCF,EAAkBC,UAAUta,OAAO,cAOzC,QAASwa,GAAaC,GAEpB,GAAMC,KAAgBD,CACtBzV,GAAmB2V,UAAYD,EAE1BA,GAMHR,EAAalV,EAAmBE,QAAUiV,EAAkBC,GAC5DC,EAAkBC,UAAUta,OAAO,iBANnCqa,EAAkBC,UAAUta,OAAO,cACnCqa,EAAkBC,UAAUC,IAAI,eAChCL,EAAaU,GACb5V,EAAmBE,SAAU,GAYjC,QAASE,KACPJ,EAAmB2V,UAAW,EAC9BN,EAAkBC,UAAUC,IAAI,eAMlC,QAASL,GAAazmB,GACpBonB,EAAmBpV,YAAchS,EAOnC,QAASyP,GAAaJ,GACpB0X,GAAa,GACbP,IAAenX,GjC6xIjBtU,OAAOC,eAAeZ,EAAS,cAC7BwE,OAAO,GiC11IT,IAAMyoB,GAAO5pB,SAASwU,cAAc,wBAC9BmV,EAAqBC,EAAKpV,cAAc,wBACxCV,EAAqB8V,EAAKpV,cAAc,SACxC2U,EAAoBrV,EAAmBqC,WAEvCuT,EAAqB,kCACrBT,EAAkB,KAClBC,EAAmB,KjCi6IzBvsB,GiCz2ISqV,ejC02ITrV,EiC12IuB2sB,ejC22IvB3sB,EiC32IqCmX,qBjC42IrCnX,EiC52IyDuX,cjCg3InD,SAAUtX,EAAQD,EAASH,GAEjC,YkCn7IA,SAAS0V,GAAgBN,GACvB,IAAKA,EAEH,YADAiY,EAAqBxV,MAAMC,QAAU,OAInC1C,KACFiY,EAAqBxV,MAAMC,QAAU,GACrCwV,EAAiBC,UAAYloB,KAAKC,UAAU8P,EAAkB,KAAM,IAIxE,QAASoY,GAAgB7a,GACvB8a,EAASF,UAAY5a,EAGvB,QAAS6D,GAAsBhL,GAC7BiiB,EAASF,UAAY/hB,EAAS8K,IAC9BoX,EAAWH,UAAYloB,KAAKC,UAAUkG,EAAU,KAAM,GAGxD,QAASiL,KACPgX,EAASF,UAAY,gBACrBG,EAAWH,UAAY,gBlC+5IzBzsB,OAAOC,eAAeZ,EAAS,cAC7BwE,OAAO,GkCh8IT,IAAM0oB,GAAuB7pB,SAASwU,cAAc,sBAE9C0V,EAAaL,EAAqBrV,cAAc,6BAChDsV,EAAmBD,EAAqBrV,cAAc,cACtDyV,EAAWJ,EAAqBrV,cAAc,kBlCo+IpD7X,GkCr8ISuV,kBlCs8ITvV,EkCt8I0BqtB,kBlCu8I1BrtB,EkCv8I2CqW,wBlCw8I3CrW,EkCx8IkEsW,sBlC48I5D,SAAUrW,EAAQD,EAASH,GAEjC,YmCx+IA,SAASmW,GAAoBzB,GAC3B,MAAOiZ,GAAA3f,QAAM4f,KAAKC,GAChBnZ,aAAcrP,KAAKG,MAAMH,KAAKC,UAAUoP,MAI5C,QAAS2B,GAAoByX,GAC3B,MAAOH,GAAA3f,QAAM+f,OAAOF,GAClBzoB,MACEuN,GAAImb,GAENviB,aAAc,SAIlB,QAASkJ,GAAiBqZ,GACxB,MAAOH,GAAA3f,QAAM9M,IAAI2sB,GAAiB9iB,QAAU4H,GAAImb,KnC29IlDhtB,OAAOC,eAAeZ,EAAS,cAC7BwE,OAAO,GmCp/IT,IAAAiS,GAAA5W,EAAA,GnCy/II2tB,EAEJ,SAAgCjqB,GAAO,MAAOA,IAAOA,EAAItC,WAAasC,GAAQsK,QAAStK,IAFlDkT,GmCt/I/BiX,EAAgBG,6CnCuhJtB7tB,GAAQ6N,SmC//IUmI,qBAAoB1B,kBAAiB4B,uBnCmgJjD,SAAUjW,EAAQD,EAASH,GoCliJjCI,EAAAD,QAAAH,EAAAyB,EAAA","file":"app.bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"./\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 27);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar bind = __webpack_require__(2);\nvar isBuffer = __webpack_require__(10);\n\n/*global toString:true*/\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object' && !isArray(obj)) {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (typeof result[key] === 'object' && typeof val === 'object') {\n      result[key] = merge(result[key], val);\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim\n};\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(process) {\n\nvar utils = __webpack_require__(0);\nvar normalizeHeaderName = __webpack_require__(12);\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = __webpack_require__(4);\n  } else if (typeof process !== 'undefined') {\n    // For node use HTTP adapter\n    adapter = __webpack_require__(4);\n  }\n  return adapter;\n}\n\nvar defaults = {\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Content-Type');\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data)) {\n      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');\n      return JSON.stringify(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    /*eslint no-param-reassign:0*/\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (e) { /* Ignore */ }\n    }\n    return data;\n  }],\n\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(process) {\n\nvar utils = __webpack_require__(0);\nvar settle = __webpack_require__(13);\nvar buildURL = __webpack_require__(15);\nvar parseHeaders = __webpack_require__(16);\nvar isURLSameOrigin = __webpack_require__(17);\nvar createError = __webpack_require__(5);\nvar btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || __webpack_require__(18);\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n    var loadEvent = 'onreadystatechange';\n    var xDomain = false;\n\n    // For IE 8/9 CORS support\n    // Only supports POST and GET calls and doesn't returns the response headers.\n    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.\n    if (process.env.NODE_ENV !== 'test' &&\n        typeof window !== 'undefined' &&\n        window.XDomainRequest && !('withCredentials' in request) &&\n        !isURLSameOrigin(config.url)) {\n      request = new window.XDomainRequest();\n      loadEvent = 'onload';\n      xDomain = true;\n      request.onprogress = function handleProgress() {};\n      request.ontimeout = function handleTimeout() {};\n    }\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    // Listen for ready state\n    request[loadEvent] = function handleLoad() {\n      if (!request || (request.readyState !== 4 && !xDomain)) {\n        return;\n      }\n\n      // The request errored out and we didn't get a response, this will be\n      // handled by onerror instead\n      // With one exception: request that using file: protocol, most browsers\n      // will return status as 0 even though it's a successful request\n      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n        return;\n      }\n\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201)\n        status: request.status === 1223 ? 204 : request.status,\n        statusText: request.status === 1223 ? 'No Content' : request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      var cookies = __webpack_require__(19);\n\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?\n          cookies.read(config.xsrfCookieName) :\n          undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (config.withCredentials) {\n      request.withCredentials = true;\n    }\n\n    // Add responseType to request if needed\n    if (config.responseType) {\n      try {\n        request.responseType = config.responseType;\n      } catch (e) {\n        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.\n        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.\n        if (config.responseType !== 'json') {\n          throw e;\n        }\n      }\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (requestData === undefined) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar enhanceError = __webpack_require__(14);\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(9);\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(0);\nvar bind = __webpack_require__(2);\nvar Axios = __webpack_require__(11);\nvar defaults = __webpack_require__(1);\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(utils.merge(defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = __webpack_require__(7);\naxios.CancelToken = __webpack_require__(25);\naxios.isCancel = __webpack_require__(6);\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = __webpack_require__(26);\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\n/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar defaults = __webpack_require__(1);\nvar utils = __webpack_require__(0);\nvar InterceptorManager = __webpack_require__(20);\nvar dispatchRequest = __webpack_require__(21);\nvar isAbsoluteURL = __webpack_require__(23);\nvar combineURLs = __webpack_require__(24);\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = utils.merge({\n      url: arguments[0]\n    }, arguments[1]);\n  }\n\n  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);\n  config.method = config.method.toLowerCase();\n\n  // Support baseURL config\n  if (config.baseURL && !isAbsoluteURL(config.url)) {\n    config.url = combineURLs(config.baseURL, config.url);\n  }\n\n  // Hook up interceptors middleware\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(0);\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar createError = __webpack_require__(5);\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  // Note: status is not exposed by XDomainRequest\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n  error.request = request;\n  error.response = response;\n  return error;\n};\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(0);\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%40/gi, '@').\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      }\n\n      if (!utils.isArray(val)) {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(0);\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n    }\n  });\n\n  return parsed;\n};\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(0);\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n  (function standardBrowserEnv() {\n    var msie = /(msie|trident)/i.test(navigator.userAgent);\n    var urlParsingNode = document.createElement('a');\n    var originURL;\n\n    /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n    function resolveURL(url) {\n      var href = url;\n\n      if (msie) {\n        // IE needs attribute set twice to normalize properties\n        urlParsingNode.setAttribute('href', href);\n        href = urlParsingNode.href;\n      }\n\n      urlParsingNode.setAttribute('href', href);\n\n      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n      return {\n        href: urlParsingNode.href,\n        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n        host: urlParsingNode.host,\n        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n        hostname: urlParsingNode.hostname,\n        port: urlParsingNode.port,\n        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n                  urlParsingNode.pathname :\n                  '/' + urlParsingNode.pathname\n      };\n    }\n\n    originURL = resolveURL(window.location.href);\n\n    /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n    return function isURLSameOrigin(requestURL) {\n      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n      return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n    };\n  })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n  (function nonStandardBrowserEnv() {\n    return function isURLSameOrigin() {\n      return true;\n    };\n  })()\n);\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js\n\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfunction E() {\n  this.message = 'String contains an invalid character';\n}\nE.prototype = new Error;\nE.prototype.code = 5;\nE.prototype.name = 'InvalidCharacterError';\n\nfunction btoa(input) {\n  var str = String(input);\n  var output = '';\n  for (\n    // initialize result and counter\n    var block, charCode, idx = 0, map = chars;\n    // if the next str index does not exist:\n    //   change the mapping table to \"=\"\n    //   check if d has no fractional digits\n    str.charAt(idx | 0) || (map = '=', idx % 1);\n    // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n    output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n  ) {\n    charCode = str.charCodeAt(idx += 3 / 4);\n    if (charCode > 0xFF) {\n      throw new E();\n    }\n    block = block << 8 | charCode;\n  }\n  return output;\n}\n\nmodule.exports = btoa;\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(0);\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n  (function standardBrowserEnv() {\n    return {\n      write: function write(name, value, expires, path, domain, secure) {\n        var cookie = [];\n        cookie.push(name + '=' + encodeURIComponent(value));\n\n        if (utils.isNumber(expires)) {\n          cookie.push('expires=' + new Date(expires).toGMTString());\n        }\n\n        if (utils.isString(path)) {\n          cookie.push('path=' + path);\n        }\n\n        if (utils.isString(domain)) {\n          cookie.push('domain=' + domain);\n        }\n\n        if (secure === true) {\n          cookie.push('secure');\n        }\n\n        document.cookie = cookie.join('; ');\n      },\n\n      read: function read(name) {\n        var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n        return (match ? decodeURIComponent(match[3]) : null);\n      },\n\n      remove: function remove(name) {\n        this.write(name, '', Date.now() - 86400000);\n      }\n    };\n  })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n  (function nonStandardBrowserEnv() {\n    return {\n      write: function write() {},\n      read: function read() { return null; },\n      remove: function remove() {}\n    };\n  })()\n);\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(0);\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(0);\nvar transformData = __webpack_require__(22);\nvar isCancel = __webpack_require__(6);\nvar defaults = __webpack_require__(1);\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData(\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers || {}\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData(\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData(\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(0);\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn(data, headers);\n  });\n\n  return data;\n};\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Cancel = __webpack_require__(7);\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n__webpack_require__(28);\n\nvar _axios = __webpack_require__(8);\n\nvar _axios2 = _interopRequireDefault(_axios);\n\nvar _supportCard = __webpack_require__(29);\n\nvar _supportCard2 = _interopRequireDefault(_supportCard);\n\nvar _localforage = __webpack_require__(30);\n\nvar _localforage2 = _interopRequireDefault(_localforage);\n\nvar _pushToggle = __webpack_require__(32);\n\nvar _pushInfo = __webpack_require__(33);\n\nvar _serverSubscription = __webpack_require__(34);\n\nvar _serverSubscription2 = _interopRequireDefault(_serverSubscription);\n\nvar _serviceWorker = __webpack_require__(35);\n\nvar _serviceWorker2 = _interopRequireDefault(_serviceWorker);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Global Variables Regarding the Support of the PushManager Related APIs\n// Imports all the Custom Styles as well as Material Design Lite\n// Using a Webpack Familiar Syntax\nvar swSupport = navigator && 'serviceWorker' in navigator;\n/**\n * Webpack Bundling Specific logic related to service worker.\n * Please IGNORE THIS!\n */\n\nvar pushSupport = window && 'PushManager' in window;\nvar isSupported = navigator && swSupport && pushSupport;\nvar SAFE_APPLICATION_SERVER_KEY = 'BFyMIWmgIvBFAbC-0CrU6tqfiqr4A4rcVqWtnHncpPuKeFfGrnHCjOfvdumLoN6Lh8fdOecWdy2_yKF7dDPldAM';\n\n/*\n * Global Variables to hold the state of\n * - `pushManager` - Manager for Push Notifications\n * - `pushSubscription` - Current Subscription stored in global state\n * \n * `pushSubscription` is helpful to coordinate in actions such as\n * delete subscription so we don't have to do an additional getSubscription\n * call for the sake of this demo.\n */\nvar pushManager = null;\nvar pushSubscription = null;\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  (0, _supportCard2.default)(swSupport, pushSupport);\n  if (isSupported) {\n    // Registering the server here if supported\n    navigator.serviceWorker.register('./service-worker.js').catch(function (error) {\n      console.error('Failed to register the latest ServiceWorker');\n      throw error;\n    });\n\n    initSubscription();\n    _pushToggle.subscriptionSwitch.addEventListener('change', function (changeEvent) {\n      var checked = changeEvent.target.checked;\n      (0, _pushToggle.waitToggle)();\n      if (checked) {\n        subscribe();\n      } else {\n        unsubscribe();\n      }\n    });\n  }\n});\n\n/**\n * Helper Function to Convert a URL Base 64 String to a Uint8Array type in JavaScript\n * @param {String} base64String\n * @return {Uint8Array} Uint8Array type\n */\nfunction urlBase64ToUint8Array(base64String) {\n  var padding = '='.repeat((4 - base64String.length % 4) % 4);\n  var base64 = (base64String + padding).replace(/\\-/g, '+').replace(/_/g, '/');\n\n  var rawData = window.atob(base64);\n  var outputArray = new Uint8Array(rawData.length);\n\n  for (var i = 0; i < rawData.length; ++i) {\n    outputArray[i] = rawData.charCodeAt(i);\n  }\n  return outputArray;\n}\n\n/**\n * Initial Subscription related logic\n */\nfunction initSubscription() {\n  navigator.serviceWorker.ready.then(function (registration) {\n    pushManager = registration.pushManager;\n    pushManager.getSubscription().then(function (subscription) {\n      updateSubscriptionUI(subscription);\n    }).catch(function (error) {\n      console.error(error);\n      updateServerSubscription(null);\n    });\n  });\n}\n\n/**\n * Subscribes to the Push Manager and updates the\n * UI if successful\n */\nfunction subscribe() {\n  pushManager.subscribe({\n    userVisibleOnly: true,\n    applicationServerKey: urlBase64ToUint8Array(SAFE_APPLICATION_SERVER_KEY)\n  }).then(function (subscription) {\n    console.log('Subscribed!');\n    pushSubscription = subscription;\n    updateSubscriptionUI(subscription);\n  }).catch(function (error) {\n    console.log('Error occured while subscribing');\n    console.error(error);\n    updateSubscriptionUI(pushSubscription);\n  });\n}\n\n/**\n * Unsubscribes the PushSubscription\n * and updates the subscription UI \n */\nfunction unsubscribe() {\n  if (!pushSubscription) {\n    console.log('`pushSubscription` is null');\n    updateSubscriptionUI(null);\n    return;\n  }\n\n  return pushSubscription.unsubscribe().then(function (removed) {\n    pushSubscription = null;\n    updateSubscriptionUI(pushSubscription);\n  }).catch(function (error) {\n    console.error(error);\n    updateSubscriptionUI(pushSubscription);\n  });\n}\n\n// Updates the subscription on update\nfunction updateSubscriptionUI(subscription) {\n  (0, _pushToggle.updateSwitch)(subscription);\n  (0, _pushInfo.displayPushInfo)(subscription);\n  updateServerSubscription(subscription);\n}\n\n/**\n * Updates the Subscription on the Server side\n * if new\n */\nfunction updateServerSubscription(subscription) {\n  return _localforage2.default.getItem('subscription').then(function (savedSubscription) {\n    savedSubscription = JSON.parse(savedSubscription);\n\n    var _evalSubscriptionCond = evalSubscriptionConditions(savedSubscription, subscription),\n        shouldUpdate = _evalSubscriptionCond.shouldUpdate,\n        shouldDelete = _evalSubscriptionCond.shouldDelete;\n\n    if (!shouldUpdate && !shouldDelete) {\n      console.log('Both Subscriptions are same, do nothing');\n      return savedSubscription;\n    }\n\n    if (shouldUpdate) {\n      /**\n       * Further actions are dependent on successful \n       * createion of subscription on database\n       * \n       * This promise is going to be included within the promise chain.\n       */\n      return _serverSubscription2.default.createSubscription(subscription).then(function (response) {\n        var data = response.data;\n        console.log('Subscription Created ', data);\n        return _localforage2.default.setItem('subscription', JSON.stringify(data)).then(function () {\n          return data;\n        });\n      });\n    } else if (shouldDelete) {\n      return _localforage2.default.setItem('subscription', null).then(function () {\n        _serverSubscription2.default.deleteSubscription(savedSubscription._id);\n        return null;\n      });\n    }\n  }).then(function (newSubscription) {\n    // UI can be updated in this then function\n    // as related operations to the subscriptions have been performed on them\n    if (subscription) {\n      console.log('Displaying information for the subscription');\n      (0, _pushInfo.displayPushInfo)(subscription);\n      (0, _pushInfo.displayServerResponse)(newSubscription);\n    }\n  }).catch(function (error) {\n    console.error('Failure in updating the status');\n    console.error(error);\n    (0, _pushInfo.displayServerError)(error);\n  });\n}\n\n/**\n * Evaluate related conditions to the subscription\n */\nfunction evalSubscriptionConditions(savedSubscription, subscription) {\n  var endpointCondition = savedSubscription && subscription && savedSubscription.endpoint !== subscription.endpoint;\n\n  return {\n    shouldUpdate: !savedSubscription && subscription || endpointCondition,\n    shouldDelete: !subscription && savedSubscription\n  };\n}\n\n/**\n * Based on conditions when the subscription should \n * be deleted\n * \n * @param {PushSubscription} savedSubscription Subscription stored in the storage\n */\nfunction shouldDeleteSubscription(savedSubscription, subscription) {\n  return !subscription || savedSubscription.endpoint;\n}\n\n/**\n * Removes the Subscription from the Client\n */\nfunction removeSubscription(subscription) {\n  return _localforage2.default.getItem('subscription').then(function (subscription) {\n    if (subscription) {\n      console.log('Existing Subscription is going to be removed');\n      return Promise.all([_serverSubscription2.default.deleteSubscription(subscription._id), _localforage2.default.setItem('subscriptionId', null)]);\n    }\n  });\n}\n\n// Updates the Loading UI in order \n// to represent the loading state of the operations\n// Disables the toggle for the duration of the task being performed\n// in order to prevent from any other task to be executed\nfunction showLoadingUI() {\n  (0, _pushToggle.waitToggle)();\n}\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = updateSupportCard;\n/**\n * Asking important questions that needs answer\n * - What is the design pattern we can use, that let's us make reuse of the elements \n *   in the applications so we can keep our memory footprint low and save time that's spent\n *   in looking up for dom elements each time?\n */\n\nvar notSupportedCard = exports.notSupportedCard = document.querySelector('.not-supported');\nvar supportStatus = notSupportedCard.querySelector('.support-status');\nvar swSupport = supportStatus.querySelector('.service-worker .value');\nvar pushSupport = supportStatus.querySelector('.push-api .value');\n\nfunction updateSupportCard(serviceWorker, pushManager) {\n  if (serviceWorker && pushManager) {\n    notSupportedCard.style.display = 'none';\n  } else {\n    swSupport.textContent = serviceWorker ? 'Supported' : 'Not Supported';\n    pushSupport.textContent = pushManager ? 'Supported' : 'Not Supported';\n    notSupportedCard.style.display = 'block';\n  }\n}\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/*!\n    localForage -- Offline Storage, Improved\n    Version 1.5.0\n    https://localforage.github.io/localForage\n    (c) 2013-2017 Mozilla, Apache License 2.0\n*/\n(function(f){if(true){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.localforage = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw (f.code=\"MODULE_NOT_FOUND\", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],2:[function(_dereq_,module,exports){\n'use strict';\nvar immediate = _dereq_(1);\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && typeof obj === 'object' && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nexports.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nexports.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nexports.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nexports.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n},{\"1\":1}],3:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nif (typeof global.Promise !== 'function') {\n  global.Promise = _dereq_(2);\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"2\":2}],4:[function(_dereq_,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction getIDB() {\n    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */\n    try {\n        if (typeof indexedDB !== 'undefined') {\n            return indexedDB;\n        }\n        if (typeof webkitIndexedDB !== 'undefined') {\n            return webkitIndexedDB;\n        }\n        if (typeof mozIndexedDB !== 'undefined') {\n            return mozIndexedDB;\n        }\n        if (typeof OIndexedDB !== 'undefined') {\n            return OIndexedDB;\n        }\n        if (typeof msIndexedDB !== 'undefined') {\n            return msIndexedDB;\n        }\n    } catch (e) {}\n}\n\nvar idb = getIDB();\n\nfunction isIndexedDBValid() {\n    try {\n        // Initialize IndexedDB; fall back to vendor-prefixed versions\n        // if needed.\n        if (!idb) {\n            return false;\n        }\n        // We mimic PouchDB here;\n        //\n        // We test for openDatabase because IE Mobile identifies itself\n        // as Safari. Oh the lulz...\n        var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);\n\n        var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;\n\n        // Safari <10.1 does not meet our requirements for IDB support (#5572)\n        // since Safari 10.1 shipped with fetch, we can use that to detect it\n        return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&\n        // some outdated implementations of IDB that appear on Samsung\n        // and HTC Android devices <4.4 are missing IDBKeyRange\n        typeof IDBKeyRange !== 'undefined';\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction isWebSQLValid() {\n    return typeof openDatabase === 'function';\n}\n\nfunction isLocalStorageValid() {\n    try {\n        return typeof localStorage !== 'undefined' && 'setItem' in localStorage && localStorage.setItem;\n    } catch (e) {\n        return false;\n    }\n}\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\nfunction createBlob(parts, properties) {\n    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n    parts = parts || [];\n    properties = properties || {};\n    try {\n        return new Blob(parts, properties);\n    } catch (e) {\n        if (e.name !== 'TypeError') {\n            throw e;\n        }\n        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;\n        var builder = new Builder();\n        for (var i = 0; i < parts.length; i += 1) {\n            builder.append(parts[i]);\n        }\n        return builder.getBlob(properties.type);\n    }\n}\n\n// This is CommonJS because lie is an external dependency, so Rollup\n// can just ignore it.\nif (typeof Promise === 'undefined') {\n    // In the \"nopromises\" build this will just throw if you don't have\n    // a global promise object, but it would throw anyway later.\n    _dereq_(3);\n}\nvar Promise$1 = Promise;\n\nfunction executeCallback(promise, callback) {\n    if (callback) {\n        promise.then(function (result) {\n            callback(null, result);\n        }, function (error) {\n            callback(error);\n        });\n    }\n}\n\nfunction executeTwoCallbacks(promise, callback, errorCallback) {\n    if (typeof callback === 'function') {\n        promise.then(callback);\n    }\n\n    if (typeof errorCallback === 'function') {\n        promise[\"catch\"](errorCallback);\n    }\n}\n\n// Some code originally from async_storage.js in\n// [Gaia](https://github.com/mozilla-b2g/gaia).\n\nvar DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';\nvar supportsBlobs;\nvar dbContexts;\nvar toString = Object.prototype.toString;\n\n// Transform a binary string to an array buffer, because otherwise\n// weird stuff happens when you try to work with the binary string directly.\n// It is known.\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction _binStringToArrayBuffer(bin) {\n    var length = bin.length;\n    var buf = new ArrayBuffer(length);\n    var arr = new Uint8Array(buf);\n    for (var i = 0; i < length; i++) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return buf;\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\n// Code borrowed from PouchDB. See:\n// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js\n//\nfunction _checkBlobSupportWithoutCaching(idb) {\n    return new Promise$1(function (resolve) {\n        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, 'readwrite');\n        var blob = createBlob(['']);\n        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n\n        txn.onabort = function (e) {\n            // If the transaction aborts now its due to not being able to\n            // write to the database, likely due to the disk being full\n            e.preventDefault();\n            e.stopPropagation();\n            resolve(false);\n        };\n\n        txn.oncomplete = function () {\n            var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n            var matchedEdge = navigator.userAgent.match(/Edge\\//);\n            // MS Edge pretends to be Chrome 42:\n            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);\n        };\n    })[\"catch\"](function () {\n        return false; // error, so assume unsupported\n    });\n}\n\nfunction _checkBlobSupport(idb) {\n    if (typeof supportsBlobs === 'boolean') {\n        return Promise$1.resolve(supportsBlobs);\n    }\n    return _checkBlobSupportWithoutCaching(idb).then(function (value) {\n        supportsBlobs = value;\n        return supportsBlobs;\n    });\n}\n\nfunction _deferReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Create a deferred object representing the current database operation.\n    var deferredOperation = {};\n\n    deferredOperation.promise = new Promise$1(function (resolve) {\n        deferredOperation.resolve = resolve;\n    });\n\n    // Enqueue the deferred operation.\n    dbContext.deferredOperations.push(deferredOperation);\n\n    // Chain its promise to the database readiness.\n    if (!dbContext.dbReady) {\n        dbContext.dbReady = deferredOperation.promise;\n    } else {\n        dbContext.dbReady = dbContext.dbReady.then(function () {\n            return deferredOperation.promise;\n        });\n    }\n}\n\nfunction _advanceReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Dequeue a deferred operation.\n    var deferredOperation = dbContext.deferredOperations.pop();\n\n    // Resolve its promise (which is part of the database readiness\n    // chain of promises).\n    if (deferredOperation) {\n        deferredOperation.resolve();\n    }\n}\n\nfunction _getConnection(dbInfo, upgradeNeeded) {\n    return new Promise$1(function (resolve, reject) {\n\n        if (dbInfo.db) {\n            if (upgradeNeeded) {\n                _deferReadiness(dbInfo);\n                dbInfo.db.close();\n            } else {\n                return resolve(dbInfo.db);\n            }\n        }\n\n        var dbArgs = [dbInfo.name];\n\n        if (upgradeNeeded) {\n            dbArgs.push(dbInfo.version);\n        }\n\n        var openreq = idb.open.apply(idb, dbArgs);\n\n        if (upgradeNeeded) {\n            openreq.onupgradeneeded = function (e) {\n                var db = openreq.result;\n                try {\n                    db.createObjectStore(dbInfo.storeName);\n                    if (e.oldVersion <= 1) {\n                        // Added when support for blob shims was added\n                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n                    }\n                } catch (ex) {\n                    if (ex.name === 'ConstraintError') {\n                        console.warn('The database \"' + dbInfo.name + '\"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage \"' + dbInfo.storeName + '\" already exists.');\n                    } else {\n                        throw ex;\n                    }\n                }\n            };\n        }\n\n        openreq.onerror = function (e) {\n            e.preventDefault();\n            reject(openreq.error);\n        };\n\n        openreq.onsuccess = function () {\n            resolve(openreq.result);\n            _advanceReadiness(dbInfo);\n        };\n    });\n}\n\nfunction _getOriginalConnection(dbInfo) {\n    return _getConnection(dbInfo, false);\n}\n\nfunction _getUpgradedConnection(dbInfo) {\n    return _getConnection(dbInfo, true);\n}\n\nfunction _isUpgradeNeeded(dbInfo, defaultVersion) {\n    if (!dbInfo.db) {\n        return true;\n    }\n\n    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\n    var isDowngrade = dbInfo.version < dbInfo.db.version;\n    var isUpgrade = dbInfo.version > dbInfo.db.version;\n\n    if (isDowngrade) {\n        // If the version is not the default one\n        // then warn for impossible downgrade.\n        if (dbInfo.version !== defaultVersion) {\n            console.warn('The database \"' + dbInfo.name + '\"' + ' can\\'t be downgraded from version ' + dbInfo.db.version + ' to version ' + dbInfo.version + '.');\n        }\n        // Align the versions to prevent errors.\n        dbInfo.version = dbInfo.db.version;\n    }\n\n    if (isUpgrade || isNewStore) {\n        // If the store is new then increment the version (if needed).\n        // This will trigger an \"upgradeneeded\" event which is required\n        // for creating a store.\n        if (isNewStore) {\n            var incVersion = dbInfo.db.version + 1;\n            if (incVersion > dbInfo.version) {\n                dbInfo.version = incVersion;\n            }\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n// encode a blob for indexeddb engines that don't support blobs\nfunction _encodeBlob(blob) {\n    return new Promise$1(function (resolve, reject) {\n        var reader = new FileReader();\n        reader.onerror = reject;\n        reader.onloadend = function (e) {\n            var base64 = btoa(e.target.result || '');\n            resolve({\n                __local_forage_encoded_blob: true,\n                data: base64,\n                type: blob.type\n            });\n        };\n        reader.readAsBinaryString(blob);\n    });\n}\n\n// decode an encoded blob\nfunction _decodeBlob(encodedBlob) {\n    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\n    return createBlob([arrayBuff], { type: encodedBlob.type });\n}\n\n// is this one of our fancy encoded blobs?\nfunction _isEncodedBlob(value) {\n    return value && value.__local_forage_encoded_blob;\n}\n\n// Specialize the default `ready()` function by making it dependent\n// on the current database operations. Thus, the driver will be actually\n// ready when it's been initialized (default) *and* there are no pending\n// operations on the database (initiated by some other instances).\nfunction _fullyReady(callback) {\n    var self = this;\n\n    var promise = self._initReady().then(function () {\n        var dbContext = dbContexts[self._dbInfo.name];\n\n        if (dbContext && dbContext.dbReady) {\n            return dbContext.dbReady;\n        }\n    });\n\n    executeTwoCallbacks(promise, callback, callback);\n    return promise;\n}\n\n// Open the IndexedDB database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    // Initialize a singleton container for all running localForages.\n    if (!dbContexts) {\n        dbContexts = {};\n    }\n\n    // Get the current context of the database;\n    var dbContext = dbContexts[dbInfo.name];\n\n    // ...or create a new context.\n    if (!dbContext) {\n        dbContext = {\n            // Running localForages sharing a database.\n            forages: [],\n            // Shared database.\n            db: null,\n            // Database readiness (promise).\n            dbReady: null,\n            // Deferred operations on the database.\n            deferredOperations: []\n        };\n        // Register the new context in the global container.\n        dbContexts[dbInfo.name] = dbContext;\n    }\n\n    // Register itself as a running localForage in the current context.\n    dbContext.forages.push(self);\n\n    // Replace the default `ready()` function with the specialized one.\n    if (!self._initReady) {\n        self._initReady = self.ready;\n        self.ready = _fullyReady;\n    }\n\n    // Create an array of initialization states of the related localForages.\n    var initPromises = [];\n\n    function ignoreErrors() {\n        // Don't handle errors here,\n        // just makes sure related localForages aren't pending.\n        return Promise$1.resolve();\n    }\n\n    for (var j = 0; j < dbContext.forages.length; j++) {\n        var forage = dbContext.forages[j];\n        if (forage !== self) {\n            // Don't wait for itself...\n            initPromises.push(forage._initReady()[\"catch\"](ignoreErrors));\n        }\n    }\n\n    // Take a snapshot of the related localForages.\n    var forages = dbContext.forages.slice(0);\n\n    // Initialize the connection process only when\n    // all the related localForages aren't pending.\n    return Promise$1.all(initPromises).then(function () {\n        dbInfo.db = dbContext.db;\n        // Get the connection or open a new one without upgrade.\n        return _getOriginalConnection(dbInfo);\n    }).then(function (db) {\n        dbInfo.db = db;\n        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {\n            // Reopen the database for upgrading.\n            return _getUpgradedConnection(dbInfo);\n        }\n        return db;\n    }).then(function (db) {\n        dbInfo.db = dbContext.db = db;\n        self._dbInfo = dbInfo;\n        // Share the final connection amongst related localForages.\n        for (var k = 0; k < forages.length; k++) {\n            var forage = forages[k];\n            if (forage !== self) {\n                // Self is already up-to-date.\n                forage._dbInfo.db = dbInfo.db;\n                forage._dbInfo.version = dbInfo.version;\n            }\n        }\n    });\n}\n\nfunction getItem(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n            var req = store.get(key);\n\n            req.onsuccess = function () {\n                var value = req.result;\n                if (value === undefined) {\n                    value = null;\n                }\n                if (_isEncodedBlob(value)) {\n                    value = _decodeBlob(value);\n                }\n                resolve(value);\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items stored in database.\nfunction iterate(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n\n            var req = store.openCursor();\n            var iterationNumber = 1;\n\n            req.onsuccess = function () {\n                var cursor = req.result;\n\n                if (cursor) {\n                    var value = cursor.value;\n                    if (_isEncodedBlob(value)) {\n                        value = _decodeBlob(value);\n                    }\n                    var result = iterator(value, cursor.key, iterationNumber++);\n\n                    if (result !== void 0) {\n                        resolve(result);\n                    } else {\n                        cursor[\"continue\"]();\n                    }\n                } else {\n                    resolve();\n                }\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n\n    return promise;\n}\n\nfunction setItem(key, value, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        var dbInfo;\n        self.ready().then(function () {\n            dbInfo = self._dbInfo;\n            if (toString.call(value) === '[object Blob]') {\n                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {\n                    if (blobSupport) {\n                        return value;\n                    }\n                    return _encodeBlob(value);\n                });\n            }\n            return value;\n        }).then(function (value) {\n            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');\n            var store = transaction.objectStore(dbInfo.storeName);\n            var req = store.put(value, key);\n\n            // The reason we don't _save_ null is because IE 10 does\n            // not support saving the `null` type in IndexedDB. How\n            // ironic, given the bug below!\n            // See: https://github.com/mozilla/localForage/issues/161\n            if (value === null) {\n                value = undefined;\n            }\n\n            transaction.oncomplete = function () {\n                // Cast to undefined so the value passed to\n                // callback/promise is the same as what one would get out\n                // of `getItem()` later. This leads to some weirdness\n                // (setItem('foo', undefined) will return `null`), but\n                // it's not my fault localStorage is our baseline and that\n                // it's weird.\n                if (value === undefined) {\n                    value = null;\n                }\n\n                resolve(value);\n            };\n            transaction.onabort = transaction.onerror = function () {\n                var err = req.error ? req.error : req.transaction.error;\n                reject(err);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction removeItem(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');\n            var store = transaction.objectStore(dbInfo.storeName);\n\n            // We use a Grunt task to make this safe for IE and some\n            // versions of Android (including those used by Cordova).\n            // Normally IE won't like `.delete()` and will insist on\n            // using `['delete']()`, but we have a build step that\n            // fixes this for us now.\n            var req = store[\"delete\"](key);\n            transaction.oncomplete = function () {\n                resolve();\n            };\n\n            transaction.onerror = function () {\n                reject(req.error);\n            };\n\n            // The request will be also be aborted if we've exceeded our storage\n            // space.\n            transaction.onabort = function () {\n                var err = req.error ? req.error : req.transaction.error;\n                reject(err);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction clear(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');\n            var store = transaction.objectStore(dbInfo.storeName);\n            var req = store.clear();\n\n            transaction.oncomplete = function () {\n                resolve();\n            };\n\n            transaction.onabort = transaction.onerror = function () {\n                var err = req.error ? req.error : req.transaction.error;\n                reject(err);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction length(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n            var req = store.count();\n\n            req.onsuccess = function () {\n                resolve(req.result);\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction key(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        if (n < 0) {\n            resolve(null);\n\n            return;\n        }\n\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n\n            var advanced = false;\n            var req = store.openCursor();\n            req.onsuccess = function () {\n                var cursor = req.result;\n                if (!cursor) {\n                    // this means there weren't enough keys\n                    resolve(null);\n\n                    return;\n                }\n\n                if (n === 0) {\n                    // We have the first key, return it if that's what they\n                    // wanted.\n                    resolve(cursor.key);\n                } else {\n                    if (!advanced) {\n                        // Otherwise, ask the cursor to skip ahead n\n                        // records.\n                        advanced = true;\n                        cursor.advance(n);\n                    } else {\n                        // When we get here, we've got the nth key.\n                        resolve(cursor.key);\n                    }\n                }\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n\n            var req = store.openCursor();\n            var keys = [];\n\n            req.onsuccess = function () {\n                var cursor = req.result;\n\n                if (!cursor) {\n                    resolve(keys);\n                    return;\n                }\n\n                keys.push(cursor.key);\n                cursor[\"continue\"]();\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar asyncStorage = {\n    _driver: 'asyncStorage',\n    _initStorage: _initStorage,\n    iterate: iterate,\n    getItem: getItem,\n    setItem: setItem,\n    removeItem: removeItem,\n    clear: clear,\n    length: length,\n    key: key,\n    keys: keys\n};\n\n// Sadly, the best way to save binary data in WebSQL/localStorage is serializing\n// it to Base64, so this is how we store it to prevent very strange errors with less\n// verbose ways of binary <-> string data storage.\nvar BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nvar BLOB_TYPE_PREFIX = '~~local_forage_type~';\nvar BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\n\nvar SERIALIZED_MARKER = '__lfsc__:';\nvar SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n\n// OMG the serializations!\nvar TYPE_ARRAYBUFFER = 'arbf';\nvar TYPE_BLOB = 'blob';\nvar TYPE_INT8ARRAY = 'si08';\nvar TYPE_UINT8ARRAY = 'ui08';\nvar TYPE_UINT8CLAMPEDARRAY = 'uic8';\nvar TYPE_INT16ARRAY = 'si16';\nvar TYPE_INT32ARRAY = 'si32';\nvar TYPE_UINT16ARRAY = 'ur16';\nvar TYPE_UINT32ARRAY = 'ui32';\nvar TYPE_FLOAT32ARRAY = 'fl32';\nvar TYPE_FLOAT64ARRAY = 'fl64';\nvar TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n\nvar toString$1 = Object.prototype.toString;\n\nfunction stringToBuffer(serializedString) {\n    // Fill the string into a ArrayBuffer.\n    var bufferLength = serializedString.length * 0.75;\n    var len = serializedString.length;\n    var i;\n    var p = 0;\n    var encoded1, encoded2, encoded3, encoded4;\n\n    if (serializedString[serializedString.length - 1] === '=') {\n        bufferLength--;\n        if (serializedString[serializedString.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n\n    var buffer = new ArrayBuffer(bufferLength);\n    var bytes = new Uint8Array(buffer);\n\n    for (i = 0; i < len; i += 4) {\n        encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\n        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\n        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);\n\n        /*jslint bitwise: true */\n        bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n    }\n    return buffer;\n}\n\n// Converts a buffer to a string to store, serialized, in the backend\n// storage library.\nfunction bufferToString(buffer) {\n    // base64-arraybuffer\n    var bytes = new Uint8Array(buffer);\n    var base64String = '';\n    var i;\n\n    for (i = 0; i < bytes.length; i += 3) {\n        /*jslint bitwise: true */\n        base64String += BASE_CHARS[bytes[i] >> 2];\n        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n        base64String += BASE_CHARS[bytes[i + 2] & 63];\n    }\n\n    if (bytes.length % 3 === 2) {\n        base64String = base64String.substring(0, base64String.length - 1) + '=';\n    } else if (bytes.length % 3 === 1) {\n        base64String = base64String.substring(0, base64String.length - 2) + '==';\n    }\n\n    return base64String;\n}\n\n// Serialize a value, afterwards executing a callback (which usually\n// instructs the `setItem()` callback/promise to be executed). This is how\n// we store binary data with localStorage.\nfunction serialize(value, callback) {\n    var valueType = '';\n    if (value) {\n        valueType = toString$1.call(value);\n    }\n\n    // Cannot use `value instanceof ArrayBuffer` or such here, as these\n    // checks fail when running the tests using casper.js...\n    //\n    // TODO: See why those tests fail and use a better solution.\n    if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {\n        // Convert binary arrays to a string and prefix the string with\n        // a special marker.\n        var buffer;\n        var marker = SERIALIZED_MARKER;\n\n        if (value instanceof ArrayBuffer) {\n            buffer = value;\n            marker += TYPE_ARRAYBUFFER;\n        } else {\n            buffer = value.buffer;\n\n            if (valueType === '[object Int8Array]') {\n                marker += TYPE_INT8ARRAY;\n            } else if (valueType === '[object Uint8Array]') {\n                marker += TYPE_UINT8ARRAY;\n            } else if (valueType === '[object Uint8ClampedArray]') {\n                marker += TYPE_UINT8CLAMPEDARRAY;\n            } else if (valueType === '[object Int16Array]') {\n                marker += TYPE_INT16ARRAY;\n            } else if (valueType === '[object Uint16Array]') {\n                marker += TYPE_UINT16ARRAY;\n            } else if (valueType === '[object Int32Array]') {\n                marker += TYPE_INT32ARRAY;\n            } else if (valueType === '[object Uint32Array]') {\n                marker += TYPE_UINT32ARRAY;\n            } else if (valueType === '[object Float32Array]') {\n                marker += TYPE_FLOAT32ARRAY;\n            } else if (valueType === '[object Float64Array]') {\n                marker += TYPE_FLOAT64ARRAY;\n            } else {\n                callback(new Error('Failed to get type for BinaryArray'));\n            }\n        }\n\n        callback(marker + bufferToString(buffer));\n    } else if (valueType === '[object Blob]') {\n        // Conver the blob to a binaryArray and then to a string.\n        var fileReader = new FileReader();\n\n        fileReader.onload = function () {\n            // Backwards-compatible prefix for the blob type.\n            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);\n\n            callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n        };\n\n        fileReader.readAsArrayBuffer(value);\n    } else {\n        try {\n            callback(JSON.stringify(value));\n        } catch (e) {\n            console.error(\"Couldn't convert value into a JSON string: \", value);\n\n            callback(null, e);\n        }\n    }\n}\n\n// Deserialize data we've inserted into a value column/field. We place\n// special markers into our strings to mark them as encoded; this isn't\n// as nice as a meta field, but it's the only sane thing we can do whilst\n// keeping localStorage support intact.\n//\n// Oftentimes this will just deserialize JSON content, but if we have a\n// special marker (SERIALIZED_MARKER, defined above), we will extract\n// some kind of arraybuffer/binary data/typed array out of the string.\nfunction deserialize(value) {\n    // If we haven't marked this string as being specially serialized (i.e.\n    // something other than serialized JSON), we can just return it and be\n    // done with it.\n    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n        return JSON.parse(value);\n    }\n\n    // The following code deals with deserializing some kind of Blob or\n    // TypedArray. First we separate out the type of data we're dealing\n    // with from the data itself.\n    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\n\n    var blobType;\n    // Backwards-compatible blob type serialization strategy.\n    // DBs created with older versions of localForage will simply not have the blob type.\n    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\n        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\n        blobType = matcher[1];\n        serializedString = serializedString.substring(matcher[0].length);\n    }\n    var buffer = stringToBuffer(serializedString);\n\n    // Return the right type based on the code/type set during\n    // serialization.\n    switch (type) {\n        case TYPE_ARRAYBUFFER:\n            return buffer;\n        case TYPE_BLOB:\n            return createBlob([buffer], { type: blobType });\n        case TYPE_INT8ARRAY:\n            return new Int8Array(buffer);\n        case TYPE_UINT8ARRAY:\n            return new Uint8Array(buffer);\n        case TYPE_UINT8CLAMPEDARRAY:\n            return new Uint8ClampedArray(buffer);\n        case TYPE_INT16ARRAY:\n            return new Int16Array(buffer);\n        case TYPE_UINT16ARRAY:\n            return new Uint16Array(buffer);\n        case TYPE_INT32ARRAY:\n            return new Int32Array(buffer);\n        case TYPE_UINT32ARRAY:\n            return new Uint32Array(buffer);\n        case TYPE_FLOAT32ARRAY:\n            return new Float32Array(buffer);\n        case TYPE_FLOAT64ARRAY:\n            return new Float64Array(buffer);\n        default:\n            throw new Error('Unkown type: ' + type);\n    }\n}\n\nvar localforageSerializer = {\n    serialize: serialize,\n    deserialize: deserialize,\n    stringToBuffer: stringToBuffer,\n    bufferToString: bufferToString\n};\n\n/*\n * Includes code from:\n *\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n// Open the WebSQL database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage$1(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];\n        }\n    }\n\n    var dbInfoPromise = new Promise$1(function (resolve, reject) {\n        // Open the database; the openDatabase API will automatically\n        // create it for us if it doesn't exist.\n        try {\n            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);\n        } catch (e) {\n            return reject(e);\n        }\n\n        // Create our key/value table if it doesn't exist.\n        dbInfo.db.transaction(function (t) {\n            t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' (id INTEGER PRIMARY KEY, key unique, value)', [], function () {\n                self._dbInfo = dbInfo;\n                resolve();\n            }, function (t, error) {\n                reject(error);\n            });\n        });\n    });\n\n    dbInfo.serializer = localforageSerializer;\n    return dbInfoPromise;\n}\n\nfunction getItem$1(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).value : null;\n\n                    // Check to see if this is serialized content we need to\n                    // unpack.\n                    if (result) {\n                        result = dbInfo.serializer.deserialize(result);\n                    }\n\n                    resolve(result);\n                }, function (t, error) {\n\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction iterate$1(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var rows = results.rows;\n                    var length = rows.length;\n\n                    for (var i = 0; i < length; i++) {\n                        var item = rows.item(i);\n                        var result = item.value;\n\n                        // Check to see if this is serialized content\n                        // we need to unpack.\n                        if (result) {\n                            result = dbInfo.serializer.deserialize(result);\n                        }\n\n                        result = iterator(result, item.key, i + 1);\n\n                        // void(0) prevents problems with redefinition\n                        // of `undefined`.\n                        if (result !== void 0) {\n                            resolve(result);\n                            return;\n                        }\n                    }\n\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction _setItem(key, value, callback, retriesLeft) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            // The localStorage API doesn't return undefined values in an\n            // \"expected\" way, so undefined is always cast to null in all\n            // drivers. See: https://github.com/mozilla/localForage/pull/42\n            if (value === undefined) {\n                value = null;\n            }\n\n            // Save the original value to pass to the callback.\n            var originalValue = value;\n\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    dbInfo.db.transaction(function (t) {\n                        t.executeSql('INSERT OR REPLACE INTO ' + dbInfo.storeName + ' (key, value) VALUES (?, ?)', [key, value], function () {\n                            resolve(originalValue);\n                        }, function (t, error) {\n                            reject(error);\n                        });\n                    }, function (sqlError) {\n                        // The transaction failed; check\n                        // to see if it's a quota error.\n                        if (sqlError.code === sqlError.QUOTA_ERR) {\n                            // We reject the callback outright for now, but\n                            // it's worth trying to re-run the transaction.\n                            // Even if the user accepts the prompt to use\n                            // more storage on Safari, this error will\n                            // be called.\n                            //\n                            // Try to re-run the transaction.\n                            if (retriesLeft > 0) {\n                                resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));\n                                return;\n                            }\n                            reject(sqlError);\n                        }\n                    });\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction setItem$1(key, value, callback) {\n    return _setItem.apply(this, [key, value, callback, 1]);\n}\n\nfunction removeItem$1(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {\n                    resolve();\n                }, function (t, error) {\n\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Deletes every item in the table.\n// TODO: Find out if this resets the AUTO_INCREMENT number.\nfunction clear$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('DELETE FROM ' + dbInfo.storeName, [], function () {\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Does a simple `COUNT(key)` to get the number of items stored in\n// localForage.\nfunction length$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                // Ahhh, SQL makes this one soooooo easy.\n                t.executeSql('SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var result = results.rows.item(0).c;\n\n                    resolve(result);\n                }, function (t, error) {\n\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Return the key located at key index X; essentially gets the key from a\n// `WHERE id = ?`. This is the most efficient way I can think to implement\n// this rarely-used (in my experience) part of the API, but it can seem\n// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n// the ID of each key will change every time it's updated. Perhaps a stored\n// procedure for the `setItem()` SQL would solve this problem?\n// TODO: Don't change ID on `setItem()`.\nfunction key$1(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).key : null;\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var keys = [];\n\n                    for (var i = 0; i < results.rows.length; i++) {\n                        keys.push(results.rows.item(i).key);\n                    }\n\n                    resolve(keys);\n                }, function (t, error) {\n\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar webSQLStorage = {\n    _driver: 'webSQLStorage',\n    _initStorage: _initStorage$1,\n    iterate: iterate$1,\n    getItem: getItem$1,\n    setItem: setItem$1,\n    removeItem: removeItem$1,\n    clear: clear$1,\n    length: length$1,\n    key: key$1,\n    keys: keys$1\n};\n\n// Config the localStorage backend, using options set in the config.\nfunction _initStorage$2(options) {\n    var self = this;\n    var dbInfo = {};\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    dbInfo.keyPrefix = dbInfo.name + '/';\n\n    if (dbInfo.storeName !== self._defaultConfig.storeName) {\n        dbInfo.keyPrefix += dbInfo.storeName + '/';\n    }\n\n    self._dbInfo = dbInfo;\n    dbInfo.serializer = localforageSerializer;\n\n    return Promise$1.resolve();\n}\n\n// Remove all keys from the datastore, effectively destroying all data in\n// the app's key/value store!\nfunction clear$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var keyPrefix = self._dbInfo.keyPrefix;\n\n        for (var i = localStorage.length - 1; i >= 0; i--) {\n            var key = localStorage.key(i);\n\n            if (key.indexOf(keyPrefix) === 0) {\n                localStorage.removeItem(key);\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Retrieve an item from the store. Unlike the original async_storage\n// library in Gaia, we don't modify return values at all. If a key's value\n// is `undefined`, we pass that value to the callback function.\nfunction getItem$2(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result = localStorage.getItem(dbInfo.keyPrefix + key);\n\n        // If a result was found, parse it from the serialized\n        // string into a JS object. If result isn't truthy, the key\n        // is likely undefined and we'll pass it straight to the\n        // callback.\n        if (result) {\n            result = dbInfo.serializer.deserialize(result);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items in the store.\nfunction iterate$2(iterator, callback) {\n    var self = this;\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var keyPrefix = dbInfo.keyPrefix;\n        var keyPrefixLength = keyPrefix.length;\n        var length = localStorage.length;\n\n        // We use a dedicated iterator instead of the `i` variable below\n        // so other keys we fetch in localStorage aren't counted in\n        // the `iterationNumber` argument passed to the `iterate()`\n        // callback.\n        //\n        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n        var iterationNumber = 1;\n\n        for (var i = 0; i < length; i++) {\n            var key = localStorage.key(i);\n            if (key.indexOf(keyPrefix) !== 0) {\n                continue;\n            }\n            var value = localStorage.getItem(key);\n\n            // If a result was found, parse it from the serialized\n            // string into a JS object. If result isn't truthy, the\n            // key is likely undefined and we'll pass it straight\n            // to the iterator.\n            if (value) {\n                value = dbInfo.serializer.deserialize(value);\n            }\n\n            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);\n\n            if (value !== void 0) {\n                return value;\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Same as localStorage's key() method, except takes a callback.\nfunction key$2(n, callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result;\n        try {\n            result = localStorage.key(n);\n        } catch (error) {\n            result = null;\n        }\n\n        // Remove the prefix from the key, if a key is found.\n        if (result) {\n            result = result.substring(dbInfo.keyPrefix.length);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var length = localStorage.length;\n        var keys = [];\n\n        for (var i = 0; i < length; i++) {\n            if (localStorage.key(i).indexOf(dbInfo.keyPrefix) === 0) {\n                keys.push(localStorage.key(i).substring(dbInfo.keyPrefix.length));\n            }\n        }\n\n        return keys;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Supply the number of keys in the datastore to the callback function.\nfunction length$2(callback) {\n    var self = this;\n    var promise = self.keys().then(function (keys) {\n        return keys.length;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Remove an item from the store, nice and simple.\nfunction removeItem$2(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        localStorage.removeItem(dbInfo.keyPrefix + key);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Set a key's value and run an optional callback once the value is set.\n// Unlike Gaia's implementation, the callback function is passed the value,\n// in case you want to operate on that value only after you're sure it\n// saved, or something like that.\nfunction setItem$2(key, value, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = self.ready().then(function () {\n        // Convert undefined values to null.\n        // https://github.com/mozilla/localForage/pull/42\n        if (value === undefined) {\n            value = null;\n        }\n\n        // Save the original value to pass to the callback.\n        var originalValue = value;\n\n        return new Promise$1(function (resolve, reject) {\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    try {\n                        localStorage.setItem(dbInfo.keyPrefix + key, value);\n                        resolve(originalValue);\n                    } catch (e) {\n                        // localStorage capacity exceeded.\n                        // TODO: Make this a specific error/event.\n                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\n                            reject(e);\n                        }\n                        reject(e);\n                    }\n                }\n            });\n        });\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar localStorageWrapper = {\n    _driver: 'localStorageWrapper',\n    _initStorage: _initStorage$2,\n    // Default API, from Gaia/localStorage.\n    iterate: iterate$2,\n    getItem: getItem$2,\n    setItem: setItem$2,\n    removeItem: removeItem$2,\n    clear: clear$2,\n    length: length$2,\n    key: key$2,\n    keys: keys$2\n};\n\n// Custom drivers are stored here when `defineDriver()` is called.\n// They are shared across all instances of localForage.\nvar CustomDrivers = {};\n\nvar DriverType = {\n    INDEXEDDB: 'asyncStorage',\n    LOCALSTORAGE: 'localStorageWrapper',\n    WEBSQL: 'webSQLStorage'\n};\n\nvar DefaultDriverOrder = [DriverType.INDEXEDDB, DriverType.WEBSQL, DriverType.LOCALSTORAGE];\n\nvar LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'];\n\nvar DefaultConfig = {\n    description: '',\n    driver: DefaultDriverOrder.slice(),\n    name: 'localforage',\n    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\n    // we can use without a prompt.\n    size: 4980736,\n    storeName: 'keyvaluepairs',\n    version: 1.0\n};\n\nvar driverSupport = {};\n// Check to see if IndexedDB is available and if it is the latest\n// implementation; it's our preferred backend library. We use \"_spec_test\"\n// as the name of the database because it's not the one we'll operate on,\n// but it's useful to make sure its using the right spec.\n// See: https://github.com/mozilla/localForage/issues/128\ndriverSupport[DriverType.INDEXEDDB] = isIndexedDBValid();\n\ndriverSupport[DriverType.WEBSQL] = isWebSQLValid();\n\ndriverSupport[DriverType.LOCALSTORAGE] = isLocalStorageValid();\n\nvar isArray = Array.isArray || function (arg) {\n    return Object.prototype.toString.call(arg) === '[object Array]';\n};\n\nfunction callWhenReady(localForageInstance, libraryMethod) {\n    localForageInstance[libraryMethod] = function () {\n        var _args = arguments;\n        return localForageInstance.ready().then(function () {\n            return localForageInstance[libraryMethod].apply(localForageInstance, _args);\n        });\n    };\n}\n\nfunction extend() {\n    for (var i = 1; i < arguments.length; i++) {\n        var arg = arguments[i];\n\n        if (arg) {\n            for (var key in arg) {\n                if (arg.hasOwnProperty(key)) {\n                    if (isArray(arg[key])) {\n                        arguments[0][key] = arg[key].slice();\n                    } else {\n                        arguments[0][key] = arg[key];\n                    }\n                }\n            }\n        }\n    }\n\n    return arguments[0];\n}\n\nfunction isLibraryDriver(driverName) {\n    for (var driver in DriverType) {\n        if (DriverType.hasOwnProperty(driver) && DriverType[driver] === driverName) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nvar LocalForage = function () {\n    function LocalForage(options) {\n        _classCallCheck(this, LocalForage);\n\n        this.INDEXEDDB = DriverType.INDEXEDDB;\n        this.LOCALSTORAGE = DriverType.LOCALSTORAGE;\n        this.WEBSQL = DriverType.WEBSQL;\n\n        this._defaultConfig = extend({}, DefaultConfig);\n        this._config = extend({}, this._defaultConfig, options);\n        this._driverSet = null;\n        this._initDriver = null;\n        this._ready = false;\n        this._dbInfo = null;\n\n        this._wrapLibraryMethodsWithReady();\n        this.setDriver(this._config.driver)[\"catch\"](function () {});\n    }\n\n    // Set any config values for localForage; can be called anytime before\n    // the first API call (e.g. `getItem`, `setItem`).\n    // We loop through options so we don't overwrite existing config\n    // values.\n\n\n    LocalForage.prototype.config = function config(options) {\n        // If the options argument is an object, we use it to set values.\n        // Otherwise, we return either a specified config value or all\n        // config values.\n        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n            // If localforage is ready and fully initialized, we can't set\n            // any new configuration values. Instead, we return an error.\n            if (this._ready) {\n                return new Error(\"Can't call config() after localforage \" + 'has been used.');\n            }\n\n            for (var i in options) {\n                if (i === 'storeName') {\n                    options[i] = options[i].replace(/\\W/g, '_');\n                }\n\n                if (i === 'version' && typeof options[i] !== 'number') {\n                    return new Error('Database version must be a number.');\n                }\n\n                this._config[i] = options[i];\n            }\n\n            // after all config options are set and\n            // the driver option is used, try setting it\n            if ('driver' in options && options.driver) {\n                return this.setDriver(this._config.driver);\n            }\n\n            return true;\n        } else if (typeof options === 'string') {\n            return this._config[options];\n        } else {\n            return this._config;\n        }\n    };\n\n    // Used to define a custom driver, shared across all instances of\n    // localForage.\n\n\n    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {\n        var promise = new Promise$1(function (resolve, reject) {\n            try {\n                var driverName = driverObject._driver;\n                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');\n                var namingError = new Error('Custom driver name already in use: ' + driverObject._driver);\n\n                // A driver name should be defined and not overlap with the\n                // library-defined, default drivers.\n                if (!driverObject._driver) {\n                    reject(complianceError);\n                    return;\n                }\n                if (isLibraryDriver(driverObject._driver)) {\n                    reject(namingError);\n                    return;\n                }\n\n                var customDriverMethods = LibraryMethods.concat('_initStorage');\n                for (var i = 0; i < customDriverMethods.length; i++) {\n                    var customDriverMethod = customDriverMethods[i];\n                    if (!customDriverMethod || !driverObject[customDriverMethod] || typeof driverObject[customDriverMethod] !== 'function') {\n                        reject(complianceError);\n                        return;\n                    }\n                }\n\n                var supportPromise = Promise$1.resolve(true);\n                if ('_support' in driverObject) {\n                    if (driverObject._support && typeof driverObject._support === 'function') {\n                        supportPromise = driverObject._support();\n                    } else {\n                        supportPromise = Promise$1.resolve(!!driverObject._support);\n                    }\n                }\n\n                supportPromise.then(function (supportResult) {\n                    driverSupport[driverName] = supportResult;\n                    CustomDrivers[driverName] = driverObject;\n                    resolve();\n                }, reject);\n            } catch (e) {\n                reject(e);\n            }\n        });\n\n        executeTwoCallbacks(promise, callback, errorCallback);\n        return promise;\n    };\n\n    LocalForage.prototype.driver = function driver() {\n        return this._driver || null;\n    };\n\n    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {\n        var self = this;\n        var getDriverPromise = Promise$1.resolve().then(function () {\n            if (isLibraryDriver(driverName)) {\n                switch (driverName) {\n                    case self.INDEXEDDB:\n                        return asyncStorage;\n                    case self.LOCALSTORAGE:\n                        return localStorageWrapper;\n                    case self.WEBSQL:\n                        return webSQLStorage;\n                }\n            } else if (CustomDrivers[driverName]) {\n                return CustomDrivers[driverName];\n            } else {\n                throw new Error('Driver not found.');\n            }\n        });\n        executeTwoCallbacks(getDriverPromise, callback, errorCallback);\n        return getDriverPromise;\n    };\n\n    LocalForage.prototype.getSerializer = function getSerializer(callback) {\n        var serializerPromise = Promise$1.resolve(localforageSerializer);\n        executeTwoCallbacks(serializerPromise, callback);\n        return serializerPromise;\n    };\n\n    LocalForage.prototype.ready = function ready(callback) {\n        var self = this;\n\n        var promise = self._driverSet.then(function () {\n            if (self._ready === null) {\n                self._ready = self._initDriver();\n            }\n\n            return self._ready;\n        });\n\n        executeTwoCallbacks(promise, callback, callback);\n        return promise;\n    };\n\n    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {\n        var self = this;\n\n        if (!isArray(drivers)) {\n            drivers = [drivers];\n        }\n\n        var supportedDrivers = this._getSupportedDrivers(drivers);\n\n        function setDriverToConfig() {\n            self._config.driver = self.driver();\n        }\n\n        function extendSelfWithDriver(driver) {\n            self._extend(driver);\n            setDriverToConfig();\n\n            self._ready = self._initStorage(self._config);\n            return self._ready;\n        }\n\n        function initDriver(supportedDrivers) {\n            return function () {\n                var currentDriverIndex = 0;\n\n                function driverPromiseLoop() {\n                    while (currentDriverIndex < supportedDrivers.length) {\n                        var driverName = supportedDrivers[currentDriverIndex];\n                        currentDriverIndex++;\n\n                        self._dbInfo = null;\n                        self._ready = null;\n\n                        return self.getDriver(driverName).then(extendSelfWithDriver)[\"catch\"](driverPromiseLoop);\n                    }\n\n                    setDriverToConfig();\n                    var error = new Error('No available storage method found.');\n                    self._driverSet = Promise$1.reject(error);\n                    return self._driverSet;\n                }\n\n                return driverPromiseLoop();\n            };\n        }\n\n        // There might be a driver initialization in progress\n        // so wait for it to finish in order to avoid a possible\n        // race condition to set _dbInfo\n        var oldDriverSetDone = this._driverSet !== null ? this._driverSet[\"catch\"](function () {\n            return Promise$1.resolve();\n        }) : Promise$1.resolve();\n\n        this._driverSet = oldDriverSetDone.then(function () {\n            var driverName = supportedDrivers[0];\n            self._dbInfo = null;\n            self._ready = null;\n\n            return self.getDriver(driverName).then(function (driver) {\n                self._driver = driver._driver;\n                setDriverToConfig();\n                self._wrapLibraryMethodsWithReady();\n                self._initDriver = initDriver(supportedDrivers);\n            });\n        })[\"catch\"](function () {\n            setDriverToConfig();\n            var error = new Error('No available storage method found.');\n            self._driverSet = Promise$1.reject(error);\n            return self._driverSet;\n        });\n\n        executeTwoCallbacks(this._driverSet, callback, errorCallback);\n        return this._driverSet;\n    };\n\n    LocalForage.prototype.supports = function supports(driverName) {\n        return !!driverSupport[driverName];\n    };\n\n    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {\n        extend(this, libraryMethodsAndProperties);\n    };\n\n    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {\n        var supportedDrivers = [];\n        for (var i = 0, len = drivers.length; i < len; i++) {\n            var driverName = drivers[i];\n            if (this.supports(driverName)) {\n                supportedDrivers.push(driverName);\n            }\n        }\n        return supportedDrivers;\n    };\n\n    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {\n        // Add a stub for each driver API method that delays the call to the\n        // corresponding driver method until localForage is ready. These stubs\n        // will be replaced by the driver methods as soon as the driver is\n        // loaded, so there is no performance impact.\n        for (var i = 0; i < LibraryMethods.length; i++) {\n            callWhenReady(this, LibraryMethods[i]);\n        }\n    };\n\n    LocalForage.prototype.createInstance = function createInstance(options) {\n        return new LocalForage(options);\n    };\n\n    return LocalForage;\n}();\n\n// The actual localForage object that we expose as a module or via a\n// global. It's extended by pulling in one of our other libraries.\n\n\nvar localforage_js = new LocalForage();\n\nmodule.exports = localforage_js;\n\n},{\"3\":3}]},{},[4])(4)\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(31)))\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * pushToggle.js\n * \n * Deals with the toggle used to Toggle Subscription from On and Off\n * It also Disables the toggle in case it's not supported with appropriate error messages\n * \n * Displaying the status text within this card, also makes sure that this \n * card is calibrated enough with the application state, which we want to make sure\n * is always the case.\n * \n * This card is going to rely on running from the beginning and thus makes \n * no assumption of having subscription state, being stored anywhere\n */\n\nvar card = document.querySelector('.subscription-toggle');\nvar subscriptionStatus = card.querySelector('.subscription-status');\nvar subscriptionSwitch = card.querySelector('input');\nvar subscriptionLabel = subscriptionSwitch.parentNode;\n\nvar NOT_SUPPORTED_TEXT = 'Relevant APIs are not supported';\nvar ENABLED_ON_TEXT = 'On';\nvar ENABLED_OFF_TEXT = 'Off';\n\nfunction changeSwitch(on) {\n  on = !!on;\n  updateStatus(on ? ENABLED_ON_TEXT : ENABLED_OFF_TEXT);\n  subscriptionSwitch.checked = on;\n  on ? subscriptionLabel.classList.add('is-checked') : subscriptionLabel.classList.remove('is-checked');\n}\n\n/**\n * Enable or disable the Material Design Switch based on the\n * enable parameter passed\n */\nfunction enableSwitch(enable) {\n  // Explicit conversion to type Boolean\n  var enabledBool = !!enable;\n  subscriptionSwitch.disabled = !enabledBool;\n\n  if (!enabledBool) {\n    subscriptionLabel.classList.remove('is-checked');\n    subscriptionLabel.classList.add('is-disabled');\n    updateStatus(NOT_SUPPORTED_TEXT);\n    subscriptionSwitch.checked = false;\n  } else {\n    updateStatus(subscriptionSwitch.checked ? ENABLED_ON_TEXT : ENABLED_OFF_TEXT);\n    subscriptionLabel.classList.remove('is-disabled');\n  }\n}\n\n/**\n * In order to wait for the operation to complete\n * before anyother operation is started\n * `waitToggle` disables the toggle so it can't be used\n */\nfunction waitToggle() {\n  subscriptionSwitch.disabled = true;\n  subscriptionLabel.classList.add('is-disabled');\n}\n\n/**\n * Updates the Statu of the text in the card\n */\nfunction updateStatus(status) {\n  subscriptionStatus.textContent = status;\n}\n\n/**\n * Updates the Switch Status and enables or disabled according\n * to the parameters\n */\nfunction updateSwitch(pushSubscription) {\n  enableSwitch(true);\n  changeSwitch(!!pushSubscription);\n}\n\nexports.updateSwitch = updateSwitch;\nexports.enableSwitch = enableSwitch;\nexports.subscriptionSwitch = subscriptionSwitch;\nexports.waitToggle = waitToggle;\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Module for handling the Card with PushSubscription information\n */\nvar subscriptionInfoCard = document.querySelector('.subscription-info');\n\nvar serverInfo = subscriptionInfoCard.querySelector('.code.server-subscription');\nvar subscriptionInfo = subscriptionInfoCard.querySelector('.code.info');\nvar serverId = subscriptionInfoCard.querySelector('.code.server-id');\n\n/**\n * Displays the Push Info\n */\nfunction displayPushInfo(pushSubscription) {\n  if (!pushSubscription) {\n    subscriptionInfoCard.style.display = 'none';\n    return;\n  }\n\n  if (pushSubscription) {\n    subscriptionInfoCard.style.display = '';\n    subscriptionInfo.innerHTML = JSON.stringify(pushSubscription, null, 4);\n  }\n}\n\nfunction displayServerId(id) {\n  serverId.innerHTML = id;\n}\n\nfunction displayServerResponse(response) {\n  serverId.innerHTML = response._id;\n  serverInfo.innerHTML = JSON.stringify(response, null, 4);\n}\n\nfunction displayServerError() {\n  serverId.innerHTML = 'Error occured';\n  serverInfo.innerHTML = 'Error occured';\n}\n\nexports.displayPushInfo = displayPushInfo;\nexports.displayServerId = displayServerId;\nexports.displayServerResponse = displayServerResponse;\nexports.displayServerError = displayServerError;\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _axios = __webpack_require__(8);\n\nvar _axios2 = _interopRequireDefault(_axios);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar SERVER_BASE_URL = 'https://server-xvcfivqgya.now.sh/'; /**\n                                                            * serverSubscriptoin.js\n                                                            * Library to perform CRUD operations on the subscriptions on server\n                                                            */\n\nvar subscriberURL = SERVER_BASE_URL + 'subscriber';\n/**\n * Creates the Subscription on the Server \n * `subscription` is passed as body\n */\nfunction createSubscription(subscription) {\n  return _axios2.default.post(subscriberURL, {\n    subscription: JSON.parse(JSON.stringify(subscription))\n  });\n}\n\nfunction deleteSubscription(subscriptionId) {\n  return _axios2.default.delete(subscriberURL, {\n    data: {\n      id: subscriptionId\n    },\n    responseType: 'json'\n  });\n}\n\nfunction getSubscription(subscriptionId) {\n  return _axios2.default.get(subscriberURL, { params: { id: subscriptionId } });\n}\n\nexports.default = { createSubscription: createSubscription, getSubscription: getSubscription, deleteSubscription: deleteSubscription };\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"service-worker.js\";\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// app.bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 27);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c32d1e7bf0ecf85b6ab6","'use strict';\n\nvar bind = require('./helpers/bind');\nvar isBuffer = require('is-buffer');\n\n/*global toString:true*/\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object' && !isArray(obj)) {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (typeof result[key] === 'object' && typeof val === 'object') {\n      result[key] = merge(result[key], val);\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/utils.js\n// module id = 0\n// module chunks = 0 1","'use strict';\n\nvar utils = require('./utils');\nvar normalizeHeaderName = require('./helpers/normalizeHeaderName');\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = require('./adapters/xhr');\n  } else if (typeof process !== 'undefined') {\n    // For node use HTTP adapter\n    adapter = require('./adapters/http');\n  }\n  return adapter;\n}\n\nvar defaults = {\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Content-Type');\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data)) {\n      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');\n      return JSON.stringify(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    /*eslint no-param-reassign:0*/\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (e) { /* Ignore */ }\n    }\n    return data;\n  }],\n\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/defaults.js\n// module id = 1\n// module chunks = 0 1","'use strict';\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/helpers/bind.js\n// module id = 2\n// module chunks = 0 1","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/process/browser.js\n// module id = 3\n// module chunks = 0 1","'use strict';\n\nvar utils = require('./../utils');\nvar settle = require('./../core/settle');\nvar buildURL = require('./../helpers/buildURL');\nvar parseHeaders = require('./../helpers/parseHeaders');\nvar isURLSameOrigin = require('./../helpers/isURLSameOrigin');\nvar createError = require('../core/createError');\nvar btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || require('./../helpers/btoa');\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n    var loadEvent = 'onreadystatechange';\n    var xDomain = false;\n\n    // For IE 8/9 CORS support\n    // Only supports POST and GET calls and doesn't returns the response headers.\n    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.\n    if (process.env.NODE_ENV !== 'test' &&\n        typeof window !== 'undefined' &&\n        window.XDomainRequest && !('withCredentials' in request) &&\n        !isURLSameOrigin(config.url)) {\n      request = new window.XDomainRequest();\n      loadEvent = 'onload';\n      xDomain = true;\n      request.onprogress = function handleProgress() {};\n      request.ontimeout = function handleTimeout() {};\n    }\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    // Listen for ready state\n    request[loadEvent] = function handleLoad() {\n      if (!request || (request.readyState !== 4 && !xDomain)) {\n        return;\n      }\n\n      // The request errored out and we didn't get a response, this will be\n      // handled by onerror instead\n      // With one exception: request that using file: protocol, most browsers\n      // will return status as 0 even though it's a successful request\n      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n        return;\n      }\n\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201)\n        status: request.status === 1223 ? 204 : request.status,\n        statusText: request.status === 1223 ? 'No Content' : request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      var cookies = require('./../helpers/cookies');\n\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?\n          cookies.read(config.xsrfCookieName) :\n          undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (config.withCredentials) {\n      request.withCredentials = true;\n    }\n\n    // Add responseType to request if needed\n    if (config.responseType) {\n      try {\n        request.responseType = config.responseType;\n      } catch (e) {\n        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.\n        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.\n        if (config.responseType !== 'json') {\n          throw e;\n        }\n      }\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (requestData === undefined) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/adapters/xhr.js\n// module id = 4\n// module chunks = 0 1","'use strict';\n\nvar enhanceError = require('./enhanceError');\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/core/createError.js\n// module id = 5\n// module chunks = 0 1","'use strict';\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/cancel/isCancel.js\n// module id = 6\n// module chunks = 0 1","'use strict';\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/cancel/Cancel.js\n// module id = 7\n// module chunks = 0 1","module.exports = require('./lib/axios');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/index.js\n// module id = 8\n// module chunks = 0 1","'use strict';\n\nvar utils = require('./utils');\nvar bind = require('./helpers/bind');\nvar Axios = require('./core/Axios');\nvar defaults = require('./defaults');\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(utils.merge(defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = require('./cancel/Cancel');\naxios.CancelToken = require('./cancel/CancelToken');\naxios.isCancel = require('./cancel/isCancel');\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = require('./helpers/spread');\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/axios.js\n// module id = 9\n// module chunks = 0 1","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/is-buffer/index.js\n// module id = 10\n// module chunks = 0 1","'use strict';\n\nvar defaults = require('./../defaults');\nvar utils = require('./../utils');\nvar InterceptorManager = require('./InterceptorManager');\nvar dispatchRequest = require('./dispatchRequest');\nvar isAbsoluteURL = require('./../helpers/isAbsoluteURL');\nvar combineURLs = require('./../helpers/combineURLs');\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = utils.merge({\n      url: arguments[0]\n    }, arguments[1]);\n  }\n\n  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);\n  config.method = config.method.toLowerCase();\n\n  // Support baseURL config\n  if (config.baseURL && !isAbsoluteURL(config.url)) {\n    config.url = combineURLs(config.baseURL, config.url);\n  }\n\n  // Hook up interceptors middleware\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/core/Axios.js\n// module id = 11\n// module chunks = 0 1","'use strict';\n\nvar utils = require('../utils');\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/helpers/normalizeHeaderName.js\n// module id = 12\n// module chunks = 0 1","'use strict';\n\nvar createError = require('./createError');\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  // Note: status is not exposed by XDomainRequest\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/core/settle.js\n// module id = 13\n// module chunks = 0 1","'use strict';\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n  error.request = request;\n  error.response = response;\n  return error;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/core/enhanceError.js\n// module id = 14\n// module chunks = 0 1","'use strict';\n\nvar utils = require('./../utils');\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%40/gi, '@').\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      }\n\n      if (!utils.isArray(val)) {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/helpers/buildURL.js\n// module id = 15\n// module chunks = 0 1","'use strict';\n\nvar utils = require('./../utils');\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n    }\n  });\n\n  return parsed;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/helpers/parseHeaders.js\n// module id = 16\n// module chunks = 0 1","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n  (function standardBrowserEnv() {\n    var msie = /(msie|trident)/i.test(navigator.userAgent);\n    var urlParsingNode = document.createElement('a');\n    var originURL;\n\n    /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n    function resolveURL(url) {\n      var href = url;\n\n      if (msie) {\n        // IE needs attribute set twice to normalize properties\n        urlParsingNode.setAttribute('href', href);\n        href = urlParsingNode.href;\n      }\n\n      urlParsingNode.setAttribute('href', href);\n\n      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n      return {\n        href: urlParsingNode.href,\n        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n        host: urlParsingNode.host,\n        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n        hostname: urlParsingNode.hostname,\n        port: urlParsingNode.port,\n        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n                  urlParsingNode.pathname :\n                  '/' + urlParsingNode.pathname\n      };\n    }\n\n    originURL = resolveURL(window.location.href);\n\n    /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n    return function isURLSameOrigin(requestURL) {\n      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n      return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n    };\n  })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n  (function nonStandardBrowserEnv() {\n    return function isURLSameOrigin() {\n      return true;\n    };\n  })()\n);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/helpers/isURLSameOrigin.js\n// module id = 17\n// module chunks = 0 1","'use strict';\n\n// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js\n\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfunction E() {\n  this.message = 'String contains an invalid character';\n}\nE.prototype = new Error;\nE.prototype.code = 5;\nE.prototype.name = 'InvalidCharacterError';\n\nfunction btoa(input) {\n  var str = String(input);\n  var output = '';\n  for (\n    // initialize result and counter\n    var block, charCode, idx = 0, map = chars;\n    // if the next str index does not exist:\n    //   change the mapping table to \"=\"\n    //   check if d has no fractional digits\n    str.charAt(idx | 0) || (map = '=', idx % 1);\n    // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n    output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n  ) {\n    charCode = str.charCodeAt(idx += 3 / 4);\n    if (charCode > 0xFF) {\n      throw new E();\n    }\n    block = block << 8 | charCode;\n  }\n  return output;\n}\n\nmodule.exports = btoa;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/helpers/btoa.js\n// module id = 18\n// module chunks = 0 1","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n  (function standardBrowserEnv() {\n    return {\n      write: function write(name, value, expires, path, domain, secure) {\n        var cookie = [];\n        cookie.push(name + '=' + encodeURIComponent(value));\n\n        if (utils.isNumber(expires)) {\n          cookie.push('expires=' + new Date(expires).toGMTString());\n        }\n\n        if (utils.isString(path)) {\n          cookie.push('path=' + path);\n        }\n\n        if (utils.isString(domain)) {\n          cookie.push('domain=' + domain);\n        }\n\n        if (secure === true) {\n          cookie.push('secure');\n        }\n\n        document.cookie = cookie.join('; ');\n      },\n\n      read: function read(name) {\n        var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n        return (match ? decodeURIComponent(match[3]) : null);\n      },\n\n      remove: function remove(name) {\n        this.write(name, '', Date.now() - 86400000);\n      }\n    };\n  })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n  (function nonStandardBrowserEnv() {\n    return {\n      write: function write() {},\n      read: function read() { return null; },\n      remove: function remove() {}\n    };\n  })()\n);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/helpers/cookies.js\n// module id = 19\n// module chunks = 0 1","'use strict';\n\nvar utils = require('./../utils');\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/core/InterceptorManager.js\n// module id = 20\n// module chunks = 0 1","'use strict';\n\nvar utils = require('./../utils');\nvar transformData = require('./transformData');\nvar isCancel = require('../cancel/isCancel');\nvar defaults = require('../defaults');\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData(\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers || {}\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData(\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData(\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/core/dispatchRequest.js\n// module id = 21\n// module chunks = 0 1","'use strict';\n\nvar utils = require('./../utils');\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn(data, headers);\n  });\n\n  return data;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/core/transformData.js\n// module id = 22\n// module chunks = 0 1","'use strict';\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/helpers/isAbsoluteURL.js\n// module id = 23\n// module chunks = 0 1","'use strict';\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/helpers/combineURLs.js\n// module id = 24\n// module chunks = 0 1","'use strict';\n\nvar Cancel = require('./Cancel');\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/cancel/CancelToken.js\n// module id = 25\n// module chunks = 0 1","'use strict';\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/helpers/spread.js\n// module id = 26\n// module chunks = 0 1","// Imports all the Custom Styles as well as Material Design Lite\n// Using a Webpack Familiar Syntax\nimport './appStyles.css';\n\nimport axios from 'axios';\nimport updateSupportCard from './supportCard';\nimport localForage from 'localforage';\nimport { updateSwitch, subscriptionSwitch, waitToggle } from './pushToggle';\nimport {  displayServerResponse, displayPushInfo, displayServerError } from './pushInfo';\nimport serverSubscription from './serverSubscription';\n/**\n * Webpack Bundling Specific logic related to service worker.\n * Please IGNORE THIS!\n */\nimport swUrl from 'file-loader?name=[name].[ext]!./service-worker.js'\n\n// Global Variables Regarding the Support of the PushManager Related APIs\nconst swSupport = navigator && 'serviceWorker' in navigator;\nconst pushSupport = window && 'PushManager' in window;\nconst isSupported = navigator  && swSupport && pushSupport;\nconst SAFE_APPLICATION_SERVER_KEY = 'BFyMIWmgIvBFAbC-0CrU6tqfiqr4A4rcVqWtnHncpPuKeFfGrnHCjOfvdumLoN6Lh8fdOecWdy2_yKF7dDPldAM'\n\n/*\n * Global Variables to hold the state of\n * - `pushManager` - Manager for Push Notifications\n * - `pushSubscription` - Current Subscription stored in global state\n * \n * `pushSubscription` is helpful to coordinate in actions such as\n * delete subscription so we don't have to do an additional getSubscription\n * call for the sake of this demo.\n */\nlet pushManager = null;\nlet pushSubscription = null;\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  updateSupportCard(swSupport, pushSupport);\n  if (isSupported) {\n    // Registering the server here if supported\n    navigator.serviceWorker.register('./service-worker.js').catch(function (error) {\n      console.error('Failed to register the latest ServiceWorker');\n      throw error;\n    });\n\n    initSubscription();\n    subscriptionSwitch.addEventListener('change', function (changeEvent) {\n      const checked = changeEvent.target.checked;\n      waitToggle();\n      if (checked) {\n        subscribe();\n      } else {\n        unsubscribe();\n      }\n    });\n  }\n});\n\n/**\n * Helper Function to Convert a URL Base 64 String to a Uint8Array type in JavaScript\n * @param {String} base64String\n * @return {Uint8Array} Uint8Array type\n */\nfunction urlBase64ToUint8Array(base64String) {\n  const padding = '='.repeat((4 - base64String.length % 4) % 4);\n  const base64 = (base64String + padding)\n    .replace(/\\-/g, '+')\n    .replace(/_/g, '/');\n\n  const rawData = window.atob(base64);\n  const outputArray = new Uint8Array(rawData.length);\n\n  for (let i = 0; i < rawData.length; ++i) {\n    outputArray[i] = rawData.charCodeAt(i);\n  }\n  return outputArray;\n}\n\n/**\n * Initial Subscription related logic\n */\nfunction initSubscription() {\n  navigator.serviceWorker.ready.then(\n    function (registration) {\n      pushManager = registration.pushManager;\n      pushManager.getSubscription()\n        .then(function (subscription) {\n          updateSubscriptionUI(subscription);\n        })\n        .catch(function (error) {\n          console.error(error);\n          updateServerSubscription(null);\n        });\n    }\n  );\n}\n\n/**\n * Subscribes to the Push Manager and updates the\n * UI if successful\n */\nfunction subscribe () {\n  pushManager.subscribe({\n    userVisibleOnly: true,\n    applicationServerKey: urlBase64ToUint8Array(SAFE_APPLICATION_SERVER_KEY)\n  })\n  .then(function (subscription) {\n    console.log('Subscribed!')\n    pushSubscription = subscription;\n    updateSubscriptionUI(subscription);\n  })\n  .catch(function (error) {\n    console.log('Error occured while subscribing');\n    console.error(error);\n    updateSubscriptionUI(pushSubscription);\n  });\n}\n\n\n/**\n * Unsubscribes the PushSubscription\n * and updates the subscription UI \n */\nfunction unsubscribe() {\n  if (!pushSubscription) {\n    console.log('`pushSubscription` is null');\n    updateSubscriptionUI(null);\n    return;\n  }\n\n  return (\n    pushSubscription.unsubscribe()\n      .then(function (removed) {\n        pushSubscription = null;\n        updateSubscriptionUI(pushSubscription);\n      })\n      .catch(function (error) {\n        console.error(error);\n        updateSubscriptionUI(pushSubscription);\n      })\n  )\n}\n\n// Updates the subscription on update\nfunction updateSubscriptionUI(subscription) {\n  updateSwitch(subscription);\n  displayPushInfo(subscription);\n  updateServerSubscription(subscription);\n}\n\n/**\n * Updates the Subscription on the Server side\n * if new\n */\nfunction updateServerSubscription(subscription) {\n  return localForage.getItem('subscription')\n    .then(function (savedSubscription) {\n      savedSubscription = JSON.parse(savedSubscription);\n      const { shouldUpdate, shouldDelete } = evalSubscriptionConditions(\n        savedSubscription,\n        subscription\n      );\n\n     if (!shouldUpdate && !shouldDelete) {\n        console.log('Both Subscriptions are same, do nothing');\n        return savedSubscription;\n      }\n\n      if (shouldUpdate) {\n        /**\n         * Further actions are dependent on successful \n         * createion of subscription on database\n         * \n         * This promise is going to be included within the promise chain.\n         */\n        return serverSubscription.createSubscription(subscription)\n          .then(response => {\n            const data = response.data;\n            console.log('Subscription Created ', data);\n            return localForage.setItem('subscription', JSON.stringify(data)).then(() => data);\n          });\n      } else if (shouldDelete) {\n        return localForage.setItem('subscription', null)\n          .then(() => {\n            serverSubscription.deleteSubscription(savedSubscription._id)\n            return null;\n          });\n      }\n    })\n    .then(function (newSubscription) {\n      // UI can be updated in this then function\n      // as related operations to the subscriptions have been performed on them\n      if (subscription) {\n        console.log('Displaying information for the subscription');\n        displayPushInfo(subscription);\n        displayServerResponse(newSubscription);\n      }\n    })\n    .catch(function (error) {\n      console.error('Failure in updating the status');\n      console.error(error);\n      displayServerError(error);\n    });\n}\n\n/**\n * Evaluate related conditions to the subscription\n */\nfunction evalSubscriptionConditions(savedSubscription, subscription) {\n  const endpointCondition = (\n    savedSubscription && subscription &&\n    savedSubscription.endpoint !== subscription.endpoint\n  );\n\n  return {\n    shouldUpdate: !savedSubscription && subscription || endpointCondition,\n    shouldDelete: !subscription && savedSubscription,\n  };\n}\n\n/**\n * Based on conditions when the subscription should \n * be deleted\n * \n * @param {PushSubscription} savedSubscription Subscription stored in the storage\n */\nfunction shouldDeleteSubscription(savedSubscription, subscription) {\n  return (\n    !subscription ||\n    savedSubscription.endpoint\n  )\n}\n\n/**\n * Removes the Subscription from the Client\n */\nfunction removeSubscription(subscription) {\n  return localForage.getItem('subscription')\n    .then(function (subscription) {\n      if (subscription) {\n        console.log('Existing Subscription is going to be removed');\n        return Promise.all([\n          serverSubscription.deleteSubscription(subscription._id),\n          localForage.setItem('subscriptionId', null)\n        ]);\n      }\n    });\n}\n\n// Updates the Loading UI in order \n// to represent the loading state of the operations\n// Disables the toggle for the duration of the task being performed\n// in order to prevent from any other task to be executed\nfunction showLoadingUI () {\n  waitToggle();\n}\n\n\n// WEBPACK FOOTER //\n// ./src/app/index.js","/**\n * Asking important questions that needs answer\n * - What is the design pattern we can use, that let's us make reuse of the elements \n *   in the applications so we can keep our memory footprint low and save time that's spent\n *   in looking up for dom elements each time?\n */\n\nexport const notSupportedCard = document.querySelector('.not-supported');\nconst supportStatus = notSupportedCard.querySelector('.support-status');\nconst swSupport = supportStatus.querySelector('.service-worker .value');\nconst pushSupport = supportStatus.querySelector('.push-api .value');\n\nexport default function updateSupportCard(serviceWorker, pushManager) {\n  if (serviceWorker && pushManager) {\n    notSupportedCard.style.display = 'none';\n  } else {\n    swSupport.textContent = serviceWorker ? 'Supported' : 'Not Supported';\n    pushSupport.textContent = pushManager ? 'Supported' : 'Not Supported';\n    notSupportedCard.style.display = 'block';\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/supportCard.js","/*!\n    localForage -- Offline Storage, Improved\n    Version 1.5.0\n    https://localforage.github.io/localForage\n    (c) 2013-2017 Mozilla, Apache License 2.0\n*/\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.localforage = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw (f.code=\"MODULE_NOT_FOUND\", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],2:[function(_dereq_,module,exports){\n'use strict';\nvar immediate = _dereq_(1);\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && typeof obj === 'object' && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nexports.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nexports.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nexports.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nexports.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n},{\"1\":1}],3:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nif (typeof global.Promise !== 'function') {\n  global.Promise = _dereq_(2);\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"2\":2}],4:[function(_dereq_,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction getIDB() {\n    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */\n    try {\n        if (typeof indexedDB !== 'undefined') {\n            return indexedDB;\n        }\n        if (typeof webkitIndexedDB !== 'undefined') {\n            return webkitIndexedDB;\n        }\n        if (typeof mozIndexedDB !== 'undefined') {\n            return mozIndexedDB;\n        }\n        if (typeof OIndexedDB !== 'undefined') {\n            return OIndexedDB;\n        }\n        if (typeof msIndexedDB !== 'undefined') {\n            return msIndexedDB;\n        }\n    } catch (e) {}\n}\n\nvar idb = getIDB();\n\nfunction isIndexedDBValid() {\n    try {\n        // Initialize IndexedDB; fall back to vendor-prefixed versions\n        // if needed.\n        if (!idb) {\n            return false;\n        }\n        // We mimic PouchDB here;\n        //\n        // We test for openDatabase because IE Mobile identifies itself\n        // as Safari. Oh the lulz...\n        var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);\n\n        var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;\n\n        // Safari <10.1 does not meet our requirements for IDB support (#5572)\n        // since Safari 10.1 shipped with fetch, we can use that to detect it\n        return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&\n        // some outdated implementations of IDB that appear on Samsung\n        // and HTC Android devices <4.4 are missing IDBKeyRange\n        typeof IDBKeyRange !== 'undefined';\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction isWebSQLValid() {\n    return typeof openDatabase === 'function';\n}\n\nfunction isLocalStorageValid() {\n    try {\n        return typeof localStorage !== 'undefined' && 'setItem' in localStorage && localStorage.setItem;\n    } catch (e) {\n        return false;\n    }\n}\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\nfunction createBlob(parts, properties) {\n    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n    parts = parts || [];\n    properties = properties || {};\n    try {\n        return new Blob(parts, properties);\n    } catch (e) {\n        if (e.name !== 'TypeError') {\n            throw e;\n        }\n        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;\n        var builder = new Builder();\n        for (var i = 0; i < parts.length; i += 1) {\n            builder.append(parts[i]);\n        }\n        return builder.getBlob(properties.type);\n    }\n}\n\n// This is CommonJS because lie is an external dependency, so Rollup\n// can just ignore it.\nif (typeof Promise === 'undefined') {\n    // In the \"nopromises\" build this will just throw if you don't have\n    // a global promise object, but it would throw anyway later.\n    _dereq_(3);\n}\nvar Promise$1 = Promise;\n\nfunction executeCallback(promise, callback) {\n    if (callback) {\n        promise.then(function (result) {\n            callback(null, result);\n        }, function (error) {\n            callback(error);\n        });\n    }\n}\n\nfunction executeTwoCallbacks(promise, callback, errorCallback) {\n    if (typeof callback === 'function') {\n        promise.then(callback);\n    }\n\n    if (typeof errorCallback === 'function') {\n        promise[\"catch\"](errorCallback);\n    }\n}\n\n// Some code originally from async_storage.js in\n// [Gaia](https://github.com/mozilla-b2g/gaia).\n\nvar DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';\nvar supportsBlobs;\nvar dbContexts;\nvar toString = Object.prototype.toString;\n\n// Transform a binary string to an array buffer, because otherwise\n// weird stuff happens when you try to work with the binary string directly.\n// It is known.\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction _binStringToArrayBuffer(bin) {\n    var length = bin.length;\n    var buf = new ArrayBuffer(length);\n    var arr = new Uint8Array(buf);\n    for (var i = 0; i < length; i++) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return buf;\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\n// Code borrowed from PouchDB. See:\n// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js\n//\nfunction _checkBlobSupportWithoutCaching(idb) {\n    return new Promise$1(function (resolve) {\n        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, 'readwrite');\n        var blob = createBlob(['']);\n        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n\n        txn.onabort = function (e) {\n            // If the transaction aborts now its due to not being able to\n            // write to the database, likely due to the disk being full\n            e.preventDefault();\n            e.stopPropagation();\n            resolve(false);\n        };\n\n        txn.oncomplete = function () {\n            var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n            var matchedEdge = navigator.userAgent.match(/Edge\\//);\n            // MS Edge pretends to be Chrome 42:\n            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);\n        };\n    })[\"catch\"](function () {\n        return false; // error, so assume unsupported\n    });\n}\n\nfunction _checkBlobSupport(idb) {\n    if (typeof supportsBlobs === 'boolean') {\n        return Promise$1.resolve(supportsBlobs);\n    }\n    return _checkBlobSupportWithoutCaching(idb).then(function (value) {\n        supportsBlobs = value;\n        return supportsBlobs;\n    });\n}\n\nfunction _deferReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Create a deferred object representing the current database operation.\n    var deferredOperation = {};\n\n    deferredOperation.promise = new Promise$1(function (resolve) {\n        deferredOperation.resolve = resolve;\n    });\n\n    // Enqueue the deferred operation.\n    dbContext.deferredOperations.push(deferredOperation);\n\n    // Chain its promise to the database readiness.\n    if (!dbContext.dbReady) {\n        dbContext.dbReady = deferredOperation.promise;\n    } else {\n        dbContext.dbReady = dbContext.dbReady.then(function () {\n            return deferredOperation.promise;\n        });\n    }\n}\n\nfunction _advanceReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Dequeue a deferred operation.\n    var deferredOperation = dbContext.deferredOperations.pop();\n\n    // Resolve its promise (which is part of the database readiness\n    // chain of promises).\n    if (deferredOperation) {\n        deferredOperation.resolve();\n    }\n}\n\nfunction _getConnection(dbInfo, upgradeNeeded) {\n    return new Promise$1(function (resolve, reject) {\n\n        if (dbInfo.db) {\n            if (upgradeNeeded) {\n                _deferReadiness(dbInfo);\n                dbInfo.db.close();\n            } else {\n                return resolve(dbInfo.db);\n            }\n        }\n\n        var dbArgs = [dbInfo.name];\n\n        if (upgradeNeeded) {\n            dbArgs.push(dbInfo.version);\n        }\n\n        var openreq = idb.open.apply(idb, dbArgs);\n\n        if (upgradeNeeded) {\n            openreq.onupgradeneeded = function (e) {\n                var db = openreq.result;\n                try {\n                    db.createObjectStore(dbInfo.storeName);\n                    if (e.oldVersion <= 1) {\n                        // Added when support for blob shims was added\n                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n                    }\n                } catch (ex) {\n                    if (ex.name === 'ConstraintError') {\n                        console.warn('The database \"' + dbInfo.name + '\"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage \"' + dbInfo.storeName + '\" already exists.');\n                    } else {\n                        throw ex;\n                    }\n                }\n            };\n        }\n\n        openreq.onerror = function (e) {\n            e.preventDefault();\n            reject(openreq.error);\n        };\n\n        openreq.onsuccess = function () {\n            resolve(openreq.result);\n            _advanceReadiness(dbInfo);\n        };\n    });\n}\n\nfunction _getOriginalConnection(dbInfo) {\n    return _getConnection(dbInfo, false);\n}\n\nfunction _getUpgradedConnection(dbInfo) {\n    return _getConnection(dbInfo, true);\n}\n\nfunction _isUpgradeNeeded(dbInfo, defaultVersion) {\n    if (!dbInfo.db) {\n        return true;\n    }\n\n    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\n    var isDowngrade = dbInfo.version < dbInfo.db.version;\n    var isUpgrade = dbInfo.version > dbInfo.db.version;\n\n    if (isDowngrade) {\n        // If the version is not the default one\n        // then warn for impossible downgrade.\n        if (dbInfo.version !== defaultVersion) {\n            console.warn('The database \"' + dbInfo.name + '\"' + ' can\\'t be downgraded from version ' + dbInfo.db.version + ' to version ' + dbInfo.version + '.');\n        }\n        // Align the versions to prevent errors.\n        dbInfo.version = dbInfo.db.version;\n    }\n\n    if (isUpgrade || isNewStore) {\n        // If the store is new then increment the version (if needed).\n        // This will trigger an \"upgradeneeded\" event which is required\n        // for creating a store.\n        if (isNewStore) {\n            var incVersion = dbInfo.db.version + 1;\n            if (incVersion > dbInfo.version) {\n                dbInfo.version = incVersion;\n            }\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n// encode a blob for indexeddb engines that don't support blobs\nfunction _encodeBlob(blob) {\n    return new Promise$1(function (resolve, reject) {\n        var reader = new FileReader();\n        reader.onerror = reject;\n        reader.onloadend = function (e) {\n            var base64 = btoa(e.target.result || '');\n            resolve({\n                __local_forage_encoded_blob: true,\n                data: base64,\n                type: blob.type\n            });\n        };\n        reader.readAsBinaryString(blob);\n    });\n}\n\n// decode an encoded blob\nfunction _decodeBlob(encodedBlob) {\n    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\n    return createBlob([arrayBuff], { type: encodedBlob.type });\n}\n\n// is this one of our fancy encoded blobs?\nfunction _isEncodedBlob(value) {\n    return value && value.__local_forage_encoded_blob;\n}\n\n// Specialize the default `ready()` function by making it dependent\n// on the current database operations. Thus, the driver will be actually\n// ready when it's been initialized (default) *and* there are no pending\n// operations on the database (initiated by some other instances).\nfunction _fullyReady(callback) {\n    var self = this;\n\n    var promise = self._initReady().then(function () {\n        var dbContext = dbContexts[self._dbInfo.name];\n\n        if (dbContext && dbContext.dbReady) {\n            return dbContext.dbReady;\n        }\n    });\n\n    executeTwoCallbacks(promise, callback, callback);\n    return promise;\n}\n\n// Open the IndexedDB database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    // Initialize a singleton container for all running localForages.\n    if (!dbContexts) {\n        dbContexts = {};\n    }\n\n    // Get the current context of the database;\n    var dbContext = dbContexts[dbInfo.name];\n\n    // ...or create a new context.\n    if (!dbContext) {\n        dbContext = {\n            // Running localForages sharing a database.\n            forages: [],\n            // Shared database.\n            db: null,\n            // Database readiness (promise).\n            dbReady: null,\n            // Deferred operations on the database.\n            deferredOperations: []\n        };\n        // Register the new context in the global container.\n        dbContexts[dbInfo.name] = dbContext;\n    }\n\n    // Register itself as a running localForage in the current context.\n    dbContext.forages.push(self);\n\n    // Replace the default `ready()` function with the specialized one.\n    if (!self._initReady) {\n        self._initReady = self.ready;\n        self.ready = _fullyReady;\n    }\n\n    // Create an array of initialization states of the related localForages.\n    var initPromises = [];\n\n    function ignoreErrors() {\n        // Don't handle errors here,\n        // just makes sure related localForages aren't pending.\n        return Promise$1.resolve();\n    }\n\n    for (var j = 0; j < dbContext.forages.length; j++) {\n        var forage = dbContext.forages[j];\n        if (forage !== self) {\n            // Don't wait for itself...\n            initPromises.push(forage._initReady()[\"catch\"](ignoreErrors));\n        }\n    }\n\n    // Take a snapshot of the related localForages.\n    var forages = dbContext.forages.slice(0);\n\n    // Initialize the connection process only when\n    // all the related localForages aren't pending.\n    return Promise$1.all(initPromises).then(function () {\n        dbInfo.db = dbContext.db;\n        // Get the connection or open a new one without upgrade.\n        return _getOriginalConnection(dbInfo);\n    }).then(function (db) {\n        dbInfo.db = db;\n        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {\n            // Reopen the database for upgrading.\n            return _getUpgradedConnection(dbInfo);\n        }\n        return db;\n    }).then(function (db) {\n        dbInfo.db = dbContext.db = db;\n        self._dbInfo = dbInfo;\n        // Share the final connection amongst related localForages.\n        for (var k = 0; k < forages.length; k++) {\n            var forage = forages[k];\n            if (forage !== self) {\n                // Self is already up-to-date.\n                forage._dbInfo.db = dbInfo.db;\n                forage._dbInfo.version = dbInfo.version;\n            }\n        }\n    });\n}\n\nfunction getItem(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n            var req = store.get(key);\n\n            req.onsuccess = function () {\n                var value = req.result;\n                if (value === undefined) {\n                    value = null;\n                }\n                if (_isEncodedBlob(value)) {\n                    value = _decodeBlob(value);\n                }\n                resolve(value);\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items stored in database.\nfunction iterate(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n\n            var req = store.openCursor();\n            var iterationNumber = 1;\n\n            req.onsuccess = function () {\n                var cursor = req.result;\n\n                if (cursor) {\n                    var value = cursor.value;\n                    if (_isEncodedBlob(value)) {\n                        value = _decodeBlob(value);\n                    }\n                    var result = iterator(value, cursor.key, iterationNumber++);\n\n                    if (result !== void 0) {\n                        resolve(result);\n                    } else {\n                        cursor[\"continue\"]();\n                    }\n                } else {\n                    resolve();\n                }\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n\n    return promise;\n}\n\nfunction setItem(key, value, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        var dbInfo;\n        self.ready().then(function () {\n            dbInfo = self._dbInfo;\n            if (toString.call(value) === '[object Blob]') {\n                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {\n                    if (blobSupport) {\n                        return value;\n                    }\n                    return _encodeBlob(value);\n                });\n            }\n            return value;\n        }).then(function (value) {\n            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');\n            var store = transaction.objectStore(dbInfo.storeName);\n            var req = store.put(value, key);\n\n            // The reason we don't _save_ null is because IE 10 does\n            // not support saving the `null` type in IndexedDB. How\n            // ironic, given the bug below!\n            // See: https://github.com/mozilla/localForage/issues/161\n            if (value === null) {\n                value = undefined;\n            }\n\n            transaction.oncomplete = function () {\n                // Cast to undefined so the value passed to\n                // callback/promise is the same as what one would get out\n                // of `getItem()` later. This leads to some weirdness\n                // (setItem('foo', undefined) will return `null`), but\n                // it's not my fault localStorage is our baseline and that\n                // it's weird.\n                if (value === undefined) {\n                    value = null;\n                }\n\n                resolve(value);\n            };\n            transaction.onabort = transaction.onerror = function () {\n                var err = req.error ? req.error : req.transaction.error;\n                reject(err);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction removeItem(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');\n            var store = transaction.objectStore(dbInfo.storeName);\n\n            // We use a Grunt task to make this safe for IE and some\n            // versions of Android (including those used by Cordova).\n            // Normally IE won't like `.delete()` and will insist on\n            // using `['delete']()`, but we have a build step that\n            // fixes this for us now.\n            var req = store[\"delete\"](key);\n            transaction.oncomplete = function () {\n                resolve();\n            };\n\n            transaction.onerror = function () {\n                reject(req.error);\n            };\n\n            // The request will be also be aborted if we've exceeded our storage\n            // space.\n            transaction.onabort = function () {\n                var err = req.error ? req.error : req.transaction.error;\n                reject(err);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction clear(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');\n            var store = transaction.objectStore(dbInfo.storeName);\n            var req = store.clear();\n\n            transaction.oncomplete = function () {\n                resolve();\n            };\n\n            transaction.onabort = transaction.onerror = function () {\n                var err = req.error ? req.error : req.transaction.error;\n                reject(err);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction length(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n            var req = store.count();\n\n            req.onsuccess = function () {\n                resolve(req.result);\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction key(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        if (n < 0) {\n            resolve(null);\n\n            return;\n        }\n\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n\n            var advanced = false;\n            var req = store.openCursor();\n            req.onsuccess = function () {\n                var cursor = req.result;\n                if (!cursor) {\n                    // this means there weren't enough keys\n                    resolve(null);\n\n                    return;\n                }\n\n                if (n === 0) {\n                    // We have the first key, return it if that's what they\n                    // wanted.\n                    resolve(cursor.key);\n                } else {\n                    if (!advanced) {\n                        // Otherwise, ask the cursor to skip ahead n\n                        // records.\n                        advanced = true;\n                        cursor.advance(n);\n                    } else {\n                        // When we get here, we've got the nth key.\n                        resolve(cursor.key);\n                    }\n                }\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n\n            var req = store.openCursor();\n            var keys = [];\n\n            req.onsuccess = function () {\n                var cursor = req.result;\n\n                if (!cursor) {\n                    resolve(keys);\n                    return;\n                }\n\n                keys.push(cursor.key);\n                cursor[\"continue\"]();\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar asyncStorage = {\n    _driver: 'asyncStorage',\n    _initStorage: _initStorage,\n    iterate: iterate,\n    getItem: getItem,\n    setItem: setItem,\n    removeItem: removeItem,\n    clear: clear,\n    length: length,\n    key: key,\n    keys: keys\n};\n\n// Sadly, the best way to save binary data in WebSQL/localStorage is serializing\n// it to Base64, so this is how we store it to prevent very strange errors with less\n// verbose ways of binary <-> string data storage.\nvar BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nvar BLOB_TYPE_PREFIX = '~~local_forage_type~';\nvar BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\n\nvar SERIALIZED_MARKER = '__lfsc__:';\nvar SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n\n// OMG the serializations!\nvar TYPE_ARRAYBUFFER = 'arbf';\nvar TYPE_BLOB = 'blob';\nvar TYPE_INT8ARRAY = 'si08';\nvar TYPE_UINT8ARRAY = 'ui08';\nvar TYPE_UINT8CLAMPEDARRAY = 'uic8';\nvar TYPE_INT16ARRAY = 'si16';\nvar TYPE_INT32ARRAY = 'si32';\nvar TYPE_UINT16ARRAY = 'ur16';\nvar TYPE_UINT32ARRAY = 'ui32';\nvar TYPE_FLOAT32ARRAY = 'fl32';\nvar TYPE_FLOAT64ARRAY = 'fl64';\nvar TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n\nvar toString$1 = Object.prototype.toString;\n\nfunction stringToBuffer(serializedString) {\n    // Fill the string into a ArrayBuffer.\n    var bufferLength = serializedString.length * 0.75;\n    var len = serializedString.length;\n    var i;\n    var p = 0;\n    var encoded1, encoded2, encoded3, encoded4;\n\n    if (serializedString[serializedString.length - 1] === '=') {\n        bufferLength--;\n        if (serializedString[serializedString.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n\n    var buffer = new ArrayBuffer(bufferLength);\n    var bytes = new Uint8Array(buffer);\n\n    for (i = 0; i < len; i += 4) {\n        encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\n        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\n        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);\n\n        /*jslint bitwise: true */\n        bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n    }\n    return buffer;\n}\n\n// Converts a buffer to a string to store, serialized, in the backend\n// storage library.\nfunction bufferToString(buffer) {\n    // base64-arraybuffer\n    var bytes = new Uint8Array(buffer);\n    var base64String = '';\n    var i;\n\n    for (i = 0; i < bytes.length; i += 3) {\n        /*jslint bitwise: true */\n        base64String += BASE_CHARS[bytes[i] >> 2];\n        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n        base64String += BASE_CHARS[bytes[i + 2] & 63];\n    }\n\n    if (bytes.length % 3 === 2) {\n        base64String = base64String.substring(0, base64String.length - 1) + '=';\n    } else if (bytes.length % 3 === 1) {\n        base64String = base64String.substring(0, base64String.length - 2) + '==';\n    }\n\n    return base64String;\n}\n\n// Serialize a value, afterwards executing a callback (which usually\n// instructs the `setItem()` callback/promise to be executed). This is how\n// we store binary data with localStorage.\nfunction serialize(value, callback) {\n    var valueType = '';\n    if (value) {\n        valueType = toString$1.call(value);\n    }\n\n    // Cannot use `value instanceof ArrayBuffer` or such here, as these\n    // checks fail when running the tests using casper.js...\n    //\n    // TODO: See why those tests fail and use a better solution.\n    if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {\n        // Convert binary arrays to a string and prefix the string with\n        // a special marker.\n        var buffer;\n        var marker = SERIALIZED_MARKER;\n\n        if (value instanceof ArrayBuffer) {\n            buffer = value;\n            marker += TYPE_ARRAYBUFFER;\n        } else {\n            buffer = value.buffer;\n\n            if (valueType === '[object Int8Array]') {\n                marker += TYPE_INT8ARRAY;\n            } else if (valueType === '[object Uint8Array]') {\n                marker += TYPE_UINT8ARRAY;\n            } else if (valueType === '[object Uint8ClampedArray]') {\n                marker += TYPE_UINT8CLAMPEDARRAY;\n            } else if (valueType === '[object Int16Array]') {\n                marker += TYPE_INT16ARRAY;\n            } else if (valueType === '[object Uint16Array]') {\n                marker += TYPE_UINT16ARRAY;\n            } else if (valueType === '[object Int32Array]') {\n                marker += TYPE_INT32ARRAY;\n            } else if (valueType === '[object Uint32Array]') {\n                marker += TYPE_UINT32ARRAY;\n            } else if (valueType === '[object Float32Array]') {\n                marker += TYPE_FLOAT32ARRAY;\n            } else if (valueType === '[object Float64Array]') {\n                marker += TYPE_FLOAT64ARRAY;\n            } else {\n                callback(new Error('Failed to get type for BinaryArray'));\n            }\n        }\n\n        callback(marker + bufferToString(buffer));\n    } else if (valueType === '[object Blob]') {\n        // Conver the blob to a binaryArray and then to a string.\n        var fileReader = new FileReader();\n\n        fileReader.onload = function () {\n            // Backwards-compatible prefix for the blob type.\n            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);\n\n            callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n        };\n\n        fileReader.readAsArrayBuffer(value);\n    } else {\n        try {\n            callback(JSON.stringify(value));\n        } catch (e) {\n            console.error(\"Couldn't convert value into a JSON string: \", value);\n\n            callback(null, e);\n        }\n    }\n}\n\n// Deserialize data we've inserted into a value column/field. We place\n// special markers into our strings to mark them as encoded; this isn't\n// as nice as a meta field, but it's the only sane thing we can do whilst\n// keeping localStorage support intact.\n//\n// Oftentimes this will just deserialize JSON content, but if we have a\n// special marker (SERIALIZED_MARKER, defined above), we will extract\n// some kind of arraybuffer/binary data/typed array out of the string.\nfunction deserialize(value) {\n    // If we haven't marked this string as being specially serialized (i.e.\n    // something other than serialized JSON), we can just return it and be\n    // done with it.\n    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n        return JSON.parse(value);\n    }\n\n    // The following code deals with deserializing some kind of Blob or\n    // TypedArray. First we separate out the type of data we're dealing\n    // with from the data itself.\n    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\n\n    var blobType;\n    // Backwards-compatible blob type serialization strategy.\n    // DBs created with older versions of localForage will simply not have the blob type.\n    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\n        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\n        blobType = matcher[1];\n        serializedString = serializedString.substring(matcher[0].length);\n    }\n    var buffer = stringToBuffer(serializedString);\n\n    // Return the right type based on the code/type set during\n    // serialization.\n    switch (type) {\n        case TYPE_ARRAYBUFFER:\n            return buffer;\n        case TYPE_BLOB:\n            return createBlob([buffer], { type: blobType });\n        case TYPE_INT8ARRAY:\n            return new Int8Array(buffer);\n        case TYPE_UINT8ARRAY:\n            return new Uint8Array(buffer);\n        case TYPE_UINT8CLAMPEDARRAY:\n            return new Uint8ClampedArray(buffer);\n        case TYPE_INT16ARRAY:\n            return new Int16Array(buffer);\n        case TYPE_UINT16ARRAY:\n            return new Uint16Array(buffer);\n        case TYPE_INT32ARRAY:\n            return new Int32Array(buffer);\n        case TYPE_UINT32ARRAY:\n            return new Uint32Array(buffer);\n        case TYPE_FLOAT32ARRAY:\n            return new Float32Array(buffer);\n        case TYPE_FLOAT64ARRAY:\n            return new Float64Array(buffer);\n        default:\n            throw new Error('Unkown type: ' + type);\n    }\n}\n\nvar localforageSerializer = {\n    serialize: serialize,\n    deserialize: deserialize,\n    stringToBuffer: stringToBuffer,\n    bufferToString: bufferToString\n};\n\n/*\n * Includes code from:\n *\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n// Open the WebSQL database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage$1(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];\n        }\n    }\n\n    var dbInfoPromise = new Promise$1(function (resolve, reject) {\n        // Open the database; the openDatabase API will automatically\n        // create it for us if it doesn't exist.\n        try {\n            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);\n        } catch (e) {\n            return reject(e);\n        }\n\n        // Create our key/value table if it doesn't exist.\n        dbInfo.db.transaction(function (t) {\n            t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' (id INTEGER PRIMARY KEY, key unique, value)', [], function () {\n                self._dbInfo = dbInfo;\n                resolve();\n            }, function (t, error) {\n                reject(error);\n            });\n        });\n    });\n\n    dbInfo.serializer = localforageSerializer;\n    return dbInfoPromise;\n}\n\nfunction getItem$1(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).value : null;\n\n                    // Check to see if this is serialized content we need to\n                    // unpack.\n                    if (result) {\n                        result = dbInfo.serializer.deserialize(result);\n                    }\n\n                    resolve(result);\n                }, function (t, error) {\n\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction iterate$1(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var rows = results.rows;\n                    var length = rows.length;\n\n                    for (var i = 0; i < length; i++) {\n                        var item = rows.item(i);\n                        var result = item.value;\n\n                        // Check to see if this is serialized content\n                        // we need to unpack.\n                        if (result) {\n                            result = dbInfo.serializer.deserialize(result);\n                        }\n\n                        result = iterator(result, item.key, i + 1);\n\n                        // void(0) prevents problems with redefinition\n                        // of `undefined`.\n                        if (result !== void 0) {\n                            resolve(result);\n                            return;\n                        }\n                    }\n\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction _setItem(key, value, callback, retriesLeft) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            // The localStorage API doesn't return undefined values in an\n            // \"expected\" way, so undefined is always cast to null in all\n            // drivers. See: https://github.com/mozilla/localForage/pull/42\n            if (value === undefined) {\n                value = null;\n            }\n\n            // Save the original value to pass to the callback.\n            var originalValue = value;\n\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    dbInfo.db.transaction(function (t) {\n                        t.executeSql('INSERT OR REPLACE INTO ' + dbInfo.storeName + ' (key, value) VALUES (?, ?)', [key, value], function () {\n                            resolve(originalValue);\n                        }, function (t, error) {\n                            reject(error);\n                        });\n                    }, function (sqlError) {\n                        // The transaction failed; check\n                        // to see if it's a quota error.\n                        if (sqlError.code === sqlError.QUOTA_ERR) {\n                            // We reject the callback outright for now, but\n                            // it's worth trying to re-run the transaction.\n                            // Even if the user accepts the prompt to use\n                            // more storage on Safari, this error will\n                            // be called.\n                            //\n                            // Try to re-run the transaction.\n                            if (retriesLeft > 0) {\n                                resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));\n                                return;\n                            }\n                            reject(sqlError);\n                        }\n                    });\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction setItem$1(key, value, callback) {\n    return _setItem.apply(this, [key, value, callback, 1]);\n}\n\nfunction removeItem$1(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {\n                    resolve();\n                }, function (t, error) {\n\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Deletes every item in the table.\n// TODO: Find out if this resets the AUTO_INCREMENT number.\nfunction clear$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('DELETE FROM ' + dbInfo.storeName, [], function () {\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Does a simple `COUNT(key)` to get the number of items stored in\n// localForage.\nfunction length$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                // Ahhh, SQL makes this one soooooo easy.\n                t.executeSql('SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var result = results.rows.item(0).c;\n\n                    resolve(result);\n                }, function (t, error) {\n\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Return the key located at key index X; essentially gets the key from a\n// `WHERE id = ?`. This is the most efficient way I can think to implement\n// this rarely-used (in my experience) part of the API, but it can seem\n// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n// the ID of each key will change every time it's updated. Perhaps a stored\n// procedure for the `setItem()` SQL would solve this problem?\n// TODO: Don't change ID on `setItem()`.\nfunction key$1(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).key : null;\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var keys = [];\n\n                    for (var i = 0; i < results.rows.length; i++) {\n                        keys.push(results.rows.item(i).key);\n                    }\n\n                    resolve(keys);\n                }, function (t, error) {\n\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar webSQLStorage = {\n    _driver: 'webSQLStorage',\n    _initStorage: _initStorage$1,\n    iterate: iterate$1,\n    getItem: getItem$1,\n    setItem: setItem$1,\n    removeItem: removeItem$1,\n    clear: clear$1,\n    length: length$1,\n    key: key$1,\n    keys: keys$1\n};\n\n// Config the localStorage backend, using options set in the config.\nfunction _initStorage$2(options) {\n    var self = this;\n    var dbInfo = {};\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    dbInfo.keyPrefix = dbInfo.name + '/';\n\n    if (dbInfo.storeName !== self._defaultConfig.storeName) {\n        dbInfo.keyPrefix += dbInfo.storeName + '/';\n    }\n\n    self._dbInfo = dbInfo;\n    dbInfo.serializer = localforageSerializer;\n\n    return Promise$1.resolve();\n}\n\n// Remove all keys from the datastore, effectively destroying all data in\n// the app's key/value store!\nfunction clear$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var keyPrefix = self._dbInfo.keyPrefix;\n\n        for (var i = localStorage.length - 1; i >= 0; i--) {\n            var key = localStorage.key(i);\n\n            if (key.indexOf(keyPrefix) === 0) {\n                localStorage.removeItem(key);\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Retrieve an item from the store. Unlike the original async_storage\n// library in Gaia, we don't modify return values at all. If a key's value\n// is `undefined`, we pass that value to the callback function.\nfunction getItem$2(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result = localStorage.getItem(dbInfo.keyPrefix + key);\n\n        // If a result was found, parse it from the serialized\n        // string into a JS object. If result isn't truthy, the key\n        // is likely undefined and we'll pass it straight to the\n        // callback.\n        if (result) {\n            result = dbInfo.serializer.deserialize(result);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items in the store.\nfunction iterate$2(iterator, callback) {\n    var self = this;\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var keyPrefix = dbInfo.keyPrefix;\n        var keyPrefixLength = keyPrefix.length;\n        var length = localStorage.length;\n\n        // We use a dedicated iterator instead of the `i` variable below\n        // so other keys we fetch in localStorage aren't counted in\n        // the `iterationNumber` argument passed to the `iterate()`\n        // callback.\n        //\n        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n        var iterationNumber = 1;\n\n        for (var i = 0; i < length; i++) {\n            var key = localStorage.key(i);\n            if (key.indexOf(keyPrefix) !== 0) {\n                continue;\n            }\n            var value = localStorage.getItem(key);\n\n            // If a result was found, parse it from the serialized\n            // string into a JS object. If result isn't truthy, the\n            // key is likely undefined and we'll pass it straight\n            // to the iterator.\n            if (value) {\n                value = dbInfo.serializer.deserialize(value);\n            }\n\n            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);\n\n            if (value !== void 0) {\n                return value;\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Same as localStorage's key() method, except takes a callback.\nfunction key$2(n, callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result;\n        try {\n            result = localStorage.key(n);\n        } catch (error) {\n            result = null;\n        }\n\n        // Remove the prefix from the key, if a key is found.\n        if (result) {\n            result = result.substring(dbInfo.keyPrefix.length);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var length = localStorage.length;\n        var keys = [];\n\n        for (var i = 0; i < length; i++) {\n            if (localStorage.key(i).indexOf(dbInfo.keyPrefix) === 0) {\n                keys.push(localStorage.key(i).substring(dbInfo.keyPrefix.length));\n            }\n        }\n\n        return keys;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Supply the number of keys in the datastore to the callback function.\nfunction length$2(callback) {\n    var self = this;\n    var promise = self.keys().then(function (keys) {\n        return keys.length;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Remove an item from the store, nice and simple.\nfunction removeItem$2(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        localStorage.removeItem(dbInfo.keyPrefix + key);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Set a key's value and run an optional callback once the value is set.\n// Unlike Gaia's implementation, the callback function is passed the value,\n// in case you want to operate on that value only after you're sure it\n// saved, or something like that.\nfunction setItem$2(key, value, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = self.ready().then(function () {\n        // Convert undefined values to null.\n        // https://github.com/mozilla/localForage/pull/42\n        if (value === undefined) {\n            value = null;\n        }\n\n        // Save the original value to pass to the callback.\n        var originalValue = value;\n\n        return new Promise$1(function (resolve, reject) {\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    try {\n                        localStorage.setItem(dbInfo.keyPrefix + key, value);\n                        resolve(originalValue);\n                    } catch (e) {\n                        // localStorage capacity exceeded.\n                        // TODO: Make this a specific error/event.\n                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\n                            reject(e);\n                        }\n                        reject(e);\n                    }\n                }\n            });\n        });\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar localStorageWrapper = {\n    _driver: 'localStorageWrapper',\n    _initStorage: _initStorage$2,\n    // Default API, from Gaia/localStorage.\n    iterate: iterate$2,\n    getItem: getItem$2,\n    setItem: setItem$2,\n    removeItem: removeItem$2,\n    clear: clear$2,\n    length: length$2,\n    key: key$2,\n    keys: keys$2\n};\n\n// Custom drivers are stored here when `defineDriver()` is called.\n// They are shared across all instances of localForage.\nvar CustomDrivers = {};\n\nvar DriverType = {\n    INDEXEDDB: 'asyncStorage',\n    LOCALSTORAGE: 'localStorageWrapper',\n    WEBSQL: 'webSQLStorage'\n};\n\nvar DefaultDriverOrder = [DriverType.INDEXEDDB, DriverType.WEBSQL, DriverType.LOCALSTORAGE];\n\nvar LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'];\n\nvar DefaultConfig = {\n    description: '',\n    driver: DefaultDriverOrder.slice(),\n    name: 'localforage',\n    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\n    // we can use without a prompt.\n    size: 4980736,\n    storeName: 'keyvaluepairs',\n    version: 1.0\n};\n\nvar driverSupport = {};\n// Check to see if IndexedDB is available and if it is the latest\n// implementation; it's our preferred backend library. We use \"_spec_test\"\n// as the name of the database because it's not the one we'll operate on,\n// but it's useful to make sure its using the right spec.\n// See: https://github.com/mozilla/localForage/issues/128\ndriverSupport[DriverType.INDEXEDDB] = isIndexedDBValid();\n\ndriverSupport[DriverType.WEBSQL] = isWebSQLValid();\n\ndriverSupport[DriverType.LOCALSTORAGE] = isLocalStorageValid();\n\nvar isArray = Array.isArray || function (arg) {\n    return Object.prototype.toString.call(arg) === '[object Array]';\n};\n\nfunction callWhenReady(localForageInstance, libraryMethod) {\n    localForageInstance[libraryMethod] = function () {\n        var _args = arguments;\n        return localForageInstance.ready().then(function () {\n            return localForageInstance[libraryMethod].apply(localForageInstance, _args);\n        });\n    };\n}\n\nfunction extend() {\n    for (var i = 1; i < arguments.length; i++) {\n        var arg = arguments[i];\n\n        if (arg) {\n            for (var key in arg) {\n                if (arg.hasOwnProperty(key)) {\n                    if (isArray(arg[key])) {\n                        arguments[0][key] = arg[key].slice();\n                    } else {\n                        arguments[0][key] = arg[key];\n                    }\n                }\n            }\n        }\n    }\n\n    return arguments[0];\n}\n\nfunction isLibraryDriver(driverName) {\n    for (var driver in DriverType) {\n        if (DriverType.hasOwnProperty(driver) && DriverType[driver] === driverName) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nvar LocalForage = function () {\n    function LocalForage(options) {\n        _classCallCheck(this, LocalForage);\n\n        this.INDEXEDDB = DriverType.INDEXEDDB;\n        this.LOCALSTORAGE = DriverType.LOCALSTORAGE;\n        this.WEBSQL = DriverType.WEBSQL;\n\n        this._defaultConfig = extend({}, DefaultConfig);\n        this._config = extend({}, this._defaultConfig, options);\n        this._driverSet = null;\n        this._initDriver = null;\n        this._ready = false;\n        this._dbInfo = null;\n\n        this._wrapLibraryMethodsWithReady();\n        this.setDriver(this._config.driver)[\"catch\"](function () {});\n    }\n\n    // Set any config values for localForage; can be called anytime before\n    // the first API call (e.g. `getItem`, `setItem`).\n    // We loop through options so we don't overwrite existing config\n    // values.\n\n\n    LocalForage.prototype.config = function config(options) {\n        // If the options argument is an object, we use it to set values.\n        // Otherwise, we return either a specified config value or all\n        // config values.\n        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n            // If localforage is ready and fully initialized, we can't set\n            // any new configuration values. Instead, we return an error.\n            if (this._ready) {\n                return new Error(\"Can't call config() after localforage \" + 'has been used.');\n            }\n\n            for (var i in options) {\n                if (i === 'storeName') {\n                    options[i] = options[i].replace(/\\W/g, '_');\n                }\n\n                if (i === 'version' && typeof options[i] !== 'number') {\n                    return new Error('Database version must be a number.');\n                }\n\n                this._config[i] = options[i];\n            }\n\n            // after all config options are set and\n            // the driver option is used, try setting it\n            if ('driver' in options && options.driver) {\n                return this.setDriver(this._config.driver);\n            }\n\n            return true;\n        } else if (typeof options === 'string') {\n            return this._config[options];\n        } else {\n            return this._config;\n        }\n    };\n\n    // Used to define a custom driver, shared across all instances of\n    // localForage.\n\n\n    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {\n        var promise = new Promise$1(function (resolve, reject) {\n            try {\n                var driverName = driverObject._driver;\n                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');\n                var namingError = new Error('Custom driver name already in use: ' + driverObject._driver);\n\n                // A driver name should be defined and not overlap with the\n                // library-defined, default drivers.\n                if (!driverObject._driver) {\n                    reject(complianceError);\n                    return;\n                }\n                if (isLibraryDriver(driverObject._driver)) {\n                    reject(namingError);\n                    return;\n                }\n\n                var customDriverMethods = LibraryMethods.concat('_initStorage');\n                for (var i = 0; i < customDriverMethods.length; i++) {\n                    var customDriverMethod = customDriverMethods[i];\n                    if (!customDriverMethod || !driverObject[customDriverMethod] || typeof driverObject[customDriverMethod] !== 'function') {\n                        reject(complianceError);\n                        return;\n                    }\n                }\n\n                var supportPromise = Promise$1.resolve(true);\n                if ('_support' in driverObject) {\n                    if (driverObject._support && typeof driverObject._support === 'function') {\n                        supportPromise = driverObject._support();\n                    } else {\n                        supportPromise = Promise$1.resolve(!!driverObject._support);\n                    }\n                }\n\n                supportPromise.then(function (supportResult) {\n                    driverSupport[driverName] = supportResult;\n                    CustomDrivers[driverName] = driverObject;\n                    resolve();\n                }, reject);\n            } catch (e) {\n                reject(e);\n            }\n        });\n\n        executeTwoCallbacks(promise, callback, errorCallback);\n        return promise;\n    };\n\n    LocalForage.prototype.driver = function driver() {\n        return this._driver || null;\n    };\n\n    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {\n        var self = this;\n        var getDriverPromise = Promise$1.resolve().then(function () {\n            if (isLibraryDriver(driverName)) {\n                switch (driverName) {\n                    case self.INDEXEDDB:\n                        return asyncStorage;\n                    case self.LOCALSTORAGE:\n                        return localStorageWrapper;\n                    case self.WEBSQL:\n                        return webSQLStorage;\n                }\n            } else if (CustomDrivers[driverName]) {\n                return CustomDrivers[driverName];\n            } else {\n                throw new Error('Driver not found.');\n            }\n        });\n        executeTwoCallbacks(getDriverPromise, callback, errorCallback);\n        return getDriverPromise;\n    };\n\n    LocalForage.prototype.getSerializer = function getSerializer(callback) {\n        var serializerPromise = Promise$1.resolve(localforageSerializer);\n        executeTwoCallbacks(serializerPromise, callback);\n        return serializerPromise;\n    };\n\n    LocalForage.prototype.ready = function ready(callback) {\n        var self = this;\n\n        var promise = self._driverSet.then(function () {\n            if (self._ready === null) {\n                self._ready = self._initDriver();\n            }\n\n            return self._ready;\n        });\n\n        executeTwoCallbacks(promise, callback, callback);\n        return promise;\n    };\n\n    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {\n        var self = this;\n\n        if (!isArray(drivers)) {\n            drivers = [drivers];\n        }\n\n        var supportedDrivers = this._getSupportedDrivers(drivers);\n\n        function setDriverToConfig() {\n            self._config.driver = self.driver();\n        }\n\n        function extendSelfWithDriver(driver) {\n            self._extend(driver);\n            setDriverToConfig();\n\n            self._ready = self._initStorage(self._config);\n            return self._ready;\n        }\n\n        function initDriver(supportedDrivers) {\n            return function () {\n                var currentDriverIndex = 0;\n\n                function driverPromiseLoop() {\n                    while (currentDriverIndex < supportedDrivers.length) {\n                        var driverName = supportedDrivers[currentDriverIndex];\n                        currentDriverIndex++;\n\n                        self._dbInfo = null;\n                        self._ready = null;\n\n                        return self.getDriver(driverName).then(extendSelfWithDriver)[\"catch\"](driverPromiseLoop);\n                    }\n\n                    setDriverToConfig();\n                    var error = new Error('No available storage method found.');\n                    self._driverSet = Promise$1.reject(error);\n                    return self._driverSet;\n                }\n\n                return driverPromiseLoop();\n            };\n        }\n\n        // There might be a driver initialization in progress\n        // so wait for it to finish in order to avoid a possible\n        // race condition to set _dbInfo\n        var oldDriverSetDone = this._driverSet !== null ? this._driverSet[\"catch\"](function () {\n            return Promise$1.resolve();\n        }) : Promise$1.resolve();\n\n        this._driverSet = oldDriverSetDone.then(function () {\n            var driverName = supportedDrivers[0];\n            self._dbInfo = null;\n            self._ready = null;\n\n            return self.getDriver(driverName).then(function (driver) {\n                self._driver = driver._driver;\n                setDriverToConfig();\n                self._wrapLibraryMethodsWithReady();\n                self._initDriver = initDriver(supportedDrivers);\n            });\n        })[\"catch\"](function () {\n            setDriverToConfig();\n            var error = new Error('No available storage method found.');\n            self._driverSet = Promise$1.reject(error);\n            return self._driverSet;\n        });\n\n        executeTwoCallbacks(this._driverSet, callback, errorCallback);\n        return this._driverSet;\n    };\n\n    LocalForage.prototype.supports = function supports(driverName) {\n        return !!driverSupport[driverName];\n    };\n\n    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {\n        extend(this, libraryMethodsAndProperties);\n    };\n\n    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {\n        var supportedDrivers = [];\n        for (var i = 0, len = drivers.length; i < len; i++) {\n            var driverName = drivers[i];\n            if (this.supports(driverName)) {\n                supportedDrivers.push(driverName);\n            }\n        }\n        return supportedDrivers;\n    };\n\n    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {\n        // Add a stub for each driver API method that delays the call to the\n        // corresponding driver method until localForage is ready. These stubs\n        // will be replaced by the driver methods as soon as the driver is\n        // loaded, so there is no performance impact.\n        for (var i = 0; i < LibraryMethods.length; i++) {\n            callWhenReady(this, LibraryMethods[i]);\n        }\n    };\n\n    LocalForage.prototype.createInstance = function createInstance(options) {\n        return new LocalForage(options);\n    };\n\n    return LocalForage;\n}();\n\n// The actual localForage object that we expose as a module or via a\n// global. It's extended by pulling in one of our other libraries.\n\n\nvar localforage_js = new LocalForage();\n\nmodule.exports = localforage_js;\n\n},{\"3\":3}]},{},[4])(4)\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/localforage/dist/localforage.js\n// module id = 30\n// module chunks = 1","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 31\n// module chunks = 1","/**\n * pushToggle.js\n * \n * Deals with the toggle used to Toggle Subscription from On and Off\n * It also Disables the toggle in case it's not supported with appropriate error messages\n * \n * Displaying the status text within this card, also makes sure that this \n * card is calibrated enough with the application state, which we want to make sure\n * is always the case.\n * \n * This card is going to rely on running from the beginning and thus makes \n * no assumption of having subscription state, being stored anywhere\n */\n\nconst card = document.querySelector('.subscription-toggle');\nconst subscriptionStatus = card.querySelector('.subscription-status');\nconst subscriptionSwitch = card.querySelector('input');\nconst subscriptionLabel = subscriptionSwitch.parentNode;\n\nconst NOT_SUPPORTED_TEXT = 'Relevant APIs are not supported';\nconst ENABLED_ON_TEXT = 'On';\nconst ENABLED_OFF_TEXT = 'Off';\n\nfunction changeSwitch(on) {\n  on = !!on;\n  updateStatus(on ? ENABLED_ON_TEXT : ENABLED_OFF_TEXT);\n  subscriptionSwitch.checked = on;\n  on ? subscriptionLabel.classList.add('is-checked')\n    : subscriptionLabel.classList.remove('is-checked');\n}\n\n/**\n * Enable or disable the Material Design Switch based on the\n * enable parameter passed\n */\nfunction enableSwitch(enable) {\n  // Explicit conversion to type Boolean\n  const enabledBool = !!enable;\n  subscriptionSwitch.disabled = !enabledBool;\n  \n  if (!enabledBool) {\n    subscriptionLabel.classList.remove('is-checked');\n    subscriptionLabel.classList.add('is-disabled');\n    updateStatus(NOT_SUPPORTED_TEXT);\n    subscriptionSwitch.checked = false;\n  } else {\n    updateStatus(subscriptionSwitch.checked ? ENABLED_ON_TEXT : ENABLED_OFF_TEXT);\n    subscriptionLabel.classList.remove('is-disabled');\n  }\n}\n\n/**\n * In order to wait for the operation to complete\n * before anyother operation is started\n * `waitToggle` disables the toggle so it can't be used\n */\nfunction waitToggle() {\n  subscriptionSwitch.disabled = true;\n  subscriptionLabel.classList.add('is-disabled');\n}\n\n/**\n * Updates the Statu of the text in the card\n */\nfunction updateStatus(status) {\n  subscriptionStatus.textContent = status;\n}\n\n/**\n * Updates the Switch Status and enables or disabled according\n * to the parameters\n */\nfunction updateSwitch(pushSubscription) {\n  enableSwitch(true);\n  changeSwitch(!!pushSubscription);\n}\n\nexport { updateSwitch, enableSwitch, subscriptionSwitch, waitToggle };\n\n\n// WEBPACK FOOTER //\n// ./src/app/pushToggle.js","/**\n * Module for handling the Card with PushSubscription information\n */\nconst subscriptionInfoCard = document.querySelector('.subscription-info');\n\nconst serverInfo = subscriptionInfoCard.querySelector('.code.server-subscription');\nconst subscriptionInfo = subscriptionInfoCard.querySelector('.code.info');\nconst serverId = subscriptionInfoCard.querySelector('.code.server-id');\n\n/**\n * Displays the Push Info\n */\nfunction displayPushInfo(pushSubscription) {\n  if (!pushSubscription) {\n    subscriptionInfoCard.style.display = 'none';\n    return;\n  }\n\n  if (pushSubscription) {\n    subscriptionInfoCard.style.display = '';\n    subscriptionInfo.innerHTML = JSON.stringify(pushSubscription, null, 4);\n  }\n}\n\nfunction displayServerId(id) {\n  serverId.innerHTML = id;\n}\n\nfunction displayServerResponse(response) {\n  serverId.innerHTML = response._id;\n  serverInfo.innerHTML = JSON.stringify(response, null, 4);\n}\n\nfunction displayServerError() {\n  serverId.innerHTML = 'Error occured';\n  serverInfo.innerHTML = 'Error occured';\n}\n\nexport { displayPushInfo, displayServerId, displayServerResponse, displayServerError };\n\n\n// WEBPACK FOOTER //\n// ./src/app/pushInfo.js","/**\n * serverSubscriptoin.js\n * Library to perform CRUD operations on the subscriptions on server\n */\nimport axios from 'axios';\n\nconst SERVER_BASE_URL = 'https://server-xvcfivqgya.now.sh/'\nconst subscriberURL = SERVER_BASE_URL + 'subscriber';\n/**\n * Creates the Subscription on the Server \n * `subscription` is passed as body\n */\nfunction createSubscription (subscription) {\n  return axios.post(subscriberURL, {\n    subscription: JSON.parse(JSON.stringify(subscription))\n  });\n}\n\nfunction deleteSubscription (subscriptionId) {\n  return axios.delete(subscriberURL, {\n    data: {\n      id: subscriptionId\n    },\n    responseType: 'json',\n  });\n}\n\nfunction getSubscription (subscriptionId) {\n  return axios.get(subscriberURL, { params: { id: subscriptionId }});\n}\n\nexport default  { createSubscription, getSubscription, deleteSubscription };\n\n\n// WEBPACK FOOTER //\n// ./src/app/serverSubscription.js","module.exports = __webpack_public_path__ + \"service-worker.js\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/file-loader?name=[name].[ext]!./src/app/service-worker.js\n// module id = 35\n// module chunks = 1"],"sourceRoot":""}