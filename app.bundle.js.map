{"version":3,"sources":["webpack:///app.bundle.js","webpack:///webpack/bootstrap 63afb45b2045d0ea524d","webpack:///./node_modules/axios/lib/utils.js","webpack:///./node_modules/axios/lib/defaults.js","webpack:///./node_modules/axios/lib/helpers/bind.js","webpack:///./node_modules/axios/lib/adapters/xhr.js","webpack:///./node_modules/axios/lib/core/createError.js","webpack:///./node_modules/axios/lib/cancel/isCancel.js","webpack:///./node_modules/axios/lib/cancel/Cancel.js","webpack:///./node_modules/axios/index.js","webpack:///./node_modules/axios/lib/axios.js","webpack:///./node_modules/is-buffer/index.js","webpack:///./node_modules/axios/lib/core/Axios.js","webpack:///./node_modules/axios/lib/helpers/normalizeHeaderName.js","webpack:///./node_modules/axios/lib/core/settle.js","webpack:///./node_modules/axios/lib/core/enhanceError.js","webpack:///./node_modules/axios/lib/helpers/buildURL.js","webpack:///./node_modules/axios/lib/helpers/parseHeaders.js","webpack:///./node_modules/axios/lib/helpers/isURLSameOrigin.js","webpack:///./node_modules/axios/lib/helpers/btoa.js","webpack:///./node_modules/axios/lib/helpers/cookies.js","webpack:///./node_modules/axios/lib/core/InterceptorManager.js","webpack:///./node_modules/axios/lib/core/dispatchRequest.js","webpack:///./node_modules/axios/lib/core/transformData.js","webpack:///./node_modules/axios/lib/helpers/isAbsoluteURL.js","webpack:///./node_modules/axios/lib/helpers/combineURLs.js","webpack:///./node_modules/axios/lib/cancel/CancelToken.js","webpack:///./node_modules/axios/lib/helpers/spread.js","webpack:///./src/app/index.js","webpack:///./src/app/supportCard.js","webpack:///./node_modules/localforage/dist/localforage.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/app/pushToggle.js","webpack:///./src/app/pushInfo.js","webpack:///./src/app/serverSubscription.js","webpack:///./src/app/service-worker.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","isArray","val","toString","isArrayBuffer","isFormData","FormData","isArrayBufferView","ArrayBuffer","isView","buffer","isString","isNumber","isUndefined","isObject","isDate","isFile","isBlob","isFunction","isStream","pipe","isURLSearchParams","URLSearchParams","trim","str","replace","isStandardBrowserEnv","navigator","product","window","document","forEach","obj","fn","length","key","merge","assignValue","result","arguments","extend","a","b","thisArg","bind","isBuffer","setContentTypeIfUnset","headers","value","utils","normalizeHeaderName","DEFAULT_CONTENT_TYPE","Content-Type","defaults","adapter","XMLHttpRequest","transformRequest","data","JSON","stringify","transformResponse","parse","e","timeout","xsrfCookieName","xsrfHeaderName","maxContentLength","validateStatus","status","common","Accept","method","args","Array","apply","settle","buildURL","parseHeaders","isURLSameOrigin","createError","btoa","config","Promise","resolve","reject","requestData","requestHeaders","request","loadEvent","xDomain","XDomainRequest","url","onprogress","ontimeout","auth","username","password","Authorization","open","toUpperCase","params","paramsSerializer","readyState","responseURL","indexOf","responseHeaders","getAllResponseHeaders","responseData","responseType","response","responseText","statusText","onerror","cookies","xsrfValue","withCredentials","read","undefined","toLowerCase","setRequestHeader","onDownloadProgress","addEventListener","onUploadProgress","upload","cancelToken","promise","then","cancel","abort","send","enhanceError","message","code","error","Error","__CANCEL__","Cancel","this","createInstance","defaultConfig","context","Axios","instance","axios","create","instanceConfig","CancelToken","isCancel","all","promises","spread","default","constructor","isSlowBuffer","readFloatLE","slice","_isBuffer","interceptors","InterceptorManager","dispatchRequest","isAbsoluteURL","combineURLs","baseURL","chain","interceptor","unshift","fulfilled","rejected","push","shift","normalizedName","encode","encodeURIComponent","serializedParams","parts","v","toISOString","join","parsed","split","line","substr","resolveURL","href","msie","urlParsingNode","setAttribute","protocol","host","search","hash","hostname","port","pathname","charAt","originURL","test","userAgent","createElement","location","requestURL","E","input","block","charCode","String","output","idx","map","chars","charCodeAt","write","expires","path","domain","secure","cookie","Date","toGMTString","match","RegExp","decodeURIComponent","remove","now","handlers","use","eject","id","h","throwIfCancellationRequested","throwIfRequested","transformData","reason","fns","relativeURL","executor","TypeError","resolvePromise","token","source","callback","arr","_interopRequireDefault","urlBase64ToUint8Array","base64String","padding","repeat","base64","rawData","atob","outputArray","Uint8Array","initSubscription","serviceWorker","ready","registration","pushManager","getSubscription","subscription","updateSubscriptionUI","catch","console","updateServerSubscription","subscribe","userVisibleOnly","applicationServerKey","SAFE_APPLICATION_SERVER_KEY","log","pushSubscription","unsubscribe","removed","_pushToggle","updateSwitch","_pushInfo","displayPushInfo","_localforage2","getItem","savedSubscription","_evalSubscriptionCond","evalSubscriptionConditions","shouldUpdate","shouldDelete","_serverSubscription2","createSubscription","setItem","deleteSubscription","_id","newSubscription","displayServerResponse","displayServerError","endpointCondition","endpoint","_axios","_supportCard","_supportCard2","_localforage","_serverSubscription","_serviceWorker","swSupport","pushSupport","isSupported","register","subscriptionSwitch","changeEvent","checked","target","waitToggle","updateSupportCard","notSupportedCard","style","display","textContent","querySelector","supportStatus","global","require","f","t","r","u","1","_dereq_","nextTick","draining","oldQueue","len","queue","immediate","task","scheduleDrain","Mutation","MutationObserver","WebKitMutationObserver","called","observer","element","createTextNode","observe","characterData","setImmediate","MessageChannel","scriptEl","onreadystatechange","parentNode","removeChild","documentElement","appendChild","setTimeout","channel","port1","onmessage","port2","postMessage","self","2","INTERNAL","resolver","state","PENDING","outcome","safelyResolveThenable","QueueItem","onFulfilled","onRejected","callFulfilled","otherCallFulfilled","callRejected","otherCallRejected","unwrap","func","returnValue","getThen","thenable","onError","onSuccess","tryToUnwrap","tryCatch","out","iterable","values","resolved","resolveFromAll","outValue","race","REJECTED","FULFILLED","3","4","_classCallCheck","Constructor","createBlob","properties","Blob","Builder","BlobBuilder","MSBlobBuilder","MozBlobBuilder","WebKitBlobBuilder","builder","append","getBlob","type","executeCallback","executeTwoCallbacks","errorCallback","_binStringToArrayBuffer","bin","buf","_checkBlobSupportWithoutCaching","idb","Promise$1","txn","transaction","DETECT_BLOB_SUPPORT_STORE","blob","objectStore","put","onabort","preventDefault","stopPropagation","oncomplete","matchedChrome","matchedEdge","parseInt","_checkBlobSupport","supportsBlobs","_deferReadiness","dbInfo","dbContext","dbContexts","deferredOperation","deferredOperations","dbReady","_advanceReadiness","pop","_getConnection","upgradeNeeded","db","close","dbArgs","version","openreq","onupgradeneeded","createObjectStore","storeName","oldVersion","ex","warn","newVersion","onsuccess","_getOriginalConnection","_getUpgradedConnection","_isUpgradeNeeded","defaultVersion","isNewStore","objectStoreNames","contains","isDowngrade","isUpgrade","incVersion","_encodeBlob","reader","FileReader","onloadend","__local_forage_encoded_blob","readAsBinaryString","_decodeBlob","encodedBlob","_isEncodedBlob","_fullyReady","_initReady","_dbInfo","_initStorage","options","ignoreErrors","forages","initPromises","j","forage","_defaultConfig","k","store","req","iterate","iterator","openCursor","iterationNumber","cursor","blobSupport","err","removeItem","clear","count","advanced","advance","keys","stringToBuffer","serializedString","encoded1","encoded2","encoded3","encoded4","bufferLength","bytes","BASE_CHARS","bufferToString","substring","serialize","valueType","toString$1","marker","SERIALIZED_MARKER","TYPE_ARRAYBUFFER","TYPE_INT8ARRAY","TYPE_UINT8ARRAY","TYPE_UINT8CLAMPEDARRAY","TYPE_INT16ARRAY","TYPE_UINT16ARRAY","TYPE_INT32ARRAY","TYPE_UINT32ARRAY","TYPE_FLOAT32ARRAY","TYPE_FLOAT64ARRAY","fileReader","onload","BLOB_TYPE_PREFIX","TYPE_BLOB","readAsArrayBuffer","deserialize","SERIALIZED_MARKER_LENGTH","blobType","TYPE_SERIALIZED_MARKER_LENGTH","BLOB_TYPE_PREFIX_REGEX","matcher","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","_initStorage$1","dbInfoPromise","openDatabase","description","size","executeSql","serializer","localforageSerializer","getItem$1","results","rows","item","iterate$1","_setItem","retriesLeft","originalValue","sqlError","QUOTA_ERR","setItem$1","removeItem$1","clear$1","length$1","key$1","keys$1","_initStorage$2","keyPrefix","clear$2","localStorage","getItem$2","iterate$2","keyPrefixLength","key$2","keys$2","length$2","removeItem$2","setItem$2","callWhenReady","localForageInstance","libraryMethod","_args","arg","isLibraryDriver","driverName","driver","DriverType","_typeof","Symbol","indexedDB","webkitIndexedDB","mozIndexedDB","OIndexedDB","msIndexedDB","asyncStorage","_driver","webSQLStorage","localStorageWrapper","CustomDrivers","INDEXEDDB","LOCALSTORAGE","WEBSQL","DefaultDriverOrder","LibraryMethods","DefaultConfig","driverSupport","isSafari","platform","hasFetch","fetch","IDBKeyRange","LocalForage","_config","_driverSet","_initDriver","_ready","_wrapLibraryMethodsWithReady","setDriver","defineDriver","driverObject","complianceError","namingError","customDriverMethods","concat","customDriverMethod","supportPromise","_support","supportResult","getDriver","getDriverPromise","getSerializer","serializerPromise","drivers","setDriverToConfig","extendSelfWithDriver","_extend","initDriver","supportedDrivers","driverPromiseLoop","currentDriverIndex","_getSupportedDrivers","oldDriverSetDone","supports","libraryMethodsAndProperties","localforage_js","g","Function","eval","changeSwitch","on","updateStatus","ENABLED_ON_TEXT","ENABLED_OFF_TEXT","subscriptionLabel","classList","add","enableSwitch","enable","enabledBool","disabled","NOT_SUPPORTED_TEXT","subscriptionStatus","card","subscriptionInfoCard","subscriptionInfo","innerHTML","displayServerId","serverId","serverInfo","_axios2","post","subscriberURL","subscriptionId","delete","SERVER_BASE_URL"],"mappings":"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","file":"app.bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"./\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 26);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar bind = __webpack_require__(2);\nvar isBuffer = __webpack_require__(9);\n\n/*global toString:true*/\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object' && !isArray(obj)) {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (typeof result[key] === 'object' && typeof val === 'object') {\n      result[key] = merge(result[key], val);\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim\n};\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(0);\nvar normalizeHeaderName = __webpack_require__(11);\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = __webpack_require__(3);\n  } else if (true) {\n    // For node use HTTP adapter\n    adapter = __webpack_require__(3);\n  }\n  return adapter;\n}\n\nvar defaults = {\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Content-Type');\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data)) {\n      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');\n      return JSON.stringify(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    /*eslint no-param-reassign:0*/\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (e) { /* Ignore */ }\n    }\n    return data;\n  }],\n\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(0);\nvar settle = __webpack_require__(12);\nvar buildURL = __webpack_require__(14);\nvar parseHeaders = __webpack_require__(15);\nvar isURLSameOrigin = __webpack_require__(16);\nvar createError = __webpack_require__(4);\nvar btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || __webpack_require__(17);\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n    var loadEvent = 'onreadystatechange';\n    var xDomain = false;\n\n    // For IE 8/9 CORS support\n    // Only supports POST and GET calls and doesn't returns the response headers.\n    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.\n    if (\"production\" !== 'test' &&\n        typeof window !== 'undefined' &&\n        window.XDomainRequest && !('withCredentials' in request) &&\n        !isURLSameOrigin(config.url)) {\n      request = new window.XDomainRequest();\n      loadEvent = 'onload';\n      xDomain = true;\n      request.onprogress = function handleProgress() {};\n      request.ontimeout = function handleTimeout() {};\n    }\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    // Listen for ready state\n    request[loadEvent] = function handleLoad() {\n      if (!request || (request.readyState !== 4 && !xDomain)) {\n        return;\n      }\n\n      // The request errored out and we didn't get a response, this will be\n      // handled by onerror instead\n      // With one exception: request that using file: protocol, most browsers\n      // will return status as 0 even though it's a successful request\n      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n        return;\n      }\n\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201)\n        status: request.status === 1223 ? 204 : request.status,\n        statusText: request.status === 1223 ? 'No Content' : request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      var cookies = __webpack_require__(18);\n\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?\n          cookies.read(config.xsrfCookieName) :\n          undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (config.withCredentials) {\n      request.withCredentials = true;\n    }\n\n    // Add responseType to request if needed\n    if (config.responseType) {\n      try {\n        request.responseType = config.responseType;\n      } catch (e) {\n        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.\n        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.\n        if (config.responseType !== 'json') {\n          throw e;\n        }\n      }\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (requestData === undefined) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar enhanceError = __webpack_require__(13);\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(8);\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(0);\nvar bind = __webpack_require__(2);\nvar Axios = __webpack_require__(10);\nvar defaults = __webpack_require__(1);\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(utils.merge(defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = __webpack_require__(6);\naxios.CancelToken = __webpack_require__(24);\naxios.isCancel = __webpack_require__(5);\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = __webpack_require__(25);\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\n/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar defaults = __webpack_require__(1);\nvar utils = __webpack_require__(0);\nvar InterceptorManager = __webpack_require__(19);\nvar dispatchRequest = __webpack_require__(20);\nvar isAbsoluteURL = __webpack_require__(22);\nvar combineURLs = __webpack_require__(23);\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = utils.merge({\n      url: arguments[0]\n    }, arguments[1]);\n  }\n\n  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);\n  config.method = config.method.toLowerCase();\n\n  // Support baseURL config\n  if (config.baseURL && !isAbsoluteURL(config.url)) {\n    config.url = combineURLs(config.baseURL, config.url);\n  }\n\n  // Hook up interceptors middleware\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(0);\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar createError = __webpack_require__(4);\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  // Note: status is not exposed by XDomainRequest\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n  error.request = request;\n  error.response = response;\n  return error;\n};\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(0);\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%40/gi, '@').\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      }\n\n      if (!utils.isArray(val)) {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(0);\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n    }\n  });\n\n  return parsed;\n};\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(0);\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n  (function standardBrowserEnv() {\n    var msie = /(msie|trident)/i.test(navigator.userAgent);\n    var urlParsingNode = document.createElement('a');\n    var originURL;\n\n    /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n    function resolveURL(url) {\n      var href = url;\n\n      if (msie) {\n        // IE needs attribute set twice to normalize properties\n        urlParsingNode.setAttribute('href', href);\n        href = urlParsingNode.href;\n      }\n\n      urlParsingNode.setAttribute('href', href);\n\n      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n      return {\n        href: urlParsingNode.href,\n        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n        host: urlParsingNode.host,\n        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n        hostname: urlParsingNode.hostname,\n        port: urlParsingNode.port,\n        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n                  urlParsingNode.pathname :\n                  '/' + urlParsingNode.pathname\n      };\n    }\n\n    originURL = resolveURL(window.location.href);\n\n    /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n    return function isURLSameOrigin(requestURL) {\n      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n      return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n    };\n  })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n  (function nonStandardBrowserEnv() {\n    return function isURLSameOrigin() {\n      return true;\n    };\n  })()\n);\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js\n\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfunction E() {\n  this.message = 'String contains an invalid character';\n}\nE.prototype = new Error;\nE.prototype.code = 5;\nE.prototype.name = 'InvalidCharacterError';\n\nfunction btoa(input) {\n  var str = String(input);\n  var output = '';\n  for (\n    // initialize result and counter\n    var block, charCode, idx = 0, map = chars;\n    // if the next str index does not exist:\n    //   change the mapping table to \"=\"\n    //   check if d has no fractional digits\n    str.charAt(idx | 0) || (map = '=', idx % 1);\n    // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n    output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n  ) {\n    charCode = str.charCodeAt(idx += 3 / 4);\n    if (charCode > 0xFF) {\n      throw new E();\n    }\n    block = block << 8 | charCode;\n  }\n  return output;\n}\n\nmodule.exports = btoa;\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(0);\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n  (function standardBrowserEnv() {\n    return {\n      write: function write(name, value, expires, path, domain, secure) {\n        var cookie = [];\n        cookie.push(name + '=' + encodeURIComponent(value));\n\n        if (utils.isNumber(expires)) {\n          cookie.push('expires=' + new Date(expires).toGMTString());\n        }\n\n        if (utils.isString(path)) {\n          cookie.push('path=' + path);\n        }\n\n        if (utils.isString(domain)) {\n          cookie.push('domain=' + domain);\n        }\n\n        if (secure === true) {\n          cookie.push('secure');\n        }\n\n        document.cookie = cookie.join('; ');\n      },\n\n      read: function read(name) {\n        var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n        return (match ? decodeURIComponent(match[3]) : null);\n      },\n\n      remove: function remove(name) {\n        this.write(name, '', Date.now() - 86400000);\n      }\n    };\n  })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n  (function nonStandardBrowserEnv() {\n    return {\n      write: function write() {},\n      read: function read() { return null; },\n      remove: function remove() {}\n    };\n  })()\n);\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(0);\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(0);\nvar transformData = __webpack_require__(21);\nvar isCancel = __webpack_require__(5);\nvar defaults = __webpack_require__(1);\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData(\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers || {}\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData(\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData(\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(0);\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn(data, headers);\n  });\n\n  return data;\n};\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Cancel = __webpack_require__(6);\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n__webpack_require__(27);\n\nvar _axios = __webpack_require__(7);\n\nvar _axios2 = _interopRequireDefault(_axios);\n\nvar _supportCard = __webpack_require__(28);\n\nvar _supportCard2 = _interopRequireDefault(_supportCard);\n\nvar _localforage = __webpack_require__(29);\n\nvar _localforage2 = _interopRequireDefault(_localforage);\n\nvar _pushToggle = __webpack_require__(31);\n\nvar _pushInfo = __webpack_require__(32);\n\nvar _serverSubscription = __webpack_require__(33);\n\nvar _serverSubscription2 = _interopRequireDefault(_serverSubscription);\n\nvar _serviceWorker = __webpack_require__(34);\n\nvar _serviceWorker2 = _interopRequireDefault(_serviceWorker);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Global Variables Regarding the Support of the PushManager Related APIs\n// Imports all the Custom Styles as well as Material Design Lite\n// Using a Webpack Familiar Syntax\nvar swSupport = navigator && 'serviceWorker' in navigator;\n/**\n * Webpack Bundling Specific logic related to service worker.\n * Please IGNORE THIS!\n */\n\nvar pushSupport = window && 'PushManager' in window;\nvar isSupported = navigator && swSupport && pushSupport;\nvar SAFE_APPLICATION_SERVER_KEY = 'BFyMIWmgIvBFAbC-0CrU6tqfiqr4A4rcVqWtnHncpPuKeFfGrnHCjOfvdumLoN6Lh8fdOecWdy2_yKF7dDPldAM';\n\n/*\n * Global Variables to hold the state of\n * - `pushManager` - Manager for Push Notifications\n * - `pushSubscription` - Current Subscription stored in global state\n * \n * `pushSubscription` is helpful to coordinate in actions such as\n * delete subscription so we don't have to do an additional getSubscription\n * call for the sake of this demo.\n */\nvar pushManager = null;\nvar pushSubscription = null;\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  (0, _supportCard2.default)(swSupport, pushSupport);\n  if (isSupported) {\n    // Registering the server here if supported\n    navigator.serviceWorker.register('./service-worker.js').catch(function (error) {\n      console.error('Failed to register the latest ServiceWorker');\n      throw error;\n    });\n\n    initSubscription();\n    _pushToggle.subscriptionSwitch.addEventListener('change', function (changeEvent) {\n      var checked = changeEvent.target.checked;\n      (0, _pushToggle.waitToggle)();\n      if (checked) {\n        subscribe();\n      } else {\n        unsubscribe();\n      }\n    });\n  }\n});\n\n/**\n * Helper Function to Convert a URL Base 64 String to a Uint8Array type in JavaScript\n * @param {String} base64String\n * @return {Uint8Array} Uint8Array type\n */\nfunction urlBase64ToUint8Array(base64String) {\n  var padding = '='.repeat((4 - base64String.length % 4) % 4);\n  var base64 = (base64String + padding).replace(/\\-/g, '+').replace(/_/g, '/');\n\n  var rawData = window.atob(base64);\n  var outputArray = new Uint8Array(rawData.length);\n\n  for (var i = 0; i < rawData.length; ++i) {\n    outputArray[i] = rawData.charCodeAt(i);\n  }\n  return outputArray;\n}\n\n/**\n * Initial Subscription related logic\n */\nfunction initSubscription() {\n  navigator.serviceWorker.ready.then(function (registration) {\n    pushManager = registration.pushManager;\n    pushManager.getSubscription().then(function (subscription) {\n      updateSubscriptionUI(subscription);\n    }).catch(function (error) {\n      console.error(error);\n      updateServerSubscription(null);\n    });\n  });\n}\n\n/**\n * Subscribes to the Push Manager and updates the\n * UI if successful\n */\nfunction subscribe() {\n  pushManager.subscribe({\n    userVisibleOnly: true,\n    applicationServerKey: urlBase64ToUint8Array(SAFE_APPLICATION_SERVER_KEY)\n  }).then(function (subscription) {\n    console.log('Subscribed!');\n    pushSubscription = subscription;\n    updateSubscriptionUI(subscription);\n  }).catch(function (error) {\n    console.log('Error occured while subscribing');\n    console.error(error);\n    updateSubscriptionUI(pushSubscription);\n  });\n}\n\n/**\n * Unsubscribes the PushSubscription\n * and updates the subscription UI \n */\nfunction unsubscribe() {\n  if (!pushSubscription) {\n    console.log('`pushSubscription` is null');\n    updateSubscriptionUI(null);\n    return;\n  }\n\n  return pushSubscription.unsubscribe().then(function (removed) {\n    pushSubscription = null;\n    updateSubscriptionUI(pushSubscription);\n  }).catch(function (error) {\n    console.error(error);\n    updateSubscriptionUI(pushSubscription);\n  });\n}\n\n// Updates the subscription on update\nfunction updateSubscriptionUI(subscription) {\n  (0, _pushToggle.updateSwitch)(subscription);\n  (0, _pushInfo.displayPushInfo)(subscription);\n  updateServerSubscription(subscription);\n}\n\n/**\n * Updates the Subscription on the Server side\n * if new\n */\nfunction updateServerSubscription(subscription) {\n  return _localforage2.default.getItem('subscription').then(function (savedSubscription) {\n    savedSubscription = JSON.parse(savedSubscription);\n\n    var _evalSubscriptionCond = evalSubscriptionConditions(savedSubscription, subscription),\n        shouldUpdate = _evalSubscriptionCond.shouldUpdate,\n        shouldDelete = _evalSubscriptionCond.shouldDelete;\n\n    if (!shouldUpdate && !shouldDelete) {\n      console.log('Both Subscriptions are same, do nothing');\n      return savedSubscription;\n    }\n\n    if (shouldUpdate) {\n      /**\n       * Further actions are dependent on successful \n       * createion of subscription on database\n       * \n       * This promise is going to be included within the promise chain.\n       */\n      return _serverSubscription2.default.createSubscription(subscription).then(function (response) {\n        var data = response.data;\n        console.log('Subscription Created ', data);\n        return _localforage2.default.setItem('subscription', JSON.stringify(data)).then(function () {\n          return data;\n        });\n      });\n    } else if (shouldDelete) {\n      return _localforage2.default.setItem('subscription', null).then(function () {\n        _serverSubscription2.default.deleteSubscription(savedSubscription._id);\n        return null;\n      });\n    }\n  }).then(function (newSubscription) {\n    // UI can be updated in this then function\n    // as related operations to the subscriptions have been performed on them\n    if (subscription) {\n      console.log('Displaying information for the subscription');\n      (0, _pushInfo.displayPushInfo)(subscription);\n      (0, _pushInfo.displayServerResponse)(newSubscription);\n    }\n  }).catch(function (error) {\n    console.error('Failure in updating the status');\n    console.error(error);\n    (0, _pushInfo.displayServerError)(error);\n  });\n}\n\n/**\n * Evaluate related conditions to the subscription\n */\nfunction evalSubscriptionConditions(savedSubscription, subscription) {\n  var endpointCondition = savedSubscription && subscription && savedSubscription.endpoint !== subscription.endpoint;\n\n  return {\n    shouldUpdate: !savedSubscription && subscription || endpointCondition,\n    shouldDelete: !subscription && savedSubscription\n  };\n}\n\n/**\n * Based on conditions when the subscription should \n * be deleted\n * \n * @param {PushSubscription} savedSubscription Subscription stored in the storage\n */\nfunction shouldDeleteSubscription(savedSubscription, subscription) {\n  return !subscription || savedSubscription.endpoint;\n}\n\n/**\n * Removes the Subscription from the Client\n */\nfunction removeSubscription(subscription) {\n  return _localforage2.default.getItem('subscription').then(function (subscription) {\n    if (subscription) {\n      console.log('Existing Subscription is going to be removed');\n      return Promise.all([_serverSubscription2.default.deleteSubscription(subscription._id), _localforage2.default.setItem('subscriptionId', null)]);\n    }\n  });\n}\n\n// Updates the Loading UI in order \n// to represent the loading state of the operations\n// Disables the toggle for the duration of the task being performed\n// in order to prevent from any other task to be executed\nfunction showLoadingUI() {\n  (0, _pushToggle.waitToggle)();\n}\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = updateSupportCard;\n/**\n * Asking important questions that needs answer\n * - What is the design pattern we can use, that let's us make reuse of the elements \n *   in the applications so we can keep our memory footprint low and save time that's spent\n *   in looking up for dom elements each time?\n */\n\nvar notSupportedCard = exports.notSupportedCard = document.querySelector('.not-supported');\nvar supportStatus = notSupportedCard.querySelector('.support-status');\nvar swSupport = supportStatus.querySelector('.service-worker .value');\nvar pushSupport = supportStatus.querySelector('.push-api .value');\n\nfunction updateSupportCard(serviceWorker, pushManager) {\n  if (serviceWorker && pushManager) {\n    notSupportedCard.style.display = 'none';\n  } else {\n    swSupport.textContent = serviceWorker ? 'Supported' : 'Not Supported';\n    pushSupport.textContent = pushManager ? 'Supported' : 'Not Supported';\n    notSupportedCard.style.display = 'block';\n  }\n}\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/*!\n    localForage -- Offline Storage, Improved\n    Version 1.5.0\n    https://localforage.github.io/localForage\n    (c) 2013-2017 Mozilla, Apache License 2.0\n*/\n(function(f){if(true){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.localforage = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw (f.code=\"MODULE_NOT_FOUND\", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],2:[function(_dereq_,module,exports){\n'use strict';\nvar immediate = _dereq_(1);\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && typeof obj === 'object' && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nexports.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nexports.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nexports.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nexports.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n},{\"1\":1}],3:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nif (typeof global.Promise !== 'function') {\n  global.Promise = _dereq_(2);\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"2\":2}],4:[function(_dereq_,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction getIDB() {\n    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */\n    try {\n        if (typeof indexedDB !== 'undefined') {\n            return indexedDB;\n        }\n        if (typeof webkitIndexedDB !== 'undefined') {\n            return webkitIndexedDB;\n        }\n        if (typeof mozIndexedDB !== 'undefined') {\n            return mozIndexedDB;\n        }\n        if (typeof OIndexedDB !== 'undefined') {\n            return OIndexedDB;\n        }\n        if (typeof msIndexedDB !== 'undefined') {\n            return msIndexedDB;\n        }\n    } catch (e) {}\n}\n\nvar idb = getIDB();\n\nfunction isIndexedDBValid() {\n    try {\n        // Initialize IndexedDB; fall back to vendor-prefixed versions\n        // if needed.\n        if (!idb) {\n            return false;\n        }\n        // We mimic PouchDB here;\n        //\n        // We test for openDatabase because IE Mobile identifies itself\n        // as Safari. Oh the lulz...\n        var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);\n\n        var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;\n\n        // Safari <10.1 does not meet our requirements for IDB support (#5572)\n        // since Safari 10.1 shipped with fetch, we can use that to detect it\n        return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&\n        // some outdated implementations of IDB that appear on Samsung\n        // and HTC Android devices <4.4 are missing IDBKeyRange\n        typeof IDBKeyRange !== 'undefined';\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction isWebSQLValid() {\n    return typeof openDatabase === 'function';\n}\n\nfunction isLocalStorageValid() {\n    try {\n        return typeof localStorage !== 'undefined' && 'setItem' in localStorage && localStorage.setItem;\n    } catch (e) {\n        return false;\n    }\n}\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\nfunction createBlob(parts, properties) {\n    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n    parts = parts || [];\n    properties = properties || {};\n    try {\n        return new Blob(parts, properties);\n    } catch (e) {\n        if (e.name !== 'TypeError') {\n            throw e;\n        }\n        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;\n        var builder = new Builder();\n        for (var i = 0; i < parts.length; i += 1) {\n            builder.append(parts[i]);\n        }\n        return builder.getBlob(properties.type);\n    }\n}\n\n// This is CommonJS because lie is an external dependency, so Rollup\n// can just ignore it.\nif (typeof Promise === 'undefined') {\n    // In the \"nopromises\" build this will just throw if you don't have\n    // a global promise object, but it would throw anyway later.\n    _dereq_(3);\n}\nvar Promise$1 = Promise;\n\nfunction executeCallback(promise, callback) {\n    if (callback) {\n        promise.then(function (result) {\n            callback(null, result);\n        }, function (error) {\n            callback(error);\n        });\n    }\n}\n\nfunction executeTwoCallbacks(promise, callback, errorCallback) {\n    if (typeof callback === 'function') {\n        promise.then(callback);\n    }\n\n    if (typeof errorCallback === 'function') {\n        promise[\"catch\"](errorCallback);\n    }\n}\n\n// Some code originally from async_storage.js in\n// [Gaia](https://github.com/mozilla-b2g/gaia).\n\nvar DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';\nvar supportsBlobs;\nvar dbContexts;\nvar toString = Object.prototype.toString;\n\n// Transform a binary string to an array buffer, because otherwise\n// weird stuff happens when you try to work with the binary string directly.\n// It is known.\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction _binStringToArrayBuffer(bin) {\n    var length = bin.length;\n    var buf = new ArrayBuffer(length);\n    var arr = new Uint8Array(buf);\n    for (var i = 0; i < length; i++) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return buf;\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\n// Code borrowed from PouchDB. See:\n// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js\n//\nfunction _checkBlobSupportWithoutCaching(idb) {\n    return new Promise$1(function (resolve) {\n        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, 'readwrite');\n        var blob = createBlob(['']);\n        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n\n        txn.onabort = function (e) {\n            // If the transaction aborts now its due to not being able to\n            // write to the database, likely due to the disk being full\n            e.preventDefault();\n            e.stopPropagation();\n            resolve(false);\n        };\n\n        txn.oncomplete = function () {\n            var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n            var matchedEdge = navigator.userAgent.match(/Edge\\//);\n            // MS Edge pretends to be Chrome 42:\n            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);\n        };\n    })[\"catch\"](function () {\n        return false; // error, so assume unsupported\n    });\n}\n\nfunction _checkBlobSupport(idb) {\n    if (typeof supportsBlobs === 'boolean') {\n        return Promise$1.resolve(supportsBlobs);\n    }\n    return _checkBlobSupportWithoutCaching(idb).then(function (value) {\n        supportsBlobs = value;\n        return supportsBlobs;\n    });\n}\n\nfunction _deferReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Create a deferred object representing the current database operation.\n    var deferredOperation = {};\n\n    deferredOperation.promise = new Promise$1(function (resolve) {\n        deferredOperation.resolve = resolve;\n    });\n\n    // Enqueue the deferred operation.\n    dbContext.deferredOperations.push(deferredOperation);\n\n    // Chain its promise to the database readiness.\n    if (!dbContext.dbReady) {\n        dbContext.dbReady = deferredOperation.promise;\n    } else {\n        dbContext.dbReady = dbContext.dbReady.then(function () {\n            return deferredOperation.promise;\n        });\n    }\n}\n\nfunction _advanceReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Dequeue a deferred operation.\n    var deferredOperation = dbContext.deferredOperations.pop();\n\n    // Resolve its promise (which is part of the database readiness\n    // chain of promises).\n    if (deferredOperation) {\n        deferredOperation.resolve();\n    }\n}\n\nfunction _getConnection(dbInfo, upgradeNeeded) {\n    return new Promise$1(function (resolve, reject) {\n\n        if (dbInfo.db) {\n            if (upgradeNeeded) {\n                _deferReadiness(dbInfo);\n                dbInfo.db.close();\n            } else {\n                return resolve(dbInfo.db);\n            }\n        }\n\n        var dbArgs = [dbInfo.name];\n\n        if (upgradeNeeded) {\n            dbArgs.push(dbInfo.version);\n        }\n\n        var openreq = idb.open.apply(idb, dbArgs);\n\n        if (upgradeNeeded) {\n            openreq.onupgradeneeded = function (e) {\n                var db = openreq.result;\n                try {\n                    db.createObjectStore(dbInfo.storeName);\n                    if (e.oldVersion <= 1) {\n                        // Added when support for blob shims was added\n                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n                    }\n                } catch (ex) {\n                    if (ex.name === 'ConstraintError') {\n                        console.warn('The database \"' + dbInfo.name + '\"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage \"' + dbInfo.storeName + '\" already exists.');\n                    } else {\n                        throw ex;\n                    }\n                }\n            };\n        }\n\n        openreq.onerror = function (e) {\n            e.preventDefault();\n            reject(openreq.error);\n        };\n\n        openreq.onsuccess = function () {\n            resolve(openreq.result);\n            _advanceReadiness(dbInfo);\n        };\n    });\n}\n\nfunction _getOriginalConnection(dbInfo) {\n    return _getConnection(dbInfo, false);\n}\n\nfunction _getUpgradedConnection(dbInfo) {\n    return _getConnection(dbInfo, true);\n}\n\nfunction _isUpgradeNeeded(dbInfo, defaultVersion) {\n    if (!dbInfo.db) {\n        return true;\n    }\n\n    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\n    var isDowngrade = dbInfo.version < dbInfo.db.version;\n    var isUpgrade = dbInfo.version > dbInfo.db.version;\n\n    if (isDowngrade) {\n        // If the version is not the default one\n        // then warn for impossible downgrade.\n        if (dbInfo.version !== defaultVersion) {\n            console.warn('The database \"' + dbInfo.name + '\"' + ' can\\'t be downgraded from version ' + dbInfo.db.version + ' to version ' + dbInfo.version + '.');\n        }\n        // Align the versions to prevent errors.\n        dbInfo.version = dbInfo.db.version;\n    }\n\n    if (isUpgrade || isNewStore) {\n        // If the store is new then increment the version (if needed).\n        // This will trigger an \"upgradeneeded\" event which is required\n        // for creating a store.\n        if (isNewStore) {\n            var incVersion = dbInfo.db.version + 1;\n            if (incVersion > dbInfo.version) {\n                dbInfo.version = incVersion;\n            }\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n// encode a blob for indexeddb engines that don't support blobs\nfunction _encodeBlob(blob) {\n    return new Promise$1(function (resolve, reject) {\n        var reader = new FileReader();\n        reader.onerror = reject;\n        reader.onloadend = function (e) {\n            var base64 = btoa(e.target.result || '');\n            resolve({\n                __local_forage_encoded_blob: true,\n                data: base64,\n                type: blob.type\n            });\n        };\n        reader.readAsBinaryString(blob);\n    });\n}\n\n// decode an encoded blob\nfunction _decodeBlob(encodedBlob) {\n    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\n    return createBlob([arrayBuff], { type: encodedBlob.type });\n}\n\n// is this one of our fancy encoded blobs?\nfunction _isEncodedBlob(value) {\n    return value && value.__local_forage_encoded_blob;\n}\n\n// Specialize the default `ready()` function by making it dependent\n// on the current database operations. Thus, the driver will be actually\n// ready when it's been initialized (default) *and* there are no pending\n// operations on the database (initiated by some other instances).\nfunction _fullyReady(callback) {\n    var self = this;\n\n    var promise = self._initReady().then(function () {\n        var dbContext = dbContexts[self._dbInfo.name];\n\n        if (dbContext && dbContext.dbReady) {\n            return dbContext.dbReady;\n        }\n    });\n\n    executeTwoCallbacks(promise, callback, callback);\n    return promise;\n}\n\n// Open the IndexedDB database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    // Initialize a singleton container for all running localForages.\n    if (!dbContexts) {\n        dbContexts = {};\n    }\n\n    // Get the current context of the database;\n    var dbContext = dbContexts[dbInfo.name];\n\n    // ...or create a new context.\n    if (!dbContext) {\n        dbContext = {\n            // Running localForages sharing a database.\n            forages: [],\n            // Shared database.\n            db: null,\n            // Database readiness (promise).\n            dbReady: null,\n            // Deferred operations on the database.\n            deferredOperations: []\n        };\n        // Register the new context in the global container.\n        dbContexts[dbInfo.name] = dbContext;\n    }\n\n    // Register itself as a running localForage in the current context.\n    dbContext.forages.push(self);\n\n    // Replace the default `ready()` function with the specialized one.\n    if (!self._initReady) {\n        self._initReady = self.ready;\n        self.ready = _fullyReady;\n    }\n\n    // Create an array of initialization states of the related localForages.\n    var initPromises = [];\n\n    function ignoreErrors() {\n        // Don't handle errors here,\n        // just makes sure related localForages aren't pending.\n        return Promise$1.resolve();\n    }\n\n    for (var j = 0; j < dbContext.forages.length; j++) {\n        var forage = dbContext.forages[j];\n        if (forage !== self) {\n            // Don't wait for itself...\n            initPromises.push(forage._initReady()[\"catch\"](ignoreErrors));\n        }\n    }\n\n    // Take a snapshot of the related localForages.\n    var forages = dbContext.forages.slice(0);\n\n    // Initialize the connection process only when\n    // all the related localForages aren't pending.\n    return Promise$1.all(initPromises).then(function () {\n        dbInfo.db = dbContext.db;\n        // Get the connection or open a new one without upgrade.\n        return _getOriginalConnection(dbInfo);\n    }).then(function (db) {\n        dbInfo.db = db;\n        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {\n            // Reopen the database for upgrading.\n            return _getUpgradedConnection(dbInfo);\n        }\n        return db;\n    }).then(function (db) {\n        dbInfo.db = dbContext.db = db;\n        self._dbInfo = dbInfo;\n        // Share the final connection amongst related localForages.\n        for (var k = 0; k < forages.length; k++) {\n            var forage = forages[k];\n            if (forage !== self) {\n                // Self is already up-to-date.\n                forage._dbInfo.db = dbInfo.db;\n                forage._dbInfo.version = dbInfo.version;\n            }\n        }\n    });\n}\n\nfunction getItem(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n            var req = store.get(key);\n\n            req.onsuccess = function () {\n                var value = req.result;\n                if (value === undefined) {\n                    value = null;\n                }\n                if (_isEncodedBlob(value)) {\n                    value = _decodeBlob(value);\n                }\n                resolve(value);\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items stored in database.\nfunction iterate(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n\n            var req = store.openCursor();\n            var iterationNumber = 1;\n\n            req.onsuccess = function () {\n                var cursor = req.result;\n\n                if (cursor) {\n                    var value = cursor.value;\n                    if (_isEncodedBlob(value)) {\n                        value = _decodeBlob(value);\n                    }\n                    var result = iterator(value, cursor.key, iterationNumber++);\n\n                    if (result !== void 0) {\n                        resolve(result);\n                    } else {\n                        cursor[\"continue\"]();\n                    }\n                } else {\n                    resolve();\n                }\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n\n    return promise;\n}\n\nfunction setItem(key, value, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        var dbInfo;\n        self.ready().then(function () {\n            dbInfo = self._dbInfo;\n            if (toString.call(value) === '[object Blob]') {\n                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {\n                    if (blobSupport) {\n                        return value;\n                    }\n                    return _encodeBlob(value);\n                });\n            }\n            return value;\n        }).then(function (value) {\n            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');\n            var store = transaction.objectStore(dbInfo.storeName);\n            var req = store.put(value, key);\n\n            // The reason we don't _save_ null is because IE 10 does\n            // not support saving the `null` type in IndexedDB. How\n            // ironic, given the bug below!\n            // See: https://github.com/mozilla/localForage/issues/161\n            if (value === null) {\n                value = undefined;\n            }\n\n            transaction.oncomplete = function () {\n                // Cast to undefined so the value passed to\n                // callback/promise is the same as what one would get out\n                // of `getItem()` later. This leads to some weirdness\n                // (setItem('foo', undefined) will return `null`), but\n                // it's not my fault localStorage is our baseline and that\n                // it's weird.\n                if (value === undefined) {\n                    value = null;\n                }\n\n                resolve(value);\n            };\n            transaction.onabort = transaction.onerror = function () {\n                var err = req.error ? req.error : req.transaction.error;\n                reject(err);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction removeItem(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');\n            var store = transaction.objectStore(dbInfo.storeName);\n\n            // We use a Grunt task to make this safe for IE and some\n            // versions of Android (including those used by Cordova).\n            // Normally IE won't like `.delete()` and will insist on\n            // using `['delete']()`, but we have a build step that\n            // fixes this for us now.\n            var req = store[\"delete\"](key);\n            transaction.oncomplete = function () {\n                resolve();\n            };\n\n            transaction.onerror = function () {\n                reject(req.error);\n            };\n\n            // The request will be also be aborted if we've exceeded our storage\n            // space.\n            transaction.onabort = function () {\n                var err = req.error ? req.error : req.transaction.error;\n                reject(err);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction clear(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');\n            var store = transaction.objectStore(dbInfo.storeName);\n            var req = store.clear();\n\n            transaction.oncomplete = function () {\n                resolve();\n            };\n\n            transaction.onabort = transaction.onerror = function () {\n                var err = req.error ? req.error : req.transaction.error;\n                reject(err);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction length(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n            var req = store.count();\n\n            req.onsuccess = function () {\n                resolve(req.result);\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction key(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        if (n < 0) {\n            resolve(null);\n\n            return;\n        }\n\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n\n            var advanced = false;\n            var req = store.openCursor();\n            req.onsuccess = function () {\n                var cursor = req.result;\n                if (!cursor) {\n                    // this means there weren't enough keys\n                    resolve(null);\n\n                    return;\n                }\n\n                if (n === 0) {\n                    // We have the first key, return it if that's what they\n                    // wanted.\n                    resolve(cursor.key);\n                } else {\n                    if (!advanced) {\n                        // Otherwise, ask the cursor to skip ahead n\n                        // records.\n                        advanced = true;\n                        cursor.advance(n);\n                    } else {\n                        // When we get here, we've got the nth key.\n                        resolve(cursor.key);\n                    }\n                }\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n\n            var req = store.openCursor();\n            var keys = [];\n\n            req.onsuccess = function () {\n                var cursor = req.result;\n\n                if (!cursor) {\n                    resolve(keys);\n                    return;\n                }\n\n                keys.push(cursor.key);\n                cursor[\"continue\"]();\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar asyncStorage = {\n    _driver: 'asyncStorage',\n    _initStorage: _initStorage,\n    iterate: iterate,\n    getItem: getItem,\n    setItem: setItem,\n    removeItem: removeItem,\n    clear: clear,\n    length: length,\n    key: key,\n    keys: keys\n};\n\n// Sadly, the best way to save binary data in WebSQL/localStorage is serializing\n// it to Base64, so this is how we store it to prevent very strange errors with less\n// verbose ways of binary <-> string data storage.\nvar BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nvar BLOB_TYPE_PREFIX = '~~local_forage_type~';\nvar BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\n\nvar SERIALIZED_MARKER = '__lfsc__:';\nvar SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n\n// OMG the serializations!\nvar TYPE_ARRAYBUFFER = 'arbf';\nvar TYPE_BLOB = 'blob';\nvar TYPE_INT8ARRAY = 'si08';\nvar TYPE_UINT8ARRAY = 'ui08';\nvar TYPE_UINT8CLAMPEDARRAY = 'uic8';\nvar TYPE_INT16ARRAY = 'si16';\nvar TYPE_INT32ARRAY = 'si32';\nvar TYPE_UINT16ARRAY = 'ur16';\nvar TYPE_UINT32ARRAY = 'ui32';\nvar TYPE_FLOAT32ARRAY = 'fl32';\nvar TYPE_FLOAT64ARRAY = 'fl64';\nvar TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n\nvar toString$1 = Object.prototype.toString;\n\nfunction stringToBuffer(serializedString) {\n    // Fill the string into a ArrayBuffer.\n    var bufferLength = serializedString.length * 0.75;\n    var len = serializedString.length;\n    var i;\n    var p = 0;\n    var encoded1, encoded2, encoded3, encoded4;\n\n    if (serializedString[serializedString.length - 1] === '=') {\n        bufferLength--;\n        if (serializedString[serializedString.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n\n    var buffer = new ArrayBuffer(bufferLength);\n    var bytes = new Uint8Array(buffer);\n\n    for (i = 0; i < len; i += 4) {\n        encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\n        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\n        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);\n\n        /*jslint bitwise: true */\n        bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n    }\n    return buffer;\n}\n\n// Converts a buffer to a string to store, serialized, in the backend\n// storage library.\nfunction bufferToString(buffer) {\n    // base64-arraybuffer\n    var bytes = new Uint8Array(buffer);\n    var base64String = '';\n    var i;\n\n    for (i = 0; i < bytes.length; i += 3) {\n        /*jslint bitwise: true */\n        base64String += BASE_CHARS[bytes[i] >> 2];\n        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n        base64String += BASE_CHARS[bytes[i + 2] & 63];\n    }\n\n    if (bytes.length % 3 === 2) {\n        base64String = base64String.substring(0, base64String.length - 1) + '=';\n    } else if (bytes.length % 3 === 1) {\n        base64String = base64String.substring(0, base64String.length - 2) + '==';\n    }\n\n    return base64String;\n}\n\n// Serialize a value, afterwards executing a callback (which usually\n// instructs the `setItem()` callback/promise to be executed). This is how\n// we store binary data with localStorage.\nfunction serialize(value, callback) {\n    var valueType = '';\n    if (value) {\n        valueType = toString$1.call(value);\n    }\n\n    // Cannot use `value instanceof ArrayBuffer` or such here, as these\n    // checks fail when running the tests using casper.js...\n    //\n    // TODO: See why those tests fail and use a better solution.\n    if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {\n        // Convert binary arrays to a string and prefix the string with\n        // a special marker.\n        var buffer;\n        var marker = SERIALIZED_MARKER;\n\n        if (value instanceof ArrayBuffer) {\n            buffer = value;\n            marker += TYPE_ARRAYBUFFER;\n        } else {\n            buffer = value.buffer;\n\n            if (valueType === '[object Int8Array]') {\n                marker += TYPE_INT8ARRAY;\n            } else if (valueType === '[object Uint8Array]') {\n                marker += TYPE_UINT8ARRAY;\n            } else if (valueType === '[object Uint8ClampedArray]') {\n                marker += TYPE_UINT8CLAMPEDARRAY;\n            } else if (valueType === '[object Int16Array]') {\n                marker += TYPE_INT16ARRAY;\n            } else if (valueType === '[object Uint16Array]') {\n                marker += TYPE_UINT16ARRAY;\n            } else if (valueType === '[object Int32Array]') {\n                marker += TYPE_INT32ARRAY;\n            } else if (valueType === '[object Uint32Array]') {\n                marker += TYPE_UINT32ARRAY;\n            } else if (valueType === '[object Float32Array]') {\n                marker += TYPE_FLOAT32ARRAY;\n            } else if (valueType === '[object Float64Array]') {\n                marker += TYPE_FLOAT64ARRAY;\n            } else {\n                callback(new Error('Failed to get type for BinaryArray'));\n            }\n        }\n\n        callback(marker + bufferToString(buffer));\n    } else if (valueType === '[object Blob]') {\n        // Conver the blob to a binaryArray and then to a string.\n        var fileReader = new FileReader();\n\n        fileReader.onload = function () {\n            // Backwards-compatible prefix for the blob type.\n            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);\n\n            callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n        };\n\n        fileReader.readAsArrayBuffer(value);\n    } else {\n        try {\n            callback(JSON.stringify(value));\n        } catch (e) {\n            console.error(\"Couldn't convert value into a JSON string: \", value);\n\n            callback(null, e);\n        }\n    }\n}\n\n// Deserialize data we've inserted into a value column/field. We place\n// special markers into our strings to mark them as encoded; this isn't\n// as nice as a meta field, but it's the only sane thing we can do whilst\n// keeping localStorage support intact.\n//\n// Oftentimes this will just deserialize JSON content, but if we have a\n// special marker (SERIALIZED_MARKER, defined above), we will extract\n// some kind of arraybuffer/binary data/typed array out of the string.\nfunction deserialize(value) {\n    // If we haven't marked this string as being specially serialized (i.e.\n    // something other than serialized JSON), we can just return it and be\n    // done with it.\n    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n        return JSON.parse(value);\n    }\n\n    // The following code deals with deserializing some kind of Blob or\n    // TypedArray. First we separate out the type of data we're dealing\n    // with from the data itself.\n    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\n\n    var blobType;\n    // Backwards-compatible blob type serialization strategy.\n    // DBs created with older versions of localForage will simply not have the blob type.\n    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\n        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\n        blobType = matcher[1];\n        serializedString = serializedString.substring(matcher[0].length);\n    }\n    var buffer = stringToBuffer(serializedString);\n\n    // Return the right type based on the code/type set during\n    // serialization.\n    switch (type) {\n        case TYPE_ARRAYBUFFER:\n            return buffer;\n        case TYPE_BLOB:\n            return createBlob([buffer], { type: blobType });\n        case TYPE_INT8ARRAY:\n            return new Int8Array(buffer);\n        case TYPE_UINT8ARRAY:\n            return new Uint8Array(buffer);\n        case TYPE_UINT8CLAMPEDARRAY:\n            return new Uint8ClampedArray(buffer);\n        case TYPE_INT16ARRAY:\n            return new Int16Array(buffer);\n        case TYPE_UINT16ARRAY:\n            return new Uint16Array(buffer);\n        case TYPE_INT32ARRAY:\n            return new Int32Array(buffer);\n        case TYPE_UINT32ARRAY:\n            return new Uint32Array(buffer);\n        case TYPE_FLOAT32ARRAY:\n            return new Float32Array(buffer);\n        case TYPE_FLOAT64ARRAY:\n            return new Float64Array(buffer);\n        default:\n            throw new Error('Unkown type: ' + type);\n    }\n}\n\nvar localforageSerializer = {\n    serialize: serialize,\n    deserialize: deserialize,\n    stringToBuffer: stringToBuffer,\n    bufferToString: bufferToString\n};\n\n/*\n * Includes code from:\n *\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n// Open the WebSQL database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage$1(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];\n        }\n    }\n\n    var dbInfoPromise = new Promise$1(function (resolve, reject) {\n        // Open the database; the openDatabase API will automatically\n        // create it for us if it doesn't exist.\n        try {\n            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);\n        } catch (e) {\n            return reject(e);\n        }\n\n        // Create our key/value table if it doesn't exist.\n        dbInfo.db.transaction(function (t) {\n            t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' (id INTEGER PRIMARY KEY, key unique, value)', [], function () {\n                self._dbInfo = dbInfo;\n                resolve();\n            }, function (t, error) {\n                reject(error);\n            });\n        });\n    });\n\n    dbInfo.serializer = localforageSerializer;\n    return dbInfoPromise;\n}\n\nfunction getItem$1(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).value : null;\n\n                    // Check to see if this is serialized content we need to\n                    // unpack.\n                    if (result) {\n                        result = dbInfo.serializer.deserialize(result);\n                    }\n\n                    resolve(result);\n                }, function (t, error) {\n\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction iterate$1(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var rows = results.rows;\n                    var length = rows.length;\n\n                    for (var i = 0; i < length; i++) {\n                        var item = rows.item(i);\n                        var result = item.value;\n\n                        // Check to see if this is serialized content\n                        // we need to unpack.\n                        if (result) {\n                            result = dbInfo.serializer.deserialize(result);\n                        }\n\n                        result = iterator(result, item.key, i + 1);\n\n                        // void(0) prevents problems with redefinition\n                        // of `undefined`.\n                        if (result !== void 0) {\n                            resolve(result);\n                            return;\n                        }\n                    }\n\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction _setItem(key, value, callback, retriesLeft) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            // The localStorage API doesn't return undefined values in an\n            // \"expected\" way, so undefined is always cast to null in all\n            // drivers. See: https://github.com/mozilla/localForage/pull/42\n            if (value === undefined) {\n                value = null;\n            }\n\n            // Save the original value to pass to the callback.\n            var originalValue = value;\n\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    dbInfo.db.transaction(function (t) {\n                        t.executeSql('INSERT OR REPLACE INTO ' + dbInfo.storeName + ' (key, value) VALUES (?, ?)', [key, value], function () {\n                            resolve(originalValue);\n                        }, function (t, error) {\n                            reject(error);\n                        });\n                    }, function (sqlError) {\n                        // The transaction failed; check\n                        // to see if it's a quota error.\n                        if (sqlError.code === sqlError.QUOTA_ERR) {\n                            // We reject the callback outright for now, but\n                            // it's worth trying to re-run the transaction.\n                            // Even if the user accepts the prompt to use\n                            // more storage on Safari, this error will\n                            // be called.\n                            //\n                            // Try to re-run the transaction.\n                            if (retriesLeft > 0) {\n                                resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));\n                                return;\n                            }\n                            reject(sqlError);\n                        }\n                    });\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction setItem$1(key, value, callback) {\n    return _setItem.apply(this, [key, value, callback, 1]);\n}\n\nfunction removeItem$1(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {\n                    resolve();\n                }, function (t, error) {\n\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Deletes every item in the table.\n// TODO: Find out if this resets the AUTO_INCREMENT number.\nfunction clear$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('DELETE FROM ' + dbInfo.storeName, [], function () {\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Does a simple `COUNT(key)` to get the number of items stored in\n// localForage.\nfunction length$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                // Ahhh, SQL makes this one soooooo easy.\n                t.executeSql('SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var result = results.rows.item(0).c;\n\n                    resolve(result);\n                }, function (t, error) {\n\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Return the key located at key index X; essentially gets the key from a\n// `WHERE id = ?`. This is the most efficient way I can think to implement\n// this rarely-used (in my experience) part of the API, but it can seem\n// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n// the ID of each key will change every time it's updated. Perhaps a stored\n// procedure for the `setItem()` SQL would solve this problem?\n// TODO: Don't change ID on `setItem()`.\nfunction key$1(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).key : null;\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var keys = [];\n\n                    for (var i = 0; i < results.rows.length; i++) {\n                        keys.push(results.rows.item(i).key);\n                    }\n\n                    resolve(keys);\n                }, function (t, error) {\n\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar webSQLStorage = {\n    _driver: 'webSQLStorage',\n    _initStorage: _initStorage$1,\n    iterate: iterate$1,\n    getItem: getItem$1,\n    setItem: setItem$1,\n    removeItem: removeItem$1,\n    clear: clear$1,\n    length: length$1,\n    key: key$1,\n    keys: keys$1\n};\n\n// Config the localStorage backend, using options set in the config.\nfunction _initStorage$2(options) {\n    var self = this;\n    var dbInfo = {};\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    dbInfo.keyPrefix = dbInfo.name + '/';\n\n    if (dbInfo.storeName !== self._defaultConfig.storeName) {\n        dbInfo.keyPrefix += dbInfo.storeName + '/';\n    }\n\n    self._dbInfo = dbInfo;\n    dbInfo.serializer = localforageSerializer;\n\n    return Promise$1.resolve();\n}\n\n// Remove all keys from the datastore, effectively destroying all data in\n// the app's key/value store!\nfunction clear$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var keyPrefix = self._dbInfo.keyPrefix;\n\n        for (var i = localStorage.length - 1; i >= 0; i--) {\n            var key = localStorage.key(i);\n\n            if (key.indexOf(keyPrefix) === 0) {\n                localStorage.removeItem(key);\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Retrieve an item from the store. Unlike the original async_storage\n// library in Gaia, we don't modify return values at all. If a key's value\n// is `undefined`, we pass that value to the callback function.\nfunction getItem$2(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result = localStorage.getItem(dbInfo.keyPrefix + key);\n\n        // If a result was found, parse it from the serialized\n        // string into a JS object. If result isn't truthy, the key\n        // is likely undefined and we'll pass it straight to the\n        // callback.\n        if (result) {\n            result = dbInfo.serializer.deserialize(result);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items in the store.\nfunction iterate$2(iterator, callback) {\n    var self = this;\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var keyPrefix = dbInfo.keyPrefix;\n        var keyPrefixLength = keyPrefix.length;\n        var length = localStorage.length;\n\n        // We use a dedicated iterator instead of the `i` variable below\n        // so other keys we fetch in localStorage aren't counted in\n        // the `iterationNumber` argument passed to the `iterate()`\n        // callback.\n        //\n        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n        var iterationNumber = 1;\n\n        for (var i = 0; i < length; i++) {\n            var key = localStorage.key(i);\n            if (key.indexOf(keyPrefix) !== 0) {\n                continue;\n            }\n            var value = localStorage.getItem(key);\n\n            // If a result was found, parse it from the serialized\n            // string into a JS object. If result isn't truthy, the\n            // key is likely undefined and we'll pass it straight\n            // to the iterator.\n            if (value) {\n                value = dbInfo.serializer.deserialize(value);\n            }\n\n            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);\n\n            if (value !== void 0) {\n                return value;\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Same as localStorage's key() method, except takes a callback.\nfunction key$2(n, callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result;\n        try {\n            result = localStorage.key(n);\n        } catch (error) {\n            result = null;\n        }\n\n        // Remove the prefix from the key, if a key is found.\n        if (result) {\n            result = result.substring(dbInfo.keyPrefix.length);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var length = localStorage.length;\n        var keys = [];\n\n        for (var i = 0; i < length; i++) {\n            if (localStorage.key(i).indexOf(dbInfo.keyPrefix) === 0) {\n                keys.push(localStorage.key(i).substring(dbInfo.keyPrefix.length));\n            }\n        }\n\n        return keys;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Supply the number of keys in the datastore to the callback function.\nfunction length$2(callback) {\n    var self = this;\n    var promise = self.keys().then(function (keys) {\n        return keys.length;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Remove an item from the store, nice and simple.\nfunction removeItem$2(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        localStorage.removeItem(dbInfo.keyPrefix + key);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Set a key's value and run an optional callback once the value is set.\n// Unlike Gaia's implementation, the callback function is passed the value,\n// in case you want to operate on that value only after you're sure it\n// saved, or something like that.\nfunction setItem$2(key, value, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = self.ready().then(function () {\n        // Convert undefined values to null.\n        // https://github.com/mozilla/localForage/pull/42\n        if (value === undefined) {\n            value = null;\n        }\n\n        // Save the original value to pass to the callback.\n        var originalValue = value;\n\n        return new Promise$1(function (resolve, reject) {\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    try {\n                        localStorage.setItem(dbInfo.keyPrefix + key, value);\n                        resolve(originalValue);\n                    } catch (e) {\n                        // localStorage capacity exceeded.\n                        // TODO: Make this a specific error/event.\n                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\n                            reject(e);\n                        }\n                        reject(e);\n                    }\n                }\n            });\n        });\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar localStorageWrapper = {\n    _driver: 'localStorageWrapper',\n    _initStorage: _initStorage$2,\n    // Default API, from Gaia/localStorage.\n    iterate: iterate$2,\n    getItem: getItem$2,\n    setItem: setItem$2,\n    removeItem: removeItem$2,\n    clear: clear$2,\n    length: length$2,\n    key: key$2,\n    keys: keys$2\n};\n\n// Custom drivers are stored here when `defineDriver()` is called.\n// They are shared across all instances of localForage.\nvar CustomDrivers = {};\n\nvar DriverType = {\n    INDEXEDDB: 'asyncStorage',\n    LOCALSTORAGE: 'localStorageWrapper',\n    WEBSQL: 'webSQLStorage'\n};\n\nvar DefaultDriverOrder = [DriverType.INDEXEDDB, DriverType.WEBSQL, DriverType.LOCALSTORAGE];\n\nvar LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'];\n\nvar DefaultConfig = {\n    description: '',\n    driver: DefaultDriverOrder.slice(),\n    name: 'localforage',\n    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\n    // we can use without a prompt.\n    size: 4980736,\n    storeName: 'keyvaluepairs',\n    version: 1.0\n};\n\nvar driverSupport = {};\n// Check to see if IndexedDB is available and if it is the latest\n// implementation; it's our preferred backend library. We use \"_spec_test\"\n// as the name of the database because it's not the one we'll operate on,\n// but it's useful to make sure its using the right spec.\n// See: https://github.com/mozilla/localForage/issues/128\ndriverSupport[DriverType.INDEXEDDB] = isIndexedDBValid();\n\ndriverSupport[DriverType.WEBSQL] = isWebSQLValid();\n\ndriverSupport[DriverType.LOCALSTORAGE] = isLocalStorageValid();\n\nvar isArray = Array.isArray || function (arg) {\n    return Object.prototype.toString.call(arg) === '[object Array]';\n};\n\nfunction callWhenReady(localForageInstance, libraryMethod) {\n    localForageInstance[libraryMethod] = function () {\n        var _args = arguments;\n        return localForageInstance.ready().then(function () {\n            return localForageInstance[libraryMethod].apply(localForageInstance, _args);\n        });\n    };\n}\n\nfunction extend() {\n    for (var i = 1; i < arguments.length; i++) {\n        var arg = arguments[i];\n\n        if (arg) {\n            for (var key in arg) {\n                if (arg.hasOwnProperty(key)) {\n                    if (isArray(arg[key])) {\n                        arguments[0][key] = arg[key].slice();\n                    } else {\n                        arguments[0][key] = arg[key];\n                    }\n                }\n            }\n        }\n    }\n\n    return arguments[0];\n}\n\nfunction isLibraryDriver(driverName) {\n    for (var driver in DriverType) {\n        if (DriverType.hasOwnProperty(driver) && DriverType[driver] === driverName) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nvar LocalForage = function () {\n    function LocalForage(options) {\n        _classCallCheck(this, LocalForage);\n\n        this.INDEXEDDB = DriverType.INDEXEDDB;\n        this.LOCALSTORAGE = DriverType.LOCALSTORAGE;\n        this.WEBSQL = DriverType.WEBSQL;\n\n        this._defaultConfig = extend({}, DefaultConfig);\n        this._config = extend({}, this._defaultConfig, options);\n        this._driverSet = null;\n        this._initDriver = null;\n        this._ready = false;\n        this._dbInfo = null;\n\n        this._wrapLibraryMethodsWithReady();\n        this.setDriver(this._config.driver)[\"catch\"](function () {});\n    }\n\n    // Set any config values for localForage; can be called anytime before\n    // the first API call (e.g. `getItem`, `setItem`).\n    // We loop through options so we don't overwrite existing config\n    // values.\n\n\n    LocalForage.prototype.config = function config(options) {\n        // If the options argument is an object, we use it to set values.\n        // Otherwise, we return either a specified config value or all\n        // config values.\n        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n            // If localforage is ready and fully initialized, we can't set\n            // any new configuration values. Instead, we return an error.\n            if (this._ready) {\n                return new Error(\"Can't call config() after localforage \" + 'has been used.');\n            }\n\n            for (var i in options) {\n                if (i === 'storeName') {\n                    options[i] = options[i].replace(/\\W/g, '_');\n                }\n\n                if (i === 'version' && typeof options[i] !== 'number') {\n                    return new Error('Database version must be a number.');\n                }\n\n                this._config[i] = options[i];\n            }\n\n            // after all config options are set and\n            // the driver option is used, try setting it\n            if ('driver' in options && options.driver) {\n                return this.setDriver(this._config.driver);\n            }\n\n            return true;\n        } else if (typeof options === 'string') {\n            return this._config[options];\n        } else {\n            return this._config;\n        }\n    };\n\n    // Used to define a custom driver, shared across all instances of\n    // localForage.\n\n\n    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {\n        var promise = new Promise$1(function (resolve, reject) {\n            try {\n                var driverName = driverObject._driver;\n                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');\n                var namingError = new Error('Custom driver name already in use: ' + driverObject._driver);\n\n                // A driver name should be defined and not overlap with the\n                // library-defined, default drivers.\n                if (!driverObject._driver) {\n                    reject(complianceError);\n                    return;\n                }\n                if (isLibraryDriver(driverObject._driver)) {\n                    reject(namingError);\n                    return;\n                }\n\n                var customDriverMethods = LibraryMethods.concat('_initStorage');\n                for (var i = 0; i < customDriverMethods.length; i++) {\n                    var customDriverMethod = customDriverMethods[i];\n                    if (!customDriverMethod || !driverObject[customDriverMethod] || typeof driverObject[customDriverMethod] !== 'function') {\n                        reject(complianceError);\n                        return;\n                    }\n                }\n\n                var supportPromise = Promise$1.resolve(true);\n                if ('_support' in driverObject) {\n                    if (driverObject._support && typeof driverObject._support === 'function') {\n                        supportPromise = driverObject._support();\n                    } else {\n                        supportPromise = Promise$1.resolve(!!driverObject._support);\n                    }\n                }\n\n                supportPromise.then(function (supportResult) {\n                    driverSupport[driverName] = supportResult;\n                    CustomDrivers[driverName] = driverObject;\n                    resolve();\n                }, reject);\n            } catch (e) {\n                reject(e);\n            }\n        });\n\n        executeTwoCallbacks(promise, callback, errorCallback);\n        return promise;\n    };\n\n    LocalForage.prototype.driver = function driver() {\n        return this._driver || null;\n    };\n\n    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {\n        var self = this;\n        var getDriverPromise = Promise$1.resolve().then(function () {\n            if (isLibraryDriver(driverName)) {\n                switch (driverName) {\n                    case self.INDEXEDDB:\n                        return asyncStorage;\n                    case self.LOCALSTORAGE:\n                        return localStorageWrapper;\n                    case self.WEBSQL:\n                        return webSQLStorage;\n                }\n            } else if (CustomDrivers[driverName]) {\n                return CustomDrivers[driverName];\n            } else {\n                throw new Error('Driver not found.');\n            }\n        });\n        executeTwoCallbacks(getDriverPromise, callback, errorCallback);\n        return getDriverPromise;\n    };\n\n    LocalForage.prototype.getSerializer = function getSerializer(callback) {\n        var serializerPromise = Promise$1.resolve(localforageSerializer);\n        executeTwoCallbacks(serializerPromise, callback);\n        return serializerPromise;\n    };\n\n    LocalForage.prototype.ready = function ready(callback) {\n        var self = this;\n\n        var promise = self._driverSet.then(function () {\n            if (self._ready === null) {\n                self._ready = self._initDriver();\n            }\n\n            return self._ready;\n        });\n\n        executeTwoCallbacks(promise, callback, callback);\n        return promise;\n    };\n\n    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {\n        var self = this;\n\n        if (!isArray(drivers)) {\n            drivers = [drivers];\n        }\n\n        var supportedDrivers = this._getSupportedDrivers(drivers);\n\n        function setDriverToConfig() {\n            self._config.driver = self.driver();\n        }\n\n        function extendSelfWithDriver(driver) {\n            self._extend(driver);\n            setDriverToConfig();\n\n            self._ready = self._initStorage(self._config);\n            return self._ready;\n        }\n\n        function initDriver(supportedDrivers) {\n            return function () {\n                var currentDriverIndex = 0;\n\n                function driverPromiseLoop() {\n                    while (currentDriverIndex < supportedDrivers.length) {\n                        var driverName = supportedDrivers[currentDriverIndex];\n                        currentDriverIndex++;\n\n                        self._dbInfo = null;\n                        self._ready = null;\n\n                        return self.getDriver(driverName).then(extendSelfWithDriver)[\"catch\"](driverPromiseLoop);\n                    }\n\n                    setDriverToConfig();\n                    var error = new Error('No available storage method found.');\n                    self._driverSet = Promise$1.reject(error);\n                    return self._driverSet;\n                }\n\n                return driverPromiseLoop();\n            };\n        }\n\n        // There might be a driver initialization in progress\n        // so wait for it to finish in order to avoid a possible\n        // race condition to set _dbInfo\n        var oldDriverSetDone = this._driverSet !== null ? this._driverSet[\"catch\"](function () {\n            return Promise$1.resolve();\n        }) : Promise$1.resolve();\n\n        this._driverSet = oldDriverSetDone.then(function () {\n            var driverName = supportedDrivers[0];\n            self._dbInfo = null;\n            self._ready = null;\n\n            return self.getDriver(driverName).then(function (driver) {\n                self._driver = driver._driver;\n                setDriverToConfig();\n                self._wrapLibraryMethodsWithReady();\n                self._initDriver = initDriver(supportedDrivers);\n            });\n        })[\"catch\"](function () {\n            setDriverToConfig();\n            var error = new Error('No available storage method found.');\n            self._driverSet = Promise$1.reject(error);\n            return self._driverSet;\n        });\n\n        executeTwoCallbacks(this._driverSet, callback, errorCallback);\n        return this._driverSet;\n    };\n\n    LocalForage.prototype.supports = function supports(driverName) {\n        return !!driverSupport[driverName];\n    };\n\n    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {\n        extend(this, libraryMethodsAndProperties);\n    };\n\n    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {\n        var supportedDrivers = [];\n        for (var i = 0, len = drivers.length; i < len; i++) {\n            var driverName = drivers[i];\n            if (this.supports(driverName)) {\n                supportedDrivers.push(driverName);\n            }\n        }\n        return supportedDrivers;\n    };\n\n    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {\n        // Add a stub for each driver API method that delays the call to the\n        // corresponding driver method until localForage is ready. These stubs\n        // will be replaced by the driver methods as soon as the driver is\n        // loaded, so there is no performance impact.\n        for (var i = 0; i < LibraryMethods.length; i++) {\n            callWhenReady(this, LibraryMethods[i]);\n        }\n    };\n\n    LocalForage.prototype.createInstance = function createInstance(options) {\n        return new LocalForage(options);\n    };\n\n    return LocalForage;\n}();\n\n// The actual localForage object that we expose as a module or via a\n// global. It's extended by pulling in one of our other libraries.\n\n\nvar localforage_js = new LocalForage();\n\nmodule.exports = localforage_js;\n\n},{\"3\":3}]},{},[4])(4)\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(30)))\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * pushToggle.js\n * \n * Deals with the toggle used to Toggle Subscription from On and Off\n * It also Disables the toggle in case it's not supported with appropriate error messages\n * \n * Displaying the status text within this card, also makes sure that this \n * card is calibrated enough with the application state, which we want to make sure\n * is always the case.\n * \n * This card is going to rely on running from the beginning and thus makes \n * no assumption of having subscription state, being stored anywhere\n */\n\nvar card = document.querySelector('.subscription-toggle');\nvar subscriptionStatus = card.querySelector('.subscription-status');\nvar subscriptionSwitch = card.querySelector('input');\nvar subscriptionLabel = subscriptionSwitch.parentNode;\n\nvar NOT_SUPPORTED_TEXT = 'Relevant APIs are not supported';\nvar ENABLED_ON_TEXT = 'On';\nvar ENABLED_OFF_TEXT = 'Off';\n\nfunction changeSwitch(on) {\n  on = !!on;\n  updateStatus(on ? ENABLED_ON_TEXT : ENABLED_OFF_TEXT);\n  subscriptionSwitch.checked = on;\n  on ? subscriptionLabel.classList.add('is-checked') : subscriptionLabel.classList.remove('is-checked');\n}\n\n/**\n * Enable or disable the Material Design Switch based on the\n * enable parameter passed\n */\nfunction enableSwitch(enable) {\n  // Explicit conversion to type Boolean\n  var enabledBool = !!enable;\n  subscriptionSwitch.disabled = !enabledBool;\n\n  if (!enabledBool) {\n    subscriptionLabel.classList.remove('is-checked');\n    subscriptionLabel.classList.add('is-disabled');\n    updateStatus(NOT_SUPPORTED_TEXT);\n    subscriptionSwitch.checked = false;\n  } else {\n    updateStatus(subscriptionSwitch.checked ? ENABLED_ON_TEXT : ENABLED_OFF_TEXT);\n    subscriptionLabel.classList.remove('is-disabled');\n  }\n}\n\n/**\n * In order to wait for the operation to complete\n * before anyother operation is started\n * `waitToggle` disables the toggle so it can't be used\n */\nfunction waitToggle() {\n  subscriptionSwitch.disabled = true;\n  subscriptionLabel.classList.add('is-disabled');\n}\n\n/**\n * Updates the Statu of the text in the card\n */\nfunction updateStatus(status) {\n  subscriptionStatus.textContent = status;\n}\n\n/**\n * Updates the Switch Status and enables or disabled according\n * to the parameters\n */\nfunction updateSwitch(pushSubscription) {\n  enableSwitch(true);\n  changeSwitch(!!pushSubscription);\n}\n\nexports.updateSwitch = updateSwitch;\nexports.enableSwitch = enableSwitch;\nexports.subscriptionSwitch = subscriptionSwitch;\nexports.waitToggle = waitToggle;\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Module for handling the Card with PushSubscription information\n */\nvar subscriptionInfoCard = document.querySelector('.subscription-info');\n\nvar serverInfo = subscriptionInfoCard.querySelector('.code.server-subscription');\nvar subscriptionInfo = subscriptionInfoCard.querySelector('.code.info');\nvar serverId = subscriptionInfoCard.querySelector('.code.server-id');\n\n/**\n * Displays the Push Info\n */\nfunction displayPushInfo(pushSubscription) {\n  if (!pushSubscription) {\n    subscriptionInfoCard.style.display = 'none';\n    return;\n  }\n\n  if (pushSubscription) {\n    subscriptionInfoCard.style.display = '';\n    subscriptionInfo.innerHTML = JSON.stringify(pushSubscription, null, 4);\n  }\n}\n\nfunction displayServerId(id) {\n  serverId.innerHTML = id;\n}\n\nfunction displayServerResponse(response) {\n  serverId.innerHTML = response._id;\n  serverInfo.innerHTML = JSON.stringify(response, null, 4);\n}\n\nfunction displayServerError() {\n  serverId.innerHTML = 'Error occured';\n  serverInfo.innerHTML = 'Error occured';\n}\n\nexports.displayPushInfo = displayPushInfo;\nexports.displayServerId = displayServerId;\nexports.displayServerResponse = displayServerResponse;\nexports.displayServerError = displayServerError;\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _axios = __webpack_require__(7);\n\nvar _axios2 = _interopRequireDefault(_axios);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar SERVER_BASE_URL = \"https://server-xvcfivqgya.now.sh/\"; /**\n                                                       * serverSubscriptoin.js\n                                                       * Library to perform CRUD operations on the subscriptions on server\n                                                       */\n\nvar subscriberURL = SERVER_BASE_URL + 'subscriber';\n/**\n * Creates the Subscription on the Server \n * `subscription` is passed as body\n */\nfunction createSubscription(subscription) {\n  return _axios2.default.post(subscriberURL, {\n    subscription: JSON.parse(JSON.stringify(subscription))\n  });\n}\n\nfunction deleteSubscription(subscriptionId) {\n  return _axios2.default.delete(subscriberURL, {\n    data: {\n      id: subscriptionId\n    },\n    responseType: 'json'\n  });\n}\n\nfunction getSubscription(subscriptionId) {\n  return _axios2.default.get(subscriberURL, { params: { id: subscriptionId } });\n}\n\nexports.default = { createSubscription: createSubscription, getSubscription: getSubscription, deleteSubscription: deleteSubscription };\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"service-worker.js\";\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// app.bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 26);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 63afb45b2045d0ea524d","'use strict';\n\nvar bind = require('./helpers/bind');\nvar isBuffer = require('is-buffer');\n\n/*global toString:true*/\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object' && !isArray(obj)) {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (typeof result[key] === 'object' && typeof val === 'object') {\n      result[key] = merge(result[key], val);\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/utils.js\n// module id = 0\n// module chunks = 0 1","'use strict';\n\nvar utils = require('./utils');\nvar normalizeHeaderName = require('./helpers/normalizeHeaderName');\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = require('./adapters/xhr');\n  } else if (typeof process !== 'undefined') {\n    // For node use HTTP adapter\n    adapter = require('./adapters/http');\n  }\n  return adapter;\n}\n\nvar defaults = {\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Content-Type');\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data)) {\n      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');\n      return JSON.stringify(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    /*eslint no-param-reassign:0*/\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (e) { /* Ignore */ }\n    }\n    return data;\n  }],\n\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/defaults.js\n// module id = 1\n// module chunks = 0 1","'use strict';\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/helpers/bind.js\n// module id = 2\n// module chunks = 0 1","'use strict';\n\nvar utils = require('./../utils');\nvar settle = require('./../core/settle');\nvar buildURL = require('./../helpers/buildURL');\nvar parseHeaders = require('./../helpers/parseHeaders');\nvar isURLSameOrigin = require('./../helpers/isURLSameOrigin');\nvar createError = require('../core/createError');\nvar btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || require('./../helpers/btoa');\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n    var loadEvent = 'onreadystatechange';\n    var xDomain = false;\n\n    // For IE 8/9 CORS support\n    // Only supports POST and GET calls and doesn't returns the response headers.\n    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.\n    if (process.env.NODE_ENV !== 'test' &&\n        typeof window !== 'undefined' &&\n        window.XDomainRequest && !('withCredentials' in request) &&\n        !isURLSameOrigin(config.url)) {\n      request = new window.XDomainRequest();\n      loadEvent = 'onload';\n      xDomain = true;\n      request.onprogress = function handleProgress() {};\n      request.ontimeout = function handleTimeout() {};\n    }\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    // Listen for ready state\n    request[loadEvent] = function handleLoad() {\n      if (!request || (request.readyState !== 4 && !xDomain)) {\n        return;\n      }\n\n      // The request errored out and we didn't get a response, this will be\n      // handled by onerror instead\n      // With one exception: request that using file: protocol, most browsers\n      // will return status as 0 even though it's a successful request\n      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n        return;\n      }\n\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201)\n        status: request.status === 1223 ? 204 : request.status,\n        statusText: request.status === 1223 ? 'No Content' : request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      var cookies = require('./../helpers/cookies');\n\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?\n          cookies.read(config.xsrfCookieName) :\n          undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (config.withCredentials) {\n      request.withCredentials = true;\n    }\n\n    // Add responseType to request if needed\n    if (config.responseType) {\n      try {\n        request.responseType = config.responseType;\n      } catch (e) {\n        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.\n        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.\n        if (config.responseType !== 'json') {\n          throw e;\n        }\n      }\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (requestData === undefined) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/adapters/xhr.js\n// module id = 3\n// module chunks = 0 1","'use strict';\n\nvar enhanceError = require('./enhanceError');\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/core/createError.js\n// module id = 4\n// module chunks = 0 1","'use strict';\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/cancel/isCancel.js\n// module id = 5\n// module chunks = 0 1","'use strict';\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/cancel/Cancel.js\n// module id = 6\n// module chunks = 0 1","module.exports = require('./lib/axios');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/index.js\n// module id = 7\n// module chunks = 0 1","'use strict';\n\nvar utils = require('./utils');\nvar bind = require('./helpers/bind');\nvar Axios = require('./core/Axios');\nvar defaults = require('./defaults');\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(utils.merge(defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = require('./cancel/Cancel');\naxios.CancelToken = require('./cancel/CancelToken');\naxios.isCancel = require('./cancel/isCancel');\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = require('./helpers/spread');\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/axios.js\n// module id = 8\n// module chunks = 0 1","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/is-buffer/index.js\n// module id = 9\n// module chunks = 0 1","'use strict';\n\nvar defaults = require('./../defaults');\nvar utils = require('./../utils');\nvar InterceptorManager = require('./InterceptorManager');\nvar dispatchRequest = require('./dispatchRequest');\nvar isAbsoluteURL = require('./../helpers/isAbsoluteURL');\nvar combineURLs = require('./../helpers/combineURLs');\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = utils.merge({\n      url: arguments[0]\n    }, arguments[1]);\n  }\n\n  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);\n  config.method = config.method.toLowerCase();\n\n  // Support baseURL config\n  if (config.baseURL && !isAbsoluteURL(config.url)) {\n    config.url = combineURLs(config.baseURL, config.url);\n  }\n\n  // Hook up interceptors middleware\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/core/Axios.js\n// module id = 10\n// module chunks = 0 1","'use strict';\n\nvar utils = require('../utils');\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/helpers/normalizeHeaderName.js\n// module id = 11\n// module chunks = 0 1","'use strict';\n\nvar createError = require('./createError');\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  // Note: status is not exposed by XDomainRequest\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/core/settle.js\n// module id = 12\n// module chunks = 0 1","'use strict';\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n  error.request = request;\n  error.response = response;\n  return error;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/core/enhanceError.js\n// module id = 13\n// module chunks = 0 1","'use strict';\n\nvar utils = require('./../utils');\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%40/gi, '@').\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      }\n\n      if (!utils.isArray(val)) {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/helpers/buildURL.js\n// module id = 14\n// module chunks = 0 1","'use strict';\n\nvar utils = require('./../utils');\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n    }\n  });\n\n  return parsed;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/helpers/parseHeaders.js\n// module id = 15\n// module chunks = 0 1","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n  (function standardBrowserEnv() {\n    var msie = /(msie|trident)/i.test(navigator.userAgent);\n    var urlParsingNode = document.createElement('a');\n    var originURL;\n\n    /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n    function resolveURL(url) {\n      var href = url;\n\n      if (msie) {\n        // IE needs attribute set twice to normalize properties\n        urlParsingNode.setAttribute('href', href);\n        href = urlParsingNode.href;\n      }\n\n      urlParsingNode.setAttribute('href', href);\n\n      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n      return {\n        href: urlParsingNode.href,\n        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n        host: urlParsingNode.host,\n        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n        hostname: urlParsingNode.hostname,\n        port: urlParsingNode.port,\n        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n                  urlParsingNode.pathname :\n                  '/' + urlParsingNode.pathname\n      };\n    }\n\n    originURL = resolveURL(window.location.href);\n\n    /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n    return function isURLSameOrigin(requestURL) {\n      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n      return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n    };\n  })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n  (function nonStandardBrowserEnv() {\n    return function isURLSameOrigin() {\n      return true;\n    };\n  })()\n);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/helpers/isURLSameOrigin.js\n// module id = 16\n// module chunks = 0 1","'use strict';\n\n// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js\n\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfunction E() {\n  this.message = 'String contains an invalid character';\n}\nE.prototype = new Error;\nE.prototype.code = 5;\nE.prototype.name = 'InvalidCharacterError';\n\nfunction btoa(input) {\n  var str = String(input);\n  var output = '';\n  for (\n    // initialize result and counter\n    var block, charCode, idx = 0, map = chars;\n    // if the next str index does not exist:\n    //   change the mapping table to \"=\"\n    //   check if d has no fractional digits\n    str.charAt(idx | 0) || (map = '=', idx % 1);\n    // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n    output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n  ) {\n    charCode = str.charCodeAt(idx += 3 / 4);\n    if (charCode > 0xFF) {\n      throw new E();\n    }\n    block = block << 8 | charCode;\n  }\n  return output;\n}\n\nmodule.exports = btoa;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/helpers/btoa.js\n// module id = 17\n// module chunks = 0 1","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n  (function standardBrowserEnv() {\n    return {\n      write: function write(name, value, expires, path, domain, secure) {\n        var cookie = [];\n        cookie.push(name + '=' + encodeURIComponent(value));\n\n        if (utils.isNumber(expires)) {\n          cookie.push('expires=' + new Date(expires).toGMTString());\n        }\n\n        if (utils.isString(path)) {\n          cookie.push('path=' + path);\n        }\n\n        if (utils.isString(domain)) {\n          cookie.push('domain=' + domain);\n        }\n\n        if (secure === true) {\n          cookie.push('secure');\n        }\n\n        document.cookie = cookie.join('; ');\n      },\n\n      read: function read(name) {\n        var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n        return (match ? decodeURIComponent(match[3]) : null);\n      },\n\n      remove: function remove(name) {\n        this.write(name, '', Date.now() - 86400000);\n      }\n    };\n  })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n  (function nonStandardBrowserEnv() {\n    return {\n      write: function write() {},\n      read: function read() { return null; },\n      remove: function remove() {}\n    };\n  })()\n);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/helpers/cookies.js\n// module id = 18\n// module chunks = 0 1","'use strict';\n\nvar utils = require('./../utils');\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/core/InterceptorManager.js\n// module id = 19\n// module chunks = 0 1","'use strict';\n\nvar utils = require('./../utils');\nvar transformData = require('./transformData');\nvar isCancel = require('../cancel/isCancel');\nvar defaults = require('../defaults');\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData(\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers || {}\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData(\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData(\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/core/dispatchRequest.js\n// module id = 20\n// module chunks = 0 1","'use strict';\n\nvar utils = require('./../utils');\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn(data, headers);\n  });\n\n  return data;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/core/transformData.js\n// module id = 21\n// module chunks = 0 1","'use strict';\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/helpers/isAbsoluteURL.js\n// module id = 22\n// module chunks = 0 1","'use strict';\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/helpers/combineURLs.js\n// module id = 23\n// module chunks = 0 1","'use strict';\n\nvar Cancel = require('./Cancel');\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/cancel/CancelToken.js\n// module id = 24\n// module chunks = 0 1","'use strict';\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/axios/lib/helpers/spread.js\n// module id = 25\n// module chunks = 0 1","// Imports all the Custom Styles as well as Material Design Lite\n// Using a Webpack Familiar Syntax\nimport './appStyles.css';\n\nimport axios from 'axios';\nimport updateSupportCard from './supportCard';\nimport localForage from 'localforage';\nimport { updateSwitch, subscriptionSwitch, waitToggle } from './pushToggle';\nimport {  displayServerResponse, displayPushInfo, displayServerError } from './pushInfo';\nimport serverSubscription from './serverSubscription';\n/**\n * Webpack Bundling Specific logic related to service worker.\n * Please IGNORE THIS!\n */\nimport swUrl from 'file-loader?name=[name].[ext]!./service-worker.js'\n\n// Global Variables Regarding the Support of the PushManager Related APIs\nconst swSupport = navigator && 'serviceWorker' in navigator;\nconst pushSupport = window && 'PushManager' in window;\nconst isSupported = navigator  && swSupport && pushSupport;\nconst SAFE_APPLICATION_SERVER_KEY = 'BFyMIWmgIvBFAbC-0CrU6tqfiqr4A4rcVqWtnHncpPuKeFfGrnHCjOfvdumLoN6Lh8fdOecWdy2_yKF7dDPldAM'\n\n/*\n * Global Variables to hold the state of\n * - `pushManager` - Manager for Push Notifications\n * - `pushSubscription` - Current Subscription stored in global state\n * \n * `pushSubscription` is helpful to coordinate in actions such as\n * delete subscription so we don't have to do an additional getSubscription\n * call for the sake of this demo.\n */\nlet pushManager = null;\nlet pushSubscription = null;\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  updateSupportCard(swSupport, pushSupport);\n  if (isSupported) {\n    // Registering the server here if supported\n    navigator.serviceWorker.register('./service-worker.js').catch(function (error) {\n      console.error('Failed to register the latest ServiceWorker');\n      throw error;\n    });\n\n    initSubscription();\n    subscriptionSwitch.addEventListener('change', function (changeEvent) {\n      const checked = changeEvent.target.checked;\n      waitToggle();\n      if (checked) {\n        subscribe();\n      } else {\n        unsubscribe();\n      }\n    });\n  }\n});\n\n/**\n * Helper Function to Convert a URL Base 64 String to a Uint8Array type in JavaScript\n * @param {String} base64String\n * @return {Uint8Array} Uint8Array type\n */\nfunction urlBase64ToUint8Array(base64String) {\n  const padding = '='.repeat((4 - base64String.length % 4) % 4);\n  const base64 = (base64String + padding)\n    .replace(/\\-/g, '+')\n    .replace(/_/g, '/');\n\n  const rawData = window.atob(base64);\n  const outputArray = new Uint8Array(rawData.length);\n\n  for (let i = 0; i < rawData.length; ++i) {\n    outputArray[i] = rawData.charCodeAt(i);\n  }\n  return outputArray;\n}\n\n/**\n * Initial Subscription related logic\n */\nfunction initSubscription() {\n  navigator.serviceWorker.ready.then(\n    function (registration) {\n      pushManager = registration.pushManager;\n      pushManager.getSubscription()\n        .then(function (subscription) {\n          updateSubscriptionUI(subscription);\n        })\n        .catch(function (error) {\n          console.error(error);\n          updateServerSubscription(null);\n        });\n    }\n  );\n}\n\n/**\n * Subscribes to the Push Manager and updates the\n * UI if successful\n */\nfunction subscribe () {\n  pushManager.subscribe({\n    userVisibleOnly: true,\n    applicationServerKey: urlBase64ToUint8Array(SAFE_APPLICATION_SERVER_KEY)\n  })\n  .then(function (subscription) {\n    console.log('Subscribed!')\n    pushSubscription = subscription;\n    updateSubscriptionUI(subscription);\n  })\n  .catch(function (error) {\n    console.log('Error occured while subscribing');\n    console.error(error);\n    updateSubscriptionUI(pushSubscription);\n  });\n}\n\n\n/**\n * Unsubscribes the PushSubscription\n * and updates the subscription UI \n */\nfunction unsubscribe() {\n  if (!pushSubscription) {\n    console.log('`pushSubscription` is null');\n    updateSubscriptionUI(null);\n    return;\n  }\n\n  return (\n    pushSubscription.unsubscribe()\n      .then(function (removed) {\n        pushSubscription = null;\n        updateSubscriptionUI(pushSubscription);\n      })\n      .catch(function (error) {\n        console.error(error);\n        updateSubscriptionUI(pushSubscription);\n      })\n  )\n}\n\n// Updates the subscription on update\nfunction updateSubscriptionUI(subscription) {\n  updateSwitch(subscription);\n  displayPushInfo(subscription);\n  updateServerSubscription(subscription);\n}\n\n/**\n * Updates the Subscription on the Server side\n * if new\n */\nfunction updateServerSubscription(subscription) {\n  return localForage.getItem('subscription')\n    .then(function (savedSubscription) {\n      savedSubscription = JSON.parse(savedSubscription);\n      const { shouldUpdate, shouldDelete } = evalSubscriptionConditions(\n        savedSubscription,\n        subscription\n      );\n\n     if (!shouldUpdate && !shouldDelete) {\n        console.log('Both Subscriptions are same, do nothing');\n        return savedSubscription;\n      }\n\n      if (shouldUpdate) {\n        /**\n         * Further actions are dependent on successful \n         * createion of subscription on database\n         * \n         * This promise is going to be included within the promise chain.\n         */\n        return serverSubscription.createSubscription(subscription)\n          .then(response => {\n            const data = response.data;\n            console.log('Subscription Created ', data);\n            return localForage.setItem('subscription', JSON.stringify(data)).then(() => data);\n          });\n      } else if (shouldDelete) {\n        return localForage.setItem('subscription', null)\n          .then(() => {\n            serverSubscription.deleteSubscription(savedSubscription._id)\n            return null;\n          });\n      }\n    })\n    .then(function (newSubscription) {\n      // UI can be updated in this then function\n      // as related operations to the subscriptions have been performed on them\n      if (subscription) {\n        console.log('Displaying information for the subscription');\n        displayPushInfo(subscription);\n        displayServerResponse(newSubscription);\n      }\n    })\n    .catch(function (error) {\n      console.error('Failure in updating the status');\n      console.error(error);\n      displayServerError(error);\n    });\n}\n\n/**\n * Evaluate related conditions to the subscription\n */\nfunction evalSubscriptionConditions(savedSubscription, subscription) {\n  const endpointCondition = (\n    savedSubscription && subscription &&\n    savedSubscription.endpoint !== subscription.endpoint\n  );\n\n  return {\n    shouldUpdate: !savedSubscription && subscription || endpointCondition,\n    shouldDelete: !subscription && savedSubscription,\n  };\n}\n\n/**\n * Based on conditions when the subscription should \n * be deleted\n * \n * @param {PushSubscription} savedSubscription Subscription stored in the storage\n */\nfunction shouldDeleteSubscription(savedSubscription, subscription) {\n  return (\n    !subscription ||\n    savedSubscription.endpoint\n  )\n}\n\n/**\n * Removes the Subscription from the Client\n */\nfunction removeSubscription(subscription) {\n  return localForage.getItem('subscription')\n    .then(function (subscription) {\n      if (subscription) {\n        console.log('Existing Subscription is going to be removed');\n        return Promise.all([\n          serverSubscription.deleteSubscription(subscription._id),\n          localForage.setItem('subscriptionId', null)\n        ]);\n      }\n    });\n}\n\n// Updates the Loading UI in order \n// to represent the loading state of the operations\n// Disables the toggle for the duration of the task being performed\n// in order to prevent from any other task to be executed\nfunction showLoadingUI () {\n  waitToggle();\n}\n\n\n// WEBPACK FOOTER //\n// ./src/app/index.js","/**\n * Asking important questions that needs answer\n * - What is the design pattern we can use, that let's us make reuse of the elements \n *   in the applications so we can keep our memory footprint low and save time that's spent\n *   in looking up for dom elements each time?\n */\n\nexport const notSupportedCard = document.querySelector('.not-supported');\nconst supportStatus = notSupportedCard.querySelector('.support-status');\nconst swSupport = supportStatus.querySelector('.service-worker .value');\nconst pushSupport = supportStatus.querySelector('.push-api .value');\n\nexport default function updateSupportCard(serviceWorker, pushManager) {\n  if (serviceWorker && pushManager) {\n    notSupportedCard.style.display = 'none';\n  } else {\n    swSupport.textContent = serviceWorker ? 'Supported' : 'Not Supported';\n    pushSupport.textContent = pushManager ? 'Supported' : 'Not Supported';\n    notSupportedCard.style.display = 'block';\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/app/supportCard.js","/*!\n    localForage -- Offline Storage, Improved\n    Version 1.5.0\n    https://localforage.github.io/localForage\n    (c) 2013-2017 Mozilla, Apache License 2.0\n*/\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.localforage = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw (f.code=\"MODULE_NOT_FOUND\", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],2:[function(_dereq_,module,exports){\n'use strict';\nvar immediate = _dereq_(1);\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && typeof obj === 'object' && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nexports.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nexports.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nexports.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nexports.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n},{\"1\":1}],3:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nif (typeof global.Promise !== 'function') {\n  global.Promise = _dereq_(2);\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"2\":2}],4:[function(_dereq_,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction getIDB() {\n    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */\n    try {\n        if (typeof indexedDB !== 'undefined') {\n            return indexedDB;\n        }\n        if (typeof webkitIndexedDB !== 'undefined') {\n            return webkitIndexedDB;\n        }\n        if (typeof mozIndexedDB !== 'undefined') {\n            return mozIndexedDB;\n        }\n        if (typeof OIndexedDB !== 'undefined') {\n            return OIndexedDB;\n        }\n        if (typeof msIndexedDB !== 'undefined') {\n            return msIndexedDB;\n        }\n    } catch (e) {}\n}\n\nvar idb = getIDB();\n\nfunction isIndexedDBValid() {\n    try {\n        // Initialize IndexedDB; fall back to vendor-prefixed versions\n        // if needed.\n        if (!idb) {\n            return false;\n        }\n        // We mimic PouchDB here;\n        //\n        // We test for openDatabase because IE Mobile identifies itself\n        // as Safari. Oh the lulz...\n        var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);\n\n        var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;\n\n        // Safari <10.1 does not meet our requirements for IDB support (#5572)\n        // since Safari 10.1 shipped with fetch, we can use that to detect it\n        return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&\n        // some outdated implementations of IDB that appear on Samsung\n        // and HTC Android devices <4.4 are missing IDBKeyRange\n        typeof IDBKeyRange !== 'undefined';\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction isWebSQLValid() {\n    return typeof openDatabase === 'function';\n}\n\nfunction isLocalStorageValid() {\n    try {\n        return typeof localStorage !== 'undefined' && 'setItem' in localStorage && localStorage.setItem;\n    } catch (e) {\n        return false;\n    }\n}\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\nfunction createBlob(parts, properties) {\n    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n    parts = parts || [];\n    properties = properties || {};\n    try {\n        return new Blob(parts, properties);\n    } catch (e) {\n        if (e.name !== 'TypeError') {\n            throw e;\n        }\n        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;\n        var builder = new Builder();\n        for (var i = 0; i < parts.length; i += 1) {\n            builder.append(parts[i]);\n        }\n        return builder.getBlob(properties.type);\n    }\n}\n\n// This is CommonJS because lie is an external dependency, so Rollup\n// can just ignore it.\nif (typeof Promise === 'undefined') {\n    // In the \"nopromises\" build this will just throw if you don't have\n    // a global promise object, but it would throw anyway later.\n    _dereq_(3);\n}\nvar Promise$1 = Promise;\n\nfunction executeCallback(promise, callback) {\n    if (callback) {\n        promise.then(function (result) {\n            callback(null, result);\n        }, function (error) {\n            callback(error);\n        });\n    }\n}\n\nfunction executeTwoCallbacks(promise, callback, errorCallback) {\n    if (typeof callback === 'function') {\n        promise.then(callback);\n    }\n\n    if (typeof errorCallback === 'function') {\n        promise[\"catch\"](errorCallback);\n    }\n}\n\n// Some code originally from async_storage.js in\n// [Gaia](https://github.com/mozilla-b2g/gaia).\n\nvar DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';\nvar supportsBlobs;\nvar dbContexts;\nvar toString = Object.prototype.toString;\n\n// Transform a binary string to an array buffer, because otherwise\n// weird stuff happens when you try to work with the binary string directly.\n// It is known.\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction _binStringToArrayBuffer(bin) {\n    var length = bin.length;\n    var buf = new ArrayBuffer(length);\n    var arr = new Uint8Array(buf);\n    for (var i = 0; i < length; i++) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return buf;\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\n// Code borrowed from PouchDB. See:\n// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js\n//\nfunction _checkBlobSupportWithoutCaching(idb) {\n    return new Promise$1(function (resolve) {\n        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, 'readwrite');\n        var blob = createBlob(['']);\n        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n\n        txn.onabort = function (e) {\n            // If the transaction aborts now its due to not being able to\n            // write to the database, likely due to the disk being full\n            e.preventDefault();\n            e.stopPropagation();\n            resolve(false);\n        };\n\n        txn.oncomplete = function () {\n            var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n            var matchedEdge = navigator.userAgent.match(/Edge\\//);\n            // MS Edge pretends to be Chrome 42:\n            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);\n        };\n    })[\"catch\"](function () {\n        return false; // error, so assume unsupported\n    });\n}\n\nfunction _checkBlobSupport(idb) {\n    if (typeof supportsBlobs === 'boolean') {\n        return Promise$1.resolve(supportsBlobs);\n    }\n    return _checkBlobSupportWithoutCaching(idb).then(function (value) {\n        supportsBlobs = value;\n        return supportsBlobs;\n    });\n}\n\nfunction _deferReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Create a deferred object representing the current database operation.\n    var deferredOperation = {};\n\n    deferredOperation.promise = new Promise$1(function (resolve) {\n        deferredOperation.resolve = resolve;\n    });\n\n    // Enqueue the deferred operation.\n    dbContext.deferredOperations.push(deferredOperation);\n\n    // Chain its promise to the database readiness.\n    if (!dbContext.dbReady) {\n        dbContext.dbReady = deferredOperation.promise;\n    } else {\n        dbContext.dbReady = dbContext.dbReady.then(function () {\n            return deferredOperation.promise;\n        });\n    }\n}\n\nfunction _advanceReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Dequeue a deferred operation.\n    var deferredOperation = dbContext.deferredOperations.pop();\n\n    // Resolve its promise (which is part of the database readiness\n    // chain of promises).\n    if (deferredOperation) {\n        deferredOperation.resolve();\n    }\n}\n\nfunction _getConnection(dbInfo, upgradeNeeded) {\n    return new Promise$1(function (resolve, reject) {\n\n        if (dbInfo.db) {\n            if (upgradeNeeded) {\n                _deferReadiness(dbInfo);\n                dbInfo.db.close();\n            } else {\n                return resolve(dbInfo.db);\n            }\n        }\n\n        var dbArgs = [dbInfo.name];\n\n        if (upgradeNeeded) {\n            dbArgs.push(dbInfo.version);\n        }\n\n        var openreq = idb.open.apply(idb, dbArgs);\n\n        if (upgradeNeeded) {\n            openreq.onupgradeneeded = function (e) {\n                var db = openreq.result;\n                try {\n                    db.createObjectStore(dbInfo.storeName);\n                    if (e.oldVersion <= 1) {\n                        // Added when support for blob shims was added\n                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n                    }\n                } catch (ex) {\n                    if (ex.name === 'ConstraintError') {\n                        console.warn('The database \"' + dbInfo.name + '\"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage \"' + dbInfo.storeName + '\" already exists.');\n                    } else {\n                        throw ex;\n                    }\n                }\n            };\n        }\n\n        openreq.onerror = function (e) {\n            e.preventDefault();\n            reject(openreq.error);\n        };\n\n        openreq.onsuccess = function () {\n            resolve(openreq.result);\n            _advanceReadiness(dbInfo);\n        };\n    });\n}\n\nfunction _getOriginalConnection(dbInfo) {\n    return _getConnection(dbInfo, false);\n}\n\nfunction _getUpgradedConnection(dbInfo) {\n    return _getConnection(dbInfo, true);\n}\n\nfunction _isUpgradeNeeded(dbInfo, defaultVersion) {\n    if (!dbInfo.db) {\n        return true;\n    }\n\n    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\n    var isDowngrade = dbInfo.version < dbInfo.db.version;\n    var isUpgrade = dbInfo.version > dbInfo.db.version;\n\n    if (isDowngrade) {\n        // If the version is not the default one\n        // then warn for impossible downgrade.\n        if (dbInfo.version !== defaultVersion) {\n            console.warn('The database \"' + dbInfo.name + '\"' + ' can\\'t be downgraded from version ' + dbInfo.db.version + ' to version ' + dbInfo.version + '.');\n        }\n        // Align the versions to prevent errors.\n        dbInfo.version = dbInfo.db.version;\n    }\n\n    if (isUpgrade || isNewStore) {\n        // If the store is new then increment the version (if needed).\n        // This will trigger an \"upgradeneeded\" event which is required\n        // for creating a store.\n        if (isNewStore) {\n            var incVersion = dbInfo.db.version + 1;\n            if (incVersion > dbInfo.version) {\n                dbInfo.version = incVersion;\n            }\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n// encode a blob for indexeddb engines that don't support blobs\nfunction _encodeBlob(blob) {\n    return new Promise$1(function (resolve, reject) {\n        var reader = new FileReader();\n        reader.onerror = reject;\n        reader.onloadend = function (e) {\n            var base64 = btoa(e.target.result || '');\n            resolve({\n                __local_forage_encoded_blob: true,\n                data: base64,\n                type: blob.type\n            });\n        };\n        reader.readAsBinaryString(blob);\n    });\n}\n\n// decode an encoded blob\nfunction _decodeBlob(encodedBlob) {\n    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\n    return createBlob([arrayBuff], { type: encodedBlob.type });\n}\n\n// is this one of our fancy encoded blobs?\nfunction _isEncodedBlob(value) {\n    return value && value.__local_forage_encoded_blob;\n}\n\n// Specialize the default `ready()` function by making it dependent\n// on the current database operations. Thus, the driver will be actually\n// ready when it's been initialized (default) *and* there are no pending\n// operations on the database (initiated by some other instances).\nfunction _fullyReady(callback) {\n    var self = this;\n\n    var promise = self._initReady().then(function () {\n        var dbContext = dbContexts[self._dbInfo.name];\n\n        if (dbContext && dbContext.dbReady) {\n            return dbContext.dbReady;\n        }\n    });\n\n    executeTwoCallbacks(promise, callback, callback);\n    return promise;\n}\n\n// Open the IndexedDB database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    // Initialize a singleton container for all running localForages.\n    if (!dbContexts) {\n        dbContexts = {};\n    }\n\n    // Get the current context of the database;\n    var dbContext = dbContexts[dbInfo.name];\n\n    // ...or create a new context.\n    if (!dbContext) {\n        dbContext = {\n            // Running localForages sharing a database.\n            forages: [],\n            // Shared database.\n            db: null,\n            // Database readiness (promise).\n            dbReady: null,\n            // Deferred operations on the database.\n            deferredOperations: []\n        };\n        // Register the new context in the global container.\n        dbContexts[dbInfo.name] = dbContext;\n    }\n\n    // Register itself as a running localForage in the current context.\n    dbContext.forages.push(self);\n\n    // Replace the default `ready()` function with the specialized one.\n    if (!self._initReady) {\n        self._initReady = self.ready;\n        self.ready = _fullyReady;\n    }\n\n    // Create an array of initialization states of the related localForages.\n    var initPromises = [];\n\n    function ignoreErrors() {\n        // Don't handle errors here,\n        // just makes sure related localForages aren't pending.\n        return Promise$1.resolve();\n    }\n\n    for (var j = 0; j < dbContext.forages.length; j++) {\n        var forage = dbContext.forages[j];\n        if (forage !== self) {\n            // Don't wait for itself...\n            initPromises.push(forage._initReady()[\"catch\"](ignoreErrors));\n        }\n    }\n\n    // Take a snapshot of the related localForages.\n    var forages = dbContext.forages.slice(0);\n\n    // Initialize the connection process only when\n    // all the related localForages aren't pending.\n    return Promise$1.all(initPromises).then(function () {\n        dbInfo.db = dbContext.db;\n        // Get the connection or open a new one without upgrade.\n        return _getOriginalConnection(dbInfo);\n    }).then(function (db) {\n        dbInfo.db = db;\n        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {\n            // Reopen the database for upgrading.\n            return _getUpgradedConnection(dbInfo);\n        }\n        return db;\n    }).then(function (db) {\n        dbInfo.db = dbContext.db = db;\n        self._dbInfo = dbInfo;\n        // Share the final connection amongst related localForages.\n        for (var k = 0; k < forages.length; k++) {\n            var forage = forages[k];\n            if (forage !== self) {\n                // Self is already up-to-date.\n                forage._dbInfo.db = dbInfo.db;\n                forage._dbInfo.version = dbInfo.version;\n            }\n        }\n    });\n}\n\nfunction getItem(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n            var req = store.get(key);\n\n            req.onsuccess = function () {\n                var value = req.result;\n                if (value === undefined) {\n                    value = null;\n                }\n                if (_isEncodedBlob(value)) {\n                    value = _decodeBlob(value);\n                }\n                resolve(value);\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items stored in database.\nfunction iterate(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n\n            var req = store.openCursor();\n            var iterationNumber = 1;\n\n            req.onsuccess = function () {\n                var cursor = req.result;\n\n                if (cursor) {\n                    var value = cursor.value;\n                    if (_isEncodedBlob(value)) {\n                        value = _decodeBlob(value);\n                    }\n                    var result = iterator(value, cursor.key, iterationNumber++);\n\n                    if (result !== void 0) {\n                        resolve(result);\n                    } else {\n                        cursor[\"continue\"]();\n                    }\n                } else {\n                    resolve();\n                }\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n\n    return promise;\n}\n\nfunction setItem(key, value, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        var dbInfo;\n        self.ready().then(function () {\n            dbInfo = self._dbInfo;\n            if (toString.call(value) === '[object Blob]') {\n                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {\n                    if (blobSupport) {\n                        return value;\n                    }\n                    return _encodeBlob(value);\n                });\n            }\n            return value;\n        }).then(function (value) {\n            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');\n            var store = transaction.objectStore(dbInfo.storeName);\n            var req = store.put(value, key);\n\n            // The reason we don't _save_ null is because IE 10 does\n            // not support saving the `null` type in IndexedDB. How\n            // ironic, given the bug below!\n            // See: https://github.com/mozilla/localForage/issues/161\n            if (value === null) {\n                value = undefined;\n            }\n\n            transaction.oncomplete = function () {\n                // Cast to undefined so the value passed to\n                // callback/promise is the same as what one would get out\n                // of `getItem()` later. This leads to some weirdness\n                // (setItem('foo', undefined) will return `null`), but\n                // it's not my fault localStorage is our baseline and that\n                // it's weird.\n                if (value === undefined) {\n                    value = null;\n                }\n\n                resolve(value);\n            };\n            transaction.onabort = transaction.onerror = function () {\n                var err = req.error ? req.error : req.transaction.error;\n                reject(err);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction removeItem(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');\n            var store = transaction.objectStore(dbInfo.storeName);\n\n            // We use a Grunt task to make this safe for IE and some\n            // versions of Android (including those used by Cordova).\n            // Normally IE won't like `.delete()` and will insist on\n            // using `['delete']()`, but we have a build step that\n            // fixes this for us now.\n            var req = store[\"delete\"](key);\n            transaction.oncomplete = function () {\n                resolve();\n            };\n\n            transaction.onerror = function () {\n                reject(req.error);\n            };\n\n            // The request will be also be aborted if we've exceeded our storage\n            // space.\n            transaction.onabort = function () {\n                var err = req.error ? req.error : req.transaction.error;\n                reject(err);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction clear(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');\n            var store = transaction.objectStore(dbInfo.storeName);\n            var req = store.clear();\n\n            transaction.oncomplete = function () {\n                resolve();\n            };\n\n            transaction.onabort = transaction.onerror = function () {\n                var err = req.error ? req.error : req.transaction.error;\n                reject(err);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction length(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n            var req = store.count();\n\n            req.onsuccess = function () {\n                resolve(req.result);\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction key(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        if (n < 0) {\n            resolve(null);\n\n            return;\n        }\n\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n\n            var advanced = false;\n            var req = store.openCursor();\n            req.onsuccess = function () {\n                var cursor = req.result;\n                if (!cursor) {\n                    // this means there weren't enough keys\n                    resolve(null);\n\n                    return;\n                }\n\n                if (n === 0) {\n                    // We have the first key, return it if that's what they\n                    // wanted.\n                    resolve(cursor.key);\n                } else {\n                    if (!advanced) {\n                        // Otherwise, ask the cursor to skip ahead n\n                        // records.\n                        advanced = true;\n                        cursor.advance(n);\n                    } else {\n                        // When we get here, we've got the nth key.\n                        resolve(cursor.key);\n                    }\n                }\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n\n            var req = store.openCursor();\n            var keys = [];\n\n            req.onsuccess = function () {\n                var cursor = req.result;\n\n                if (!cursor) {\n                    resolve(keys);\n                    return;\n                }\n\n                keys.push(cursor.key);\n                cursor[\"continue\"]();\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar asyncStorage = {\n    _driver: 'asyncStorage',\n    _initStorage: _initStorage,\n    iterate: iterate,\n    getItem: getItem,\n    setItem: setItem,\n    removeItem: removeItem,\n    clear: clear,\n    length: length,\n    key: key,\n    keys: keys\n};\n\n// Sadly, the best way to save binary data in WebSQL/localStorage is serializing\n// it to Base64, so this is how we store it to prevent very strange errors with less\n// verbose ways of binary <-> string data storage.\nvar BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nvar BLOB_TYPE_PREFIX = '~~local_forage_type~';\nvar BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\n\nvar SERIALIZED_MARKER = '__lfsc__:';\nvar SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n\n// OMG the serializations!\nvar TYPE_ARRAYBUFFER = 'arbf';\nvar TYPE_BLOB = 'blob';\nvar TYPE_INT8ARRAY = 'si08';\nvar TYPE_UINT8ARRAY = 'ui08';\nvar TYPE_UINT8CLAMPEDARRAY = 'uic8';\nvar TYPE_INT16ARRAY = 'si16';\nvar TYPE_INT32ARRAY = 'si32';\nvar TYPE_UINT16ARRAY = 'ur16';\nvar TYPE_UINT32ARRAY = 'ui32';\nvar TYPE_FLOAT32ARRAY = 'fl32';\nvar TYPE_FLOAT64ARRAY = 'fl64';\nvar TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n\nvar toString$1 = Object.prototype.toString;\n\nfunction stringToBuffer(serializedString) {\n    // Fill the string into a ArrayBuffer.\n    var bufferLength = serializedString.length * 0.75;\n    var len = serializedString.length;\n    var i;\n    var p = 0;\n    var encoded1, encoded2, encoded3, encoded4;\n\n    if (serializedString[serializedString.length - 1] === '=') {\n        bufferLength--;\n        if (serializedString[serializedString.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n\n    var buffer = new ArrayBuffer(bufferLength);\n    var bytes = new Uint8Array(buffer);\n\n    for (i = 0; i < len; i += 4) {\n        encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\n        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\n        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);\n\n        /*jslint bitwise: true */\n        bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n    }\n    return buffer;\n}\n\n// Converts a buffer to a string to store, serialized, in the backend\n// storage library.\nfunction bufferToString(buffer) {\n    // base64-arraybuffer\n    var bytes = new Uint8Array(buffer);\n    var base64String = '';\n    var i;\n\n    for (i = 0; i < bytes.length; i += 3) {\n        /*jslint bitwise: true */\n        base64String += BASE_CHARS[bytes[i] >> 2];\n        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n        base64String += BASE_CHARS[bytes[i + 2] & 63];\n    }\n\n    if (bytes.length % 3 === 2) {\n        base64String = base64String.substring(0, base64String.length - 1) + '=';\n    } else if (bytes.length % 3 === 1) {\n        base64String = base64String.substring(0, base64String.length - 2) + '==';\n    }\n\n    return base64String;\n}\n\n// Serialize a value, afterwards executing a callback (which usually\n// instructs the `setItem()` callback/promise to be executed). This is how\n// we store binary data with localStorage.\nfunction serialize(value, callback) {\n    var valueType = '';\n    if (value) {\n        valueType = toString$1.call(value);\n    }\n\n    // Cannot use `value instanceof ArrayBuffer` or such here, as these\n    // checks fail when running the tests using casper.js...\n    //\n    // TODO: See why those tests fail and use a better solution.\n    if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {\n        // Convert binary arrays to a string and prefix the string with\n        // a special marker.\n        var buffer;\n        var marker = SERIALIZED_MARKER;\n\n        if (value instanceof ArrayBuffer) {\n            buffer = value;\n            marker += TYPE_ARRAYBUFFER;\n        } else {\n            buffer = value.buffer;\n\n            if (valueType === '[object Int8Array]') {\n                marker += TYPE_INT8ARRAY;\n            } else if (valueType === '[object Uint8Array]') {\n                marker += TYPE_UINT8ARRAY;\n            } else if (valueType === '[object Uint8ClampedArray]') {\n                marker += TYPE_UINT8CLAMPEDARRAY;\n            } else if (valueType === '[object Int16Array]') {\n                marker += TYPE_INT16ARRAY;\n            } else if (valueType === '[object Uint16Array]') {\n                marker += TYPE_UINT16ARRAY;\n            } else if (valueType === '[object Int32Array]') {\n                marker += TYPE_INT32ARRAY;\n            } else if (valueType === '[object Uint32Array]') {\n                marker += TYPE_UINT32ARRAY;\n            } else if (valueType === '[object Float32Array]') {\n                marker += TYPE_FLOAT32ARRAY;\n            } else if (valueType === '[object Float64Array]') {\n                marker += TYPE_FLOAT64ARRAY;\n            } else {\n                callback(new Error('Failed to get type for BinaryArray'));\n            }\n        }\n\n        callback(marker + bufferToString(buffer));\n    } else if (valueType === '[object Blob]') {\n        // Conver the blob to a binaryArray and then to a string.\n        var fileReader = new FileReader();\n\n        fileReader.onload = function () {\n            // Backwards-compatible prefix for the blob type.\n            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);\n\n            callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n        };\n\n        fileReader.readAsArrayBuffer(value);\n    } else {\n        try {\n            callback(JSON.stringify(value));\n        } catch (e) {\n            console.error(\"Couldn't convert value into a JSON string: \", value);\n\n            callback(null, e);\n        }\n    }\n}\n\n// Deserialize data we've inserted into a value column/field. We place\n// special markers into our strings to mark them as encoded; this isn't\n// as nice as a meta field, but it's the only sane thing we can do whilst\n// keeping localStorage support intact.\n//\n// Oftentimes this will just deserialize JSON content, but if we have a\n// special marker (SERIALIZED_MARKER, defined above), we will extract\n// some kind of arraybuffer/binary data/typed array out of the string.\nfunction deserialize(value) {\n    // If we haven't marked this string as being specially serialized (i.e.\n    // something other than serialized JSON), we can just return it and be\n    // done with it.\n    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n        return JSON.parse(value);\n    }\n\n    // The following code deals with deserializing some kind of Blob or\n    // TypedArray. First we separate out the type of data we're dealing\n    // with from the data itself.\n    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\n\n    var blobType;\n    // Backwards-compatible blob type serialization strategy.\n    // DBs created with older versions of localForage will simply not have the blob type.\n    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\n        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\n        blobType = matcher[1];\n        serializedString = serializedString.substring(matcher[0].length);\n    }\n    var buffer = stringToBuffer(serializedString);\n\n    // Return the right type based on the code/type set during\n    // serialization.\n    switch (type) {\n        case TYPE_ARRAYBUFFER:\n            return buffer;\n        case TYPE_BLOB:\n            return createBlob([buffer], { type: blobType });\n        case TYPE_INT8ARRAY:\n            return new Int8Array(buffer);\n        case TYPE_UINT8ARRAY:\n            return new Uint8Array(buffer);\n        case TYPE_UINT8CLAMPEDARRAY:\n            return new Uint8ClampedArray(buffer);\n        case TYPE_INT16ARRAY:\n            return new Int16Array(buffer);\n        case TYPE_UINT16ARRAY:\n            return new Uint16Array(buffer);\n        case TYPE_INT32ARRAY:\n            return new Int32Array(buffer);\n        case TYPE_UINT32ARRAY:\n            return new Uint32Array(buffer);\n        case TYPE_FLOAT32ARRAY:\n            return new Float32Array(buffer);\n        case TYPE_FLOAT64ARRAY:\n            return new Float64Array(buffer);\n        default:\n            throw new Error('Unkown type: ' + type);\n    }\n}\n\nvar localforageSerializer = {\n    serialize: serialize,\n    deserialize: deserialize,\n    stringToBuffer: stringToBuffer,\n    bufferToString: bufferToString\n};\n\n/*\n * Includes code from:\n *\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n// Open the WebSQL database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage$1(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];\n        }\n    }\n\n    var dbInfoPromise = new Promise$1(function (resolve, reject) {\n        // Open the database; the openDatabase API will automatically\n        // create it for us if it doesn't exist.\n        try {\n            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);\n        } catch (e) {\n            return reject(e);\n        }\n\n        // Create our key/value table if it doesn't exist.\n        dbInfo.db.transaction(function (t) {\n            t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' (id INTEGER PRIMARY KEY, key unique, value)', [], function () {\n                self._dbInfo = dbInfo;\n                resolve();\n            }, function (t, error) {\n                reject(error);\n            });\n        });\n    });\n\n    dbInfo.serializer = localforageSerializer;\n    return dbInfoPromise;\n}\n\nfunction getItem$1(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).value : null;\n\n                    // Check to see if this is serialized content we need to\n                    // unpack.\n                    if (result) {\n                        result = dbInfo.serializer.deserialize(result);\n                    }\n\n                    resolve(result);\n                }, function (t, error) {\n\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction iterate$1(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var rows = results.rows;\n                    var length = rows.length;\n\n                    for (var i = 0; i < length; i++) {\n                        var item = rows.item(i);\n                        var result = item.value;\n\n                        // Check to see if this is serialized content\n                        // we need to unpack.\n                        if (result) {\n                            result = dbInfo.serializer.deserialize(result);\n                        }\n\n                        result = iterator(result, item.key, i + 1);\n\n                        // void(0) prevents problems with redefinition\n                        // of `undefined`.\n                        if (result !== void 0) {\n                            resolve(result);\n                            return;\n                        }\n                    }\n\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction _setItem(key, value, callback, retriesLeft) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            // The localStorage API doesn't return undefined values in an\n            // \"expected\" way, so undefined is always cast to null in all\n            // drivers. See: https://github.com/mozilla/localForage/pull/42\n            if (value === undefined) {\n                value = null;\n            }\n\n            // Save the original value to pass to the callback.\n            var originalValue = value;\n\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    dbInfo.db.transaction(function (t) {\n                        t.executeSql('INSERT OR REPLACE INTO ' + dbInfo.storeName + ' (key, value) VALUES (?, ?)', [key, value], function () {\n                            resolve(originalValue);\n                        }, function (t, error) {\n                            reject(error);\n                        });\n                    }, function (sqlError) {\n                        // The transaction failed; check\n                        // to see if it's a quota error.\n                        if (sqlError.code === sqlError.QUOTA_ERR) {\n                            // We reject the callback outright for now, but\n                            // it's worth trying to re-run the transaction.\n                            // Even if the user accepts the prompt to use\n                            // more storage on Safari, this error will\n                            // be called.\n                            //\n                            // Try to re-run the transaction.\n                            if (retriesLeft > 0) {\n                                resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));\n                                return;\n                            }\n                            reject(sqlError);\n                        }\n                    });\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction setItem$1(key, value, callback) {\n    return _setItem.apply(this, [key, value, callback, 1]);\n}\n\nfunction removeItem$1(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {\n                    resolve();\n                }, function (t, error) {\n\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Deletes every item in the table.\n// TODO: Find out if this resets the AUTO_INCREMENT number.\nfunction clear$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('DELETE FROM ' + dbInfo.storeName, [], function () {\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Does a simple `COUNT(key)` to get the number of items stored in\n// localForage.\nfunction length$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                // Ahhh, SQL makes this one soooooo easy.\n                t.executeSql('SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var result = results.rows.item(0).c;\n\n                    resolve(result);\n                }, function (t, error) {\n\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Return the key located at key index X; essentially gets the key from a\n// `WHERE id = ?`. This is the most efficient way I can think to implement\n// this rarely-used (in my experience) part of the API, but it can seem\n// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n// the ID of each key will change every time it's updated. Perhaps a stored\n// procedure for the `setItem()` SQL would solve this problem?\n// TODO: Don't change ID on `setItem()`.\nfunction key$1(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).key : null;\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var keys = [];\n\n                    for (var i = 0; i < results.rows.length; i++) {\n                        keys.push(results.rows.item(i).key);\n                    }\n\n                    resolve(keys);\n                }, function (t, error) {\n\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar webSQLStorage = {\n    _driver: 'webSQLStorage',\n    _initStorage: _initStorage$1,\n    iterate: iterate$1,\n    getItem: getItem$1,\n    setItem: setItem$1,\n    removeItem: removeItem$1,\n    clear: clear$1,\n    length: length$1,\n    key: key$1,\n    keys: keys$1\n};\n\n// Config the localStorage backend, using options set in the config.\nfunction _initStorage$2(options) {\n    var self = this;\n    var dbInfo = {};\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    dbInfo.keyPrefix = dbInfo.name + '/';\n\n    if (dbInfo.storeName !== self._defaultConfig.storeName) {\n        dbInfo.keyPrefix += dbInfo.storeName + '/';\n    }\n\n    self._dbInfo = dbInfo;\n    dbInfo.serializer = localforageSerializer;\n\n    return Promise$1.resolve();\n}\n\n// Remove all keys from the datastore, effectively destroying all data in\n// the app's key/value store!\nfunction clear$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var keyPrefix = self._dbInfo.keyPrefix;\n\n        for (var i = localStorage.length - 1; i >= 0; i--) {\n            var key = localStorage.key(i);\n\n            if (key.indexOf(keyPrefix) === 0) {\n                localStorage.removeItem(key);\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Retrieve an item from the store. Unlike the original async_storage\n// library in Gaia, we don't modify return values at all. If a key's value\n// is `undefined`, we pass that value to the callback function.\nfunction getItem$2(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result = localStorage.getItem(dbInfo.keyPrefix + key);\n\n        // If a result was found, parse it from the serialized\n        // string into a JS object. If result isn't truthy, the key\n        // is likely undefined and we'll pass it straight to the\n        // callback.\n        if (result) {\n            result = dbInfo.serializer.deserialize(result);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items in the store.\nfunction iterate$2(iterator, callback) {\n    var self = this;\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var keyPrefix = dbInfo.keyPrefix;\n        var keyPrefixLength = keyPrefix.length;\n        var length = localStorage.length;\n\n        // We use a dedicated iterator instead of the `i` variable below\n        // so other keys we fetch in localStorage aren't counted in\n        // the `iterationNumber` argument passed to the `iterate()`\n        // callback.\n        //\n        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n        var iterationNumber = 1;\n\n        for (var i = 0; i < length; i++) {\n            var key = localStorage.key(i);\n            if (key.indexOf(keyPrefix) !== 0) {\n                continue;\n            }\n            var value = localStorage.getItem(key);\n\n            // If a result was found, parse it from the serialized\n            // string into a JS object. If result isn't truthy, the\n            // key is likely undefined and we'll pass it straight\n            // to the iterator.\n            if (value) {\n                value = dbInfo.serializer.deserialize(value);\n            }\n\n            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);\n\n            if (value !== void 0) {\n                return value;\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Same as localStorage's key() method, except takes a callback.\nfunction key$2(n, callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result;\n        try {\n            result = localStorage.key(n);\n        } catch (error) {\n            result = null;\n        }\n\n        // Remove the prefix from the key, if a key is found.\n        if (result) {\n            result = result.substring(dbInfo.keyPrefix.length);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var length = localStorage.length;\n        var keys = [];\n\n        for (var i = 0; i < length; i++) {\n            if (localStorage.key(i).indexOf(dbInfo.keyPrefix) === 0) {\n                keys.push(localStorage.key(i).substring(dbInfo.keyPrefix.length));\n            }\n        }\n\n        return keys;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Supply the number of keys in the datastore to the callback function.\nfunction length$2(callback) {\n    var self = this;\n    var promise = self.keys().then(function (keys) {\n        return keys.length;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Remove an item from the store, nice and simple.\nfunction removeItem$2(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        localStorage.removeItem(dbInfo.keyPrefix + key);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Set a key's value and run an optional callback once the value is set.\n// Unlike Gaia's implementation, the callback function is passed the value,\n// in case you want to operate on that value only after you're sure it\n// saved, or something like that.\nfunction setItem$2(key, value, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = self.ready().then(function () {\n        // Convert undefined values to null.\n        // https://github.com/mozilla/localForage/pull/42\n        if (value === undefined) {\n            value = null;\n        }\n\n        // Save the original value to pass to the callback.\n        var originalValue = value;\n\n        return new Promise$1(function (resolve, reject) {\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    try {\n                        localStorage.setItem(dbInfo.keyPrefix + key, value);\n                        resolve(originalValue);\n                    } catch (e) {\n                        // localStorage capacity exceeded.\n                        // TODO: Make this a specific error/event.\n                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\n                            reject(e);\n                        }\n                        reject(e);\n                    }\n                }\n            });\n        });\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar localStorageWrapper = {\n    _driver: 'localStorageWrapper',\n    _initStorage: _initStorage$2,\n    // Default API, from Gaia/localStorage.\n    iterate: iterate$2,\n    getItem: getItem$2,\n    setItem: setItem$2,\n    removeItem: removeItem$2,\n    clear: clear$2,\n    length: length$2,\n    key: key$2,\n    keys: keys$2\n};\n\n// Custom drivers are stored here when `defineDriver()` is called.\n// They are shared across all instances of localForage.\nvar CustomDrivers = {};\n\nvar DriverType = {\n    INDEXEDDB: 'asyncStorage',\n    LOCALSTORAGE: 'localStorageWrapper',\n    WEBSQL: 'webSQLStorage'\n};\n\nvar DefaultDriverOrder = [DriverType.INDEXEDDB, DriverType.WEBSQL, DriverType.LOCALSTORAGE];\n\nvar LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'];\n\nvar DefaultConfig = {\n    description: '',\n    driver: DefaultDriverOrder.slice(),\n    name: 'localforage',\n    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\n    // we can use without a prompt.\n    size: 4980736,\n    storeName: 'keyvaluepairs',\n    version: 1.0\n};\n\nvar driverSupport = {};\n// Check to see if IndexedDB is available and if it is the latest\n// implementation; it's our preferred backend library. We use \"_spec_test\"\n// as the name of the database because it's not the one we'll operate on,\n// but it's useful to make sure its using the right spec.\n// See: https://github.com/mozilla/localForage/issues/128\ndriverSupport[DriverType.INDEXEDDB] = isIndexedDBValid();\n\ndriverSupport[DriverType.WEBSQL] = isWebSQLValid();\n\ndriverSupport[DriverType.LOCALSTORAGE] = isLocalStorageValid();\n\nvar isArray = Array.isArray || function (arg) {\n    return Object.prototype.toString.call(arg) === '[object Array]';\n};\n\nfunction callWhenReady(localForageInstance, libraryMethod) {\n    localForageInstance[libraryMethod] = function () {\n        var _args = arguments;\n        return localForageInstance.ready().then(function () {\n            return localForageInstance[libraryMethod].apply(localForageInstance, _args);\n        });\n    };\n}\n\nfunction extend() {\n    for (var i = 1; i < arguments.length; i++) {\n        var arg = arguments[i];\n\n        if (arg) {\n            for (var key in arg) {\n                if (arg.hasOwnProperty(key)) {\n                    if (isArray(arg[key])) {\n                        arguments[0][key] = arg[key].slice();\n                    } else {\n                        arguments[0][key] = arg[key];\n                    }\n                }\n            }\n        }\n    }\n\n    return arguments[0];\n}\n\nfunction isLibraryDriver(driverName) {\n    for (var driver in DriverType) {\n        if (DriverType.hasOwnProperty(driver) && DriverType[driver] === driverName) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nvar LocalForage = function () {\n    function LocalForage(options) {\n        _classCallCheck(this, LocalForage);\n\n        this.INDEXEDDB = DriverType.INDEXEDDB;\n        this.LOCALSTORAGE = DriverType.LOCALSTORAGE;\n        this.WEBSQL = DriverType.WEBSQL;\n\n        this._defaultConfig = extend({}, DefaultConfig);\n        this._config = extend({}, this._defaultConfig, options);\n        this._driverSet = null;\n        this._initDriver = null;\n        this._ready = false;\n        this._dbInfo = null;\n\n        this._wrapLibraryMethodsWithReady();\n        this.setDriver(this._config.driver)[\"catch\"](function () {});\n    }\n\n    // Set any config values for localForage; can be called anytime before\n    // the first API call (e.g. `getItem`, `setItem`).\n    // We loop through options so we don't overwrite existing config\n    // values.\n\n\n    LocalForage.prototype.config = function config(options) {\n        // If the options argument is an object, we use it to set values.\n        // Otherwise, we return either a specified config value or all\n        // config values.\n        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n            // If localforage is ready and fully initialized, we can't set\n            // any new configuration values. Instead, we return an error.\n            if (this._ready) {\n                return new Error(\"Can't call config() after localforage \" + 'has been used.');\n            }\n\n            for (var i in options) {\n                if (i === 'storeName') {\n                    options[i] = options[i].replace(/\\W/g, '_');\n                }\n\n                if (i === 'version' && typeof options[i] !== 'number') {\n                    return new Error('Database version must be a number.');\n                }\n\n                this._config[i] = options[i];\n            }\n\n            // after all config options are set and\n            // the driver option is used, try setting it\n            if ('driver' in options && options.driver) {\n                return this.setDriver(this._config.driver);\n            }\n\n            return true;\n        } else if (typeof options === 'string') {\n            return this._config[options];\n        } else {\n            return this._config;\n        }\n    };\n\n    // Used to define a custom driver, shared across all instances of\n    // localForage.\n\n\n    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {\n        var promise = new Promise$1(function (resolve, reject) {\n            try {\n                var driverName = driverObject._driver;\n                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');\n                var namingError = new Error('Custom driver name already in use: ' + driverObject._driver);\n\n                // A driver name should be defined and not overlap with the\n                // library-defined, default drivers.\n                if (!driverObject._driver) {\n                    reject(complianceError);\n                    return;\n                }\n                if (isLibraryDriver(driverObject._driver)) {\n                    reject(namingError);\n                    return;\n                }\n\n                var customDriverMethods = LibraryMethods.concat('_initStorage');\n                for (var i = 0; i < customDriverMethods.length; i++) {\n                    var customDriverMethod = customDriverMethods[i];\n                    if (!customDriverMethod || !driverObject[customDriverMethod] || typeof driverObject[customDriverMethod] !== 'function') {\n                        reject(complianceError);\n                        return;\n                    }\n                }\n\n                var supportPromise = Promise$1.resolve(true);\n                if ('_support' in driverObject) {\n                    if (driverObject._support && typeof driverObject._support === 'function') {\n                        supportPromise = driverObject._support();\n                    } else {\n                        supportPromise = Promise$1.resolve(!!driverObject._support);\n                    }\n                }\n\n                supportPromise.then(function (supportResult) {\n                    driverSupport[driverName] = supportResult;\n                    CustomDrivers[driverName] = driverObject;\n                    resolve();\n                }, reject);\n            } catch (e) {\n                reject(e);\n            }\n        });\n\n        executeTwoCallbacks(promise, callback, errorCallback);\n        return promise;\n    };\n\n    LocalForage.prototype.driver = function driver() {\n        return this._driver || null;\n    };\n\n    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {\n        var self = this;\n        var getDriverPromise = Promise$1.resolve().then(function () {\n            if (isLibraryDriver(driverName)) {\n                switch (driverName) {\n                    case self.INDEXEDDB:\n                        return asyncStorage;\n                    case self.LOCALSTORAGE:\n                        return localStorageWrapper;\n                    case self.WEBSQL:\n                        return webSQLStorage;\n                }\n            } else if (CustomDrivers[driverName]) {\n                return CustomDrivers[driverName];\n            } else {\n                throw new Error('Driver not found.');\n            }\n        });\n        executeTwoCallbacks(getDriverPromise, callback, errorCallback);\n        return getDriverPromise;\n    };\n\n    LocalForage.prototype.getSerializer = function getSerializer(callback) {\n        var serializerPromise = Promise$1.resolve(localforageSerializer);\n        executeTwoCallbacks(serializerPromise, callback);\n        return serializerPromise;\n    };\n\n    LocalForage.prototype.ready = function ready(callback) {\n        var self = this;\n\n        var promise = self._driverSet.then(function () {\n            if (self._ready === null) {\n                self._ready = self._initDriver();\n            }\n\n            return self._ready;\n        });\n\n        executeTwoCallbacks(promise, callback, callback);\n        return promise;\n    };\n\n    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {\n        var self = this;\n\n        if (!isArray(drivers)) {\n            drivers = [drivers];\n        }\n\n        var supportedDrivers = this._getSupportedDrivers(drivers);\n\n        function setDriverToConfig() {\n            self._config.driver = self.driver();\n        }\n\n        function extendSelfWithDriver(driver) {\n            self._extend(driver);\n            setDriverToConfig();\n\n            self._ready = self._initStorage(self._config);\n            return self._ready;\n        }\n\n        function initDriver(supportedDrivers) {\n            return function () {\n                var currentDriverIndex = 0;\n\n                function driverPromiseLoop() {\n                    while (currentDriverIndex < supportedDrivers.length) {\n                        var driverName = supportedDrivers[currentDriverIndex];\n                        currentDriverIndex++;\n\n                        self._dbInfo = null;\n                        self._ready = null;\n\n                        return self.getDriver(driverName).then(extendSelfWithDriver)[\"catch\"](driverPromiseLoop);\n                    }\n\n                    setDriverToConfig();\n                    var error = new Error('No available storage method found.');\n                    self._driverSet = Promise$1.reject(error);\n                    return self._driverSet;\n                }\n\n                return driverPromiseLoop();\n            };\n        }\n\n        // There might be a driver initialization in progress\n        // so wait for it to finish in order to avoid a possible\n        // race condition to set _dbInfo\n        var oldDriverSetDone = this._driverSet !== null ? this._driverSet[\"catch\"](function () {\n            return Promise$1.resolve();\n        }) : Promise$1.resolve();\n\n        this._driverSet = oldDriverSetDone.then(function () {\n            var driverName = supportedDrivers[0];\n            self._dbInfo = null;\n            self._ready = null;\n\n            return self.getDriver(driverName).then(function (driver) {\n                self._driver = driver._driver;\n                setDriverToConfig();\n                self._wrapLibraryMethodsWithReady();\n                self._initDriver = initDriver(supportedDrivers);\n            });\n        })[\"catch\"](function () {\n            setDriverToConfig();\n            var error = new Error('No available storage method found.');\n            self._driverSet = Promise$1.reject(error);\n            return self._driverSet;\n        });\n\n        executeTwoCallbacks(this._driverSet, callback, errorCallback);\n        return this._driverSet;\n    };\n\n    LocalForage.prototype.supports = function supports(driverName) {\n        return !!driverSupport[driverName];\n    };\n\n    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {\n        extend(this, libraryMethodsAndProperties);\n    };\n\n    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {\n        var supportedDrivers = [];\n        for (var i = 0, len = drivers.length; i < len; i++) {\n            var driverName = drivers[i];\n            if (this.supports(driverName)) {\n                supportedDrivers.push(driverName);\n            }\n        }\n        return supportedDrivers;\n    };\n\n    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {\n        // Add a stub for each driver API method that delays the call to the\n        // corresponding driver method until localForage is ready. These stubs\n        // will be replaced by the driver methods as soon as the driver is\n        // loaded, so there is no performance impact.\n        for (var i = 0; i < LibraryMethods.length; i++) {\n            callWhenReady(this, LibraryMethods[i]);\n        }\n    };\n\n    LocalForage.prototype.createInstance = function createInstance(options) {\n        return new LocalForage(options);\n    };\n\n    return LocalForage;\n}();\n\n// The actual localForage object that we expose as a module or via a\n// global. It's extended by pulling in one of our other libraries.\n\n\nvar localforage_js = new LocalForage();\n\nmodule.exports = localforage_js;\n\n},{\"3\":3}]},{},[4])(4)\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/localforage/dist/localforage.js\n// module id = 29\n// module chunks = 1","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 30\n// module chunks = 1","/**\n * pushToggle.js\n * \n * Deals with the toggle used to Toggle Subscription from On and Off\n * It also Disables the toggle in case it's not supported with appropriate error messages\n * \n * Displaying the status text within this card, also makes sure that this \n * card is calibrated enough with the application state, which we want to make sure\n * is always the case.\n * \n * This card is going to rely on running from the beginning and thus makes \n * no assumption of having subscription state, being stored anywhere\n */\n\nconst card = document.querySelector('.subscription-toggle');\nconst subscriptionStatus = card.querySelector('.subscription-status');\nconst subscriptionSwitch = card.querySelector('input');\nconst subscriptionLabel = subscriptionSwitch.parentNode;\n\nconst NOT_SUPPORTED_TEXT = 'Relevant APIs are not supported';\nconst ENABLED_ON_TEXT = 'On';\nconst ENABLED_OFF_TEXT = 'Off';\n\nfunction changeSwitch(on) {\n  on = !!on;\n  updateStatus(on ? ENABLED_ON_TEXT : ENABLED_OFF_TEXT);\n  subscriptionSwitch.checked = on;\n  on ? subscriptionLabel.classList.add('is-checked')\n    : subscriptionLabel.classList.remove('is-checked');\n}\n\n/**\n * Enable or disable the Material Design Switch based on the\n * enable parameter passed\n */\nfunction enableSwitch(enable) {\n  // Explicit conversion to type Boolean\n  const enabledBool = !!enable;\n  subscriptionSwitch.disabled = !enabledBool;\n  \n  if (!enabledBool) {\n    subscriptionLabel.classList.remove('is-checked');\n    subscriptionLabel.classList.add('is-disabled');\n    updateStatus(NOT_SUPPORTED_TEXT);\n    subscriptionSwitch.checked = false;\n  } else {\n    updateStatus(subscriptionSwitch.checked ? ENABLED_ON_TEXT : ENABLED_OFF_TEXT);\n    subscriptionLabel.classList.remove('is-disabled');\n  }\n}\n\n/**\n * In order to wait for the operation to complete\n * before anyother operation is started\n * `waitToggle` disables the toggle so it can't be used\n */\nfunction waitToggle() {\n  subscriptionSwitch.disabled = true;\n  subscriptionLabel.classList.add('is-disabled');\n}\n\n/**\n * Updates the Statu of the text in the card\n */\nfunction updateStatus(status) {\n  subscriptionStatus.textContent = status;\n}\n\n/**\n * Updates the Switch Status and enables or disabled according\n * to the parameters\n */\nfunction updateSwitch(pushSubscription) {\n  enableSwitch(true);\n  changeSwitch(!!pushSubscription);\n}\n\nexport { updateSwitch, enableSwitch, subscriptionSwitch, waitToggle };\n\n\n// WEBPACK FOOTER //\n// ./src/app/pushToggle.js","/**\n * Module for handling the Card with PushSubscription information\n */\nconst subscriptionInfoCard = document.querySelector('.subscription-info');\n\nconst serverInfo = subscriptionInfoCard.querySelector('.code.server-subscription');\nconst subscriptionInfo = subscriptionInfoCard.querySelector('.code.info');\nconst serverId = subscriptionInfoCard.querySelector('.code.server-id');\n\n/**\n * Displays the Push Info\n */\nfunction displayPushInfo(pushSubscription) {\n  if (!pushSubscription) {\n    subscriptionInfoCard.style.display = 'none';\n    return;\n  }\n\n  if (pushSubscription) {\n    subscriptionInfoCard.style.display = '';\n    subscriptionInfo.innerHTML = JSON.stringify(pushSubscription, null, 4);\n  }\n}\n\nfunction displayServerId(id) {\n  serverId.innerHTML = id;\n}\n\nfunction displayServerResponse(response) {\n  serverId.innerHTML = response._id;\n  serverInfo.innerHTML = JSON.stringify(response, null, 4);\n}\n\nfunction displayServerError() {\n  serverId.innerHTML = 'Error occured';\n  serverInfo.innerHTML = 'Error occured';\n}\n\nexport { displayPushInfo, displayServerId, displayServerResponse, displayServerError };\n\n\n// WEBPACK FOOTER //\n// ./src/app/pushInfo.js","/**\n * serverSubscriptoin.js\n * Library to perform CRUD operations on the subscriptions on server\n */\nimport axios from 'axios';\n\nconst SERVER_BASE_URL = process.env.DEFAULT_SERVER_URL;\nconst subscriberURL = SERVER_BASE_URL + 'subscriber';\n/**\n * Creates the Subscription on the Server \n * `subscription` is passed as body\n */\nfunction createSubscription (subscription) {\n  return axios.post(subscriberURL, {\n    subscription: JSON.parse(JSON.stringify(subscription))\n  });\n}\n\nfunction deleteSubscription (subscriptionId) {\n  return axios.delete(subscriberURL, {\n    data: {\n      id: subscriptionId\n    },\n    responseType: 'json',\n  });\n}\n\nfunction getSubscription (subscriptionId) {\n  return axios.get(subscriberURL, { params: { id: subscriptionId }});\n}\n\nexport default  { createSubscription, getSubscription, deleteSubscription };\n\n\n// WEBPACK FOOTER //\n// ./src/app/serverSubscription.js","module.exports = __webpack_public_path__ + \"service-worker.js\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/file-loader?name=[name].[ext]!./src/app/service-worker.js\n// module id = 34\n// module chunks = 1"],"sourceRoot":""}